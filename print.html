<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Junita UI Framework</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="A GPU-accelerated, reactive UI framework for Rust">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex-9be82478.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-208d0d01.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">Junita UI Framework</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>
                        <a href="https://github.com/iamqiss/Junita" title="Git repository" aria-label="Git repository">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p><strong>Junita</strong> is a GPU-accelerated, reactive UI framework for Rust. It provides a declarative, component-based approach to building high-performance user interfaces with smooth animations and modern visual effects.</p>
<h2 id="why-junita"><a class="header" href="#why-junita">Why Junita?</a></h2>
<ul>
<li>
<p><strong>GPU-Accelerated Rendering</strong> - All rendering is done on the GPU via wgpu, enabling smooth 60fps animations and complex visual effects like glass materials and shadows.</p>
</li>
<li>
<p><strong>Declarative UI</strong> - Build interfaces using a fluent, composable API inspired by SwiftUI and modern web frameworks. No manual DOM manipulation.</p>
</li>
<li>
<p><strong>Reactive State</strong> - Automatic UI updates when state changes, with fine-grained reactivity for optimal performance.</p>
</li>
<li>
<p><strong>Spring Physics</strong> - Natural, physics-based animations using spring dynamics instead of fixed durations.</p>
</li>
<li>
<p><strong>Cross-Platform</strong> - Runs on macOS, Windows, Linux, and Android (iOS coming soon).</p>
</li>
</ul>
<h2 id="key-features"><a class="header" href="#key-features">Key Features</a></h2>
<h3 id="flexbox-layout"><a class="header" href="#flexbox-layout">Flexbox Layout</a></h3>
<p>All layout is powered by <a href="https://github.com/DioxusLabs/taffy">Taffy</a>, a high-performance flexbox implementation. Use familiar CSS-like properties:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>div()
    .flex_col()
    .gap(16.0)
    .p(24.0)
    .child(text("Hello"))
    .child(text("World"))
<span class="boring">}</span></code></pre>
<h3 id="material-effects"><a class="header" href="#material-effects">Material Effects</a></h3>
<p>Built-in support for glass, metallic, and other material effects:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>div()
    .glass()
    .rounded(16.0)
    .p(24.0)
    .child(text("Frosted Glass"))
<span class="boring">}</span></code></pre>
<h3 id="type-safe-animations"><a class="header" href="#type-safe-animations">Type-Safe Animations</a></h3>
<p>The <code>JunitaComponent</code> derive macro generates type-safe animation hooks:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(JunitaComponent)]
struct MyCard {
    #[animation]
    scale: f32,
    #[animation]
    opacity: f32,
}

// Usage
let scale = MyCard::use_scale(ctx, 1.0, SpringConfig::snappy());
let opacity = MyCard::use_opacity(ctx, 0.0, SpringConfig::gentle());
<span class="boring">}</span></code></pre>
<h3 id="event-handling"><a class="header" href="#event-handling">Event Handling</a></h3>
<p>Intuitive event handling with closures:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>div()
    .on_click(|_| println!("Clicked!"))
    .on_hover_enter(|_| println!("Hovered"))
<span class="boring">}</span></code></pre>
<h2 id="architecture-overview"><a class="header" href="#architecture-overview">Architecture Overview</a></h2>
<pre><code>┌─────────────────────────────────────────────────────┐
│                   Your Application                   │
├─────────────────────────────────────────────────────┤
│  junita_app   │  WindowedApp, Context, State Hooks   │
├──────────────┼──────────────────────────────────────┤
│  junita_layout│  Elements, Flexbox, Event Routing    │
├──────────────┼──────────────────────────────────────┤
│  junita_animation │  Springs, Timelines, Motion      │
├──────────────┼──────────────────────────────────────┤
│  junita_gpu   │  Render Pipeline, Materials          │
├──────────────┼──────────────────────────────────────┤
│  wgpu        │  GPU Abstraction Layer               │
└─────────────────────────────────────────────────────┘
</code></pre>
<h2 id="quick-example"><a class="header" href="#quick-example">Quick Example</a></h2>
<p>Here’s a minimal Junita application:</p>
<pre class="playground"><code class="language-rust">use junita_app::prelude::*;
use junita_app::windowed::{WindowedApp, WindowedContext};

fn main() -&gt; Result&lt;()&gt; {
    WindowedApp::run(WindowConfig::default(), |ctx| {
        div()
            .w(ctx.width)
            .h(ctx.height)
            .bg(Color::rgba(0.1, 0.1, 0.15, 1.0))
            .flex_center()
            .child(
                div()
                    .glass()
                    .rounded(16.0)
                    .p(32.0)
                    .child(text("Hello, Junita!").size(24.0).color(Color::WHITE))
            )
    })
}</code></pre>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<ul>
<li><a href="#installation">Installation</a> - Set up your development environment</li>
<li><a href="#your-first-app">Your First App</a> - Build a complete application step by step</li>
<li><a href="#elements--layout">Elements &amp; Layout</a> - Learn about available UI elements</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<p>Junita requires:</p>
<ul>
<li><strong>Rust 1.70+</strong> (for stable async and other features)</li>
<li>A GPU with Vulkan, Metal, or DX12 support</li>
</ul>
<h2 id="adding-junita-to-your-project"><a class="header" href="#adding-junita-to-your-project">Adding Junita to Your Project</a></h2>
<p>Add <code>junita_app</code> to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
junita_app = { version = "0.1", features = ["windowed"] }
</code></pre>
<p>The <code>windowed</code> feature enables desktop windowing support. For headless rendering (e.g., server-side), omit this feature.</p>
<h2 id="feature-flags"><a class="header" href="#feature-flags">Feature Flags</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Feature</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>windowed</code></td><td>Desktop window support via winit (default)</td></tr>
<tr><td><code>android</code></td><td>Android platform support</td></tr>
</tbody>
</table>
</div>
<h2 id="verifying-installation"><a class="header" href="#verifying-installation">Verifying Installation</a></h2>
<p>Create a simple test application:</p>
<pre class="playground"><code class="language-rust">// src/main.rs
use junita_app::prelude::*;
use junita_app::windowed::{WindowedApp, WindowedContext};

fn main() -&gt; Result&lt;()&gt; {
    WindowedApp::run(WindowConfig::default(), |ctx| {
        div()
            .w(ctx.width)
            .h(ctx.height)
            .bg(Color::rgba(0.1, 0.1, 0.15, 1.0))
            .flex_center()
            .child(text("Junita is working!").size(32.0).color(Color::WHITE))
    })
}</code></pre>
<p>Run with:</p>
<pre><code class="language-bash">cargo run
</code></pre>
<p>You should see a window with “Junita is working!” displayed in the center.</p>
<h2 id="recommended-dev-dependencies"><a class="header" href="#recommended-dev-dependencies">Recommended Dev Dependencies</a></h2>
<p>For a better development experience, add these to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dev-dependencies]
tracing-subscriber = "0.3"
</code></pre>
<p>Then initialize logging in your app:</p>
<pre class="playground"><code class="language-rust">fn main() -&gt; Result&lt;()&gt; {
    tracing_subscriber::fmt()
        .with_max_level(tracing::Level::INFO)
        .init();

    WindowedApp::run(/* ... */)
}</code></pre>
<h2 id="platform-specific-notes"><a class="header" href="#platform-specific-notes">Platform-Specific Notes</a></h2>
<h3 id="macos"><a class="header" href="#macos">macOS</a></h3>
<p>No additional setup required. Junita uses Metal for GPU rendering.</p>
<h3 id="windows"><a class="header" href="#windows">Windows</a></h3>
<p>Ensure you have up-to-date GPU drivers. Junita uses DX12 by default, falling back to Vulkan.</p>
<h3 id="linux"><a class="header" href="#linux">Linux</a></h3>
<p>Install Vulkan development libraries:</p>
<pre><code class="language-bash"># Ubuntu/Debian
sudo apt install libvulkan-dev

# Fedora
sudo dnf install vulkan-devel

# Arch
sudo pacman -S vulkan-icd-loader
</code></pre>
<h3 id="android"><a class="header" href="#android">Android</a></h3>
<p>See the Android platform guide for cross-compilation setup.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="your-first-app"><a class="header" href="#your-first-app">Your First App</a></h1>
<p>Let’s build a simple counter application to learn Junita fundamentals.</p>
<h2 id="the-basic-structure"><a class="header" href="#the-basic-structure">The Basic Structure</a></h2>
<p>Every Junita windowed application follows this pattern:</p>
<pre class="playground"><code class="language-rust">use junita_app::prelude::*;
use junita_app::windowed::{WindowedApp, WindowedContext};

fn main() -&gt; Result&lt;()&gt; {
    WindowedApp::run(WindowConfig::default(), |ctx| {
        // Your UI goes here
        build_ui(ctx)
    })
}

fn build_ui(ctx: &amp;WindowedContext) -&gt; impl ElementBuilder {
    div()
        .w(ctx.width)
        .h(ctx.height)
        // ... children
}</code></pre>
<p>The <code>WindowedApp::run</code> function:</p>
<ol>
<li>Creates a window with the given configuration</li>
<li>Sets up the GPU renderer</li>
<li>Calls your UI builder function when needed</li>
<li>Handles events and animations automatically</li>
</ol>
<h2 id="building-a-counter"><a class="header" href="#building-a-counter">Building a Counter</a></h2>
<p>Let’s create a counter with increment and decrement buttons.</p>
<h3 id="step-1-window-configuration"><a class="header" href="#step-1-window-configuration">Step 1: Window Configuration</a></h3>
<pre class="playground"><code class="language-rust">use junita_app::prelude::*;
use junita_app::windowed::{WindowedApp, WindowedContext};

fn main() -&gt; Result&lt;()&gt; {
    let config = WindowConfig {
        title: "Counter App".to_string(),
        width: 400,
        height: 300,
        resizable: true,
        ..Default::default()
    };

    WindowedApp::run(config, |ctx| build_ui(ctx))
}</code></pre>
<h3 id="step-2-creating-state"><a class="header" href="#step-2-creating-state">Step 2: Creating State</a></h3>
<p>Use <code>use_state_keyed</code> to create reactive state that persists across UI rebuilds:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn build_ui(ctx: &amp;WindowedContext) -&gt; impl ElementBuilder {
    // Create keyed state for the count - persists across rebuilds
    let count = ctx.use_state_keyed("counter", || 0i32);

    // State will be read inside stateful elements via .deps()
    // ... rest of UI
}
<span class="boring">}</span></code></pre>
<h3 id="step-3-building-the-layout-with-stateful-elements"><a class="header" href="#step-3-building-the-layout-with-stateful-elements">Step 3: Building the Layout with Stateful Elements</a></h3>
<p>The key insight in Junita is that UI doesn’t rebuild on every state change. Instead, we use <code>stateful(handle)</code> with <code>.deps()</code> to react to state changes:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use junita_layout::stateful::stateful;

fn build_ui(ctx: &amp;WindowedContext) -&gt; impl ElementBuilder {
    let count = ctx.use_state_keyed("counter", || 0i32);
    let container_handle = ctx.use_state(ButtonState::Idle);

    div()
        .w(ctx.width)
        .h(ctx.height)
        .bg(Color::rgba(0.08, 0.08, 0.12, 1.0))
        .flex_col()
        .justify_center()
        .items_center()
        .gap(24.0)
        // Title
        .child(
            text("Counter")
                .size(32.0)
                .weight(FontWeight::Bold)
                .color(Color::WHITE)
        )
        // Count display - uses stateful with deps to update when count changes
        .child(count_display(ctx, count.clone()))
        // Buttons row
        .child(
            div()
                .flex_row()
                .gap(16.0)
                .child(counter_button(ctx, count.clone(), "-", -1))
                .child(counter_button(ctx, count.clone(), "+", 1))
        )
}
<span class="boring">}</span></code></pre>
<h3 id="step-4-creating-the-count-display"><a class="header" href="#step-4-creating-the-count-display">Step 4: Creating the Count Display</a></h3>
<p>The count display needs to update when the count changes. We use <code>stateful(handle)</code> with <code>.deps()</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn count_display(ctx: &amp;WindowedContext, count: State&lt;i32&gt;) -&gt; impl ElementBuilder {
    let handle = ctx.use_state(ButtonState::Idle);

    stateful(handle)
        .deps(&amp;[count.signal_id()])
        .on_state(move |_state, container| {
            let current = count.get();
            container.merge(
                div()
                    .child(
                        text(&amp;format!("{}", current))
                            .size(64.0)
                            .weight(FontWeight::Bold)
                            .color(Color::rgba(0.4, 0.6, 1.0, 1.0))
                    )
            );
        })
}
<span class="boring">}</span></code></pre>
<h3 id="step-5-creating-interactive-buttons"><a class="header" href="#step-5-creating-interactive-buttons">Step 5: Creating Interactive Buttons</a></h3>
<p>For interactive buttons with hover and press states, use <code>stateful(handle)</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn counter_button(
    ctx: &amp;WindowedContext,
    count: State&lt;i32&gt;,
    label: &amp;'static str,
    delta: i32,
) -&gt; impl ElementBuilder {
    // Use use_state_for for reusable components with a unique key
    let handle = ctx.use_state_for(label, ButtonState::Idle);

    stateful(handle)
        .w(60.0)
        .h(60.0)
        .rounded(12.0)
        .flex_center()
        .on_state(|state, div| {
            // Apply different styles based on current state
            let bg = match state {
                ButtonState::Idle =&gt; Color::rgba(0.2, 0.2, 0.25, 1.0),
                ButtonState::Hovered =&gt; Color::rgba(0.3, 0.3, 0.35, 1.0),
                ButtonState::Pressed =&gt; Color::rgba(0.15, 0.15, 0.2, 1.0),
                ButtonState::Disabled =&gt; Color::rgba(0.1, 0.1, 0.12, 0.5),
            };
            div.set_bg(bg);
        })
        .on_click(move |_| {
            count.update(|v| v + delta);
        })
        .child(
            text(label)
                .size(28.0)
                .weight(FontWeight::Bold)
                .color(Color::WHITE)
        )
}
<span class="boring">}</span></code></pre>
<h2 id="complete-example"><a class="header" href="#complete-example">Complete Example</a></h2>
<p>Here’s the full counter application:</p>
<pre class="playground"><code class="language-rust">use junita_app::prelude::*;
use junita_app::windowed::{WindowedApp, WindowedContext};
use junita_layout::stateful::stateful;

fn main() -&gt; Result&lt;()&gt; {
    tracing_subscriber::fmt()
        .with_max_level(tracing::Level::INFO)
        .init();

    let config = WindowConfig {
        title: "Counter App".to_string(),
        width: 400,
        height: 300,
        resizable: true,
        ..Default::default()
    };

    WindowedApp::run(config, |ctx| build_ui(ctx))
}

fn build_ui(ctx: &amp;WindowedContext) -&gt; impl ElementBuilder {
    let count = ctx.use_state_keyed("counter", || 0i32);

    div()
        .w(ctx.width)
        .h(ctx.height)
        .bg(Color::rgba(0.08, 0.08, 0.12, 1.0))
        .flex_col()
        .justify_center()
        .items_center()
        .gap(24.0)
        .child(
            text("Counter")
                .size(32.0)
                .weight(FontWeight::Bold)
                .color(Color::WHITE)
        )
        .child(count_display(ctx, count.clone()))
        .child(
            div()
                .flex_row()
                .gap(16.0)
                .child(counter_button(ctx, count.clone(), "-", -1))
                .child(counter_button(ctx, count.clone(), "+", 1))
        )
}

fn count_display(ctx: &amp;WindowedContext, count: State&lt;i32&gt;) -&gt; impl ElementBuilder {
    let handle = ctx.use_state(ButtonState::Idle);

    stateful(handle)
        .deps(&amp;[count.signal_id()])
        .on_state(move |_state, container| {
            let current = count.get();
            container.merge(
                div()
                    .child(
                        text(&amp;format!("{}", current))
                            .size(64.0)
                            .weight(FontWeight::Bold)
                            .color(Color::rgba(0.4, 0.6, 1.0, 1.0))
                    )
            );
        })
}

fn counter_button(
    ctx: &amp;WindowedContext,
    count: State&lt;i32&gt;,
    label: &amp;'static str,
    delta: i32,
) -&gt; impl ElementBuilder {
    let handle = ctx.use_state_for(label, ButtonState::Idle);

    stateful(handle)
        .w(60.0)
        .h(60.0)
        .rounded(12.0)
        .flex_center()
        .on_state(|state, div| {
            let bg = match state {
                ButtonState::Idle =&gt; Color::rgba(0.2, 0.2, 0.25, 1.0),
                ButtonState::Hovered =&gt; Color::rgba(0.3, 0.3, 0.35, 1.0),
                ButtonState::Pressed =&gt; Color::rgba(0.15, 0.15, 0.2, 1.0),
                ButtonState::Disabled =&gt; Color::rgba(0.1, 0.1, 0.12, 0.5),
            };
            div.set_bg(bg);
        })
        .on_click(move |_| {
            count.update(|v| v + delta);
        })
        .child(
            text(label)
                .size(28.0)
                .weight(FontWeight::Bold)
                .color(Color::WHITE)
        )
}</code></pre>
<blockquote>
<p><strong>Tip:</strong> For more examples, explore the <code>crates/junita_app/examples/</code> directory which includes
<code>windowed.rs</code>, <code>canvas_demo.rs</code>, <code>motion_demo.rs</code>, and more.</p>
</blockquote>
<h2 id="key-concepts-learned"><a class="header" href="#key-concepts-learned">Key Concepts Learned</a></h2>
<ol>
<li><strong>WindowedApp::run</strong> - Entry point for desktop applications</li>
<li><strong>WindowedContext</strong> - Provides window dimensions and state hooks</li>
<li><strong>use_state_keyed</strong> - Creates reactive state with a string key</li>
<li><strong>stateful(handle)</strong> - Creates elements that react to state changes</li>
<li><strong>deps()</strong> - Declares signal dependencies for reactive updates</li>
<li><strong>on_state</strong> - Callback that runs when state or dependencies change</li>
<li><strong>Fluent Builder API</strong> - Chain methods like <code>.w()</code>, <code>.h()</code>, <code>.child()</code></li>
<li><strong>Flexbox Layout</strong> - Use <code>.flex_col()</code>, <code>.flex_center()</code>, <code>.gap()</code></li>
</ol>
<h2 id="next-steps-1"><a class="header" href="#next-steps-1">Next Steps</a></h2>
<ul>
<li>Learn about all available <a href="#elements--layout">Elements &amp; Layout</a></li>
<li>Add <a href="#spring-physics">Spring Animations</a> to your counter</li>
<li>Explore <a href="#styling--materials">Styling &amp; Materials</a> for visual polish</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="project-structure"><a class="header" href="#project-structure">Project Structure</a></h1>
<h2 id="recommended-layout"><a class="header" href="#recommended-layout">Recommended Layout</a></h2>
<p>For a typical Junita application:</p>
<pre><code>my-app/
├── Cargo.toml
├── src/
│   ├── main.rs           # Application entry point
│   ├── app.rs            # Main UI builder
│   ├── components/       # Reusable UI components
│   │   ├── mod.rs
│   │   ├── header.rs
│   │   ├── sidebar.rs
│   │   └── card.rs
│   ├── screens/          # Full-page views
│   │   ├── mod.rs
│   │   ├── home.rs
│   │   └── settings.rs
│   └── state/            # Application state
│       ├── mod.rs
│       └── app_state.rs
└── assets/               # Static assets
    ├── fonts/
    ├── images/
    └── icons/
</code></pre>
<h2 id="entry-point-pattern"><a class="header" href="#entry-point-pattern">Entry Point Pattern</a></h2>
<pre class="playground"><code class="language-rust">// src/main.rs
use junita_app::prelude::*;
use junita_app::windowed::{WindowedApp, WindowedContext};

mod app;
mod components;
mod screens;
mod state;

fn main() -&gt; Result&lt;()&gt; {
    tracing_subscriber::fmt()
        .with_env_filter(
            tracing_subscriber::EnvFilter::from_default_env()
                .add_directive(tracing::Level::INFO.into()),
        )
        .init();

    let config = WindowConfig {
        title: "My App".to_string(),
        width: 1200,
        height: 800,
        resizable: true,
        ..Default::default()
    };

    WindowedApp::run(config, |ctx| app::build(ctx))
}</code></pre>
<h2 id="component-organization"><a class="header" href="#component-organization">Component Organization</a></h2>
<h3 id="simple-component"><a class="header" href="#simple-component">Simple Component</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/components/card.rs
use junita_app::prelude::*;

pub fn card(title: &amp;str) -&gt; Div {
    div()
        .p(16.0)
        .rounded(12.0)
        .bg(Color::rgba(0.15, 0.15, 0.2, 1.0))
        .flex_col()
        .gap(8.0)
        .child(
            text(title)
                .size(18.0)
                .weight(FontWeight::SemiBold)
                .color(Color::WHITE)
        )
}
<span class="boring">}</span></code></pre>
<h3 id="component-with-children"><a class="header" href="#component-with-children">Component with Children</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/components/card.rs
pub fn card_with_content&lt;E: ElementBuilder&gt;(title: &amp;str, content: E) -&gt; Div {
    div()
        .p(16.0)
        .rounded(12.0)
        .bg(Color::rgba(0.15, 0.15, 0.2, 1.0))
        .flex_col()
        .gap(8.0)
        .child(
            text(title)
                .size(18.0)
                .weight(FontWeight::SemiBold)
                .color(Color::WHITE)
        )
        .child(content)
}
<span class="boring">}</span></code></pre>
<h3 id="stateful-component-with-junitacomponent"><a class="header" href="#stateful-component-with-junitacomponent">Stateful Component with JunitaComponent</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/components/animated_card.rs
use junita_app::prelude::*;
use junita_app::windowed::WindowedContext;
use junita_animation::SpringConfig;
use std::sync::Arc;

#[derive(JunitaComponent)]
pub struct AnimatedCard {
    #[animation]
    scale: f32,
    #[animation]
    opacity: f32,
}

pub fn animated_card(ctx: &amp;WindowedContext, title: &amp;str) -&gt; Div {
    let scale = AnimatedCard::use_scale(ctx, 1.0, SpringConfig::snappy());
    let opacity = AnimatedCard::use_opacity(ctx, 1.0, SpringConfig::gentle());

    let hover_scale = Arc::clone(&amp;scale);
    let leave_scale = Arc::clone(&amp;scale);

    div()
        .p(16.0)
        .rounded(12.0)
        .bg(Color::rgba(0.15, 0.15, 0.2, 1.0))
        .transform(Transform::scale(scale.lock().unwrap().get()))
        .opacity(opacity.lock().unwrap().get())
        .on_hover_enter(move |_| {
            hover_scale.lock().unwrap().set_target(1.05);
        })
        .on_hover_leave(move |_| {
            leave_scale.lock().unwrap().set_target(1.0);
        })
        .child(text(title).size(18.0).color(Color::WHITE))
}
<span class="boring">}</span></code></pre>
<h2 id="screen-organization"><a class="header" href="#screen-organization">Screen Organization</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/screens/home.rs
use junita_app::prelude::*;
use junita_app::windowed::WindowedContext;
use crate::components::{header, card};

pub fn home_screen(ctx: &amp;WindowedContext) -&gt; impl ElementBuilder {
    div()
        .w(ctx.width)
        .h(ctx.height)
        .bg(Color::rgba(0.08, 0.08, 0.12, 1.0))
        .flex_col()
        .child(header::header(ctx))
        .child(
            div()
                .flex_1()
                .p(24.0)
                .flex_col()
                .gap(16.0)
                .child(card("Welcome"))
                .child(card("Getting Started"))
        )
}
<span class="boring">}</span></code></pre>
<h2 id="state-management-patterns"><a class="header" href="#state-management-patterns">State Management Patterns</a></h2>
<h3 id="global-app-state"><a class="header" href="#global-app-state">Global App State</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/state/app_state.rs
use junita_core::reactive::Signal;
use junita_app::windowed::WindowedContext;

pub struct AppState {
    pub user_name: Signal&lt;String&gt;,
    pub theme: Signal&lt;Theme&gt;,
    pub sidebar_open: Signal&lt;bool&gt;,
}

impl AppState {
    pub fn new(ctx: &amp;WindowedContext) -&gt; Self {
        Self {
            user_name: ctx.use_signal(String::new()),
            theme: ctx.use_signal(Theme::Dark),
            sidebar_open: ctx.use_signal(true),
        }
    }
}

#[derive(Clone, Copy, PartialEq)]
pub enum Theme {
    Light,
    Dark,
}
<span class="boring">}</span></code></pre>
<h3 id="using-app-state"><a class="header" href="#using-app-state">Using App State</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/app.rs
use junita_app::prelude::*;
use junita_app::windowed::WindowedContext;
use crate::state::AppState;
use crate::screens;

pub fn build(ctx: &amp;WindowedContext) -&gt; impl ElementBuilder {
    let state = AppState::new(ctx);

    div()
        .w(ctx.width)
        .h(ctx.height)
        .flex_row()
        .child(sidebar(ctx, &amp;state))
        .child(main_content(ctx, &amp;state))
}

fn sidebar(ctx: &amp;WindowedContext, state: &amp;AppState) -&gt; Div {
    let is_open = ctx.get(state.sidebar_open).unwrap_or(true);

    if is_open {
        div().w(250.0).h_full().bg(Color::rgba(0.1, 0.1, 0.15, 1.0))
            // ... sidebar content
    } else {
        div().w(0.0).h(0.0)
    }
}
<span class="boring">}</span></code></pre>
<h2 id="module-re-exports"><a class="header" href="#module-re-exports">Module Re-exports</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/components/mod.rs
mod card;
mod header;
mod sidebar;
mod animated_card;

pub use card::*;
pub use header::*;
pub use sidebar::*;
pub use animated_card::*;
<span class="boring">}</span></code></pre>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/screens/mod.rs
mod home;
mod settings;

pub use home::*;
pub use settings::*;
<span class="boring">}</span></code></pre>
<h2 id="asset-loading"><a class="header" href="#asset-loading">Asset Loading</a></h2>
<p>For images and other assets, use relative paths from your project root:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Load an image
image("assets/images/logo.png")
    .w(100.0)
    .h(100.0)
    .contain()

// Load an SVG icon
svg("assets/icons/menu.svg")
    .w(24.0)
    .h(24.0)
    .tint(Color::WHITE)
<span class="boring">}</span></code></pre>
<h2 id="tips"><a class="header" href="#tips">Tips</a></h2>
<ol>
<li><strong>Keep components small</strong> - Each component should do one thing well</li>
<li><strong>Use JunitaComponent</strong> - For any component with animations or complex state</li>
<li><strong>Separate concerns</strong> - UI building, state management, and business logic</li>
<li><strong>Use the prelude</strong> - <code>use junita_app::prelude::*</code> imports common items</li>
<li><strong>Consistent naming</strong> - Use <code>_screen</code> suffix for full-page views, no suffix for components</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="mobile-development"><a class="header" href="#mobile-development">Mobile Development</a></h1>
<p>Blinc supports building native mobile applications for both Android and iOS platforms. The same Rust UI code runs on mobile with platform-specific rendering backends (Vulkan for Android, Metal for iOS).</p>
<h2 id="cross-platform-architecture"><a class="header" href="#cross-platform-architecture">Cross-Platform Architecture</a></h2>
<pre><code class="language-text">┌─────────────────────────────────────────────────────────────┐
│                      Your Blinc App                          │
│         (Shared Rust UI code, state, animations)             │
└─────────────────────────────┬───────────────────────────────┘
                              │
         ┌────────────────────┼────────────────────┐
         │                    │                    │
    ┌────▼────┐         ┌─────▼─────┐        ┌────▼────┐
    │ Desktop │         │  Android  │        │   iOS   │
    │ (wgpu)  │         │ (Vulkan)  │        │ (Metal) │
    └─────────┘         └───────────┘        └─────────┘
</code></pre>
<h2 id="key-features-1"><a class="header" href="#key-features-1">Key Features</a></h2>
<ul>
<li><strong>Shared UI Code</strong>: Write your UI once in Rust, deploy everywhere</li>
<li><strong>Native Performance</strong>: GPU-accelerated rendering via Vulkan/Metal</li>
<li><strong>Touch Support</strong>: Full multi-touch gesture handling</li>
<li><strong>Reactive State</strong>: Same reactive state system as desktop</li>
<li><strong>Animations</strong>: Spring physics and keyframe animations work seamlessly</li>
</ul>
<h2 id="supported-platforms"><a class="header" href="#supported-platforms">Supported Platforms</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Platform</th><th>Backend</th><th>Min Version</th><th>Status</th></tr>
</thead>
<tbody>
<tr><td>Android</td><td>Vulkan</td><td>API 24 (7.0)</td><td>Stable</td></tr>
<tr><td>iOS</td><td>Metal</td><td>iOS 15+</td><td>Stable</td></tr>
</tbody>
</table>
</div>
<h2 id="project-structure-1"><a class="header" href="#project-structure-1">Project Structure</a></h2>
<p>A typical Blinc mobile project looks like this:</p>
<pre><code class="language-text">my-app/
├── Cargo.toml           # Rust dependencies
├── blinc.toml           # Blinc project config
├── src/
│   └── main.rs          # Shared UI code
├── platforms/
│   ├── android/         # Android-specific files
│   │   ├── app/
│   │   │   └── src/main/
│   │   │       ├── AndroidManifest.xml
│   │   │       └── kotlin/.../MainActivity.kt
│   │   └── build.gradle.kts
│   └── ios/             # iOS-specific files
│       ├── BlincApp/
│       │   ├── AppDelegate.swift
│       │   ├── BlincViewController.swift
│       │   └── Info.plist
│       └── BlincApp.xcodeproj/
└── build-android.sh     # Build scripts
</code></pre>
<h2 id="quick-start"><a class="header" href="#quick-start">Quick Start</a></h2>
<h3 id="1-create-a-new-mobile-project"><a class="header" href="#1-create-a-new-mobile-project">1. Create a new mobile project</a></h3>
<pre><code class="language-bash">blinc new my-app --template rust
cd my-app
</code></pre>
<h3 id="2-write-your-ui"><a class="header" href="#2-write-your-ui">2. Write your UI</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use blinc_app::prelude::*;

fn app(ctx: &amp;mut WindowedContext) -&gt; impl ElementBuilder {
    let count = ctx.use_state_keyed("count", || 0i32);

    div()
        .w(ctx.width)
        .h(ctx.height)
        .bg(Color::from_hex(0x1a1a2e))
        .flex_col()
        .items_center()
        .justify_center()
        .gap(20.0)
        .child(counter_display(count.clone()))
        .child(counter_button("+", count.clone(), 1))
}

fn counter_display(count: State&lt;i32&gt;) -&gt; impl ElementBuilder {
    // Stateful elements with deps update incrementally when dependencies change
    stateful::&lt;NoState&gt;()
        .deps([count.signal_id()])
        .on_state(move |_ctx| {
            text(format!("Count: {}", count.get()))
                .size(48.0)
                .color(Color::WHITE)
        })
}

fn counter_button(label: &amp;str, count: State&lt;i32&gt;, delta: i32) -&gt; impl ElementBuilder {
    let label = label.to_string();
    stateful::&lt;ButtonState&gt;()
        .on_state(move |ctx| {
            let bg = match ctx.state() {
                ButtonState::Idle =&gt; Color::from_hex(0x4a4a5a),
                ButtonState::Hovered =&gt; Color::from_hex(0x5a5a6a),
                ButtonState::Pressed =&gt; Color::from_hex(0x3a3a4a),
                ButtonState::Disabled =&gt; Color::from_hex(0x2a2a2a),
            };
            div()
                .w(80.0).h(50.0)
                .rounded(8.0)
                .bg(bg)
                .items_center()
                .justify_center()
                .child(text(&amp;label).size(24.0).color(Color::WHITE))
        })
        .on_click(move |_| count.set(count.get() + delta))
}
<span class="boring">}</span></code></pre>
<h3 id="3-build-and-run"><a class="header" href="#3-build-and-run">3. Build and run</a></h3>
<pre><code class="language-bash"># Android
blinc run android

# iOS
blinc run ios
</code></pre>
<h2 id="next-steps-2"><a class="header" href="#next-steps-2">Next Steps</a></h2>
<ul>
<li><a href="#android-development">Android Development</a> - Set up Android toolchain and build</li>
<li><a href="#ios-development">iOS Development</a> - Set up iOS toolchain and build</li>
<li><a href="#cli-reference">CLI Reference</a> - Full CLI command reference</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="android-development"><a class="header" href="#android-development">Android Development</a></h1>
<p>This guide covers setting up your environment and building Junita apps for Android.</p>
<h2 id="prerequisites-1"><a class="header" href="#prerequisites-1">Prerequisites</a></h2>
<h3 id="1-android-sdk--ndk"><a class="header" href="#1-android-sdk--ndk">1. Android SDK &amp; NDK</a></h3>
<p>Install Android Studio or the standalone SDK:</p>
<pre><code class="language-bash"># macOS (via Homebrew)
brew install --cask android-studio

# Or download from https://developer.android.com/studio
</code></pre>
<p>Set up environment variables:</p>
<pre><code class="language-bash">export ANDROID_HOME=$HOME/Library/Android/sdk
export ANDROID_NDK_HOME=$ANDROID_HOME/ndk/26.1.10909125
export PATH=$PATH:$ANDROID_HOME/platform-tools
</code></pre>
<h3 id="2-rust-android-targets"><a class="header" href="#2-rust-android-targets">2. Rust Android Targets</a></h3>
<pre><code class="language-bash">rustup target add aarch64-linux-android
rustup target add armv7-linux-androideabi
rustup target add x86_64-linux-android
rustup target add i686-linux-android
</code></pre>
<h3 id="3-cargo-ndk"><a class="header" href="#3-cargo-ndk">3. cargo-ndk</a></h3>
<pre><code class="language-bash">cargo install cargo-ndk
</code></pre>
<h2 id="building"><a class="header" href="#building">Building</a></h2>
<h3 id="debug-build"><a class="header" href="#debug-build">Debug Build</a></h3>
<pre><code class="language-bash"># Build for arm64 (most modern devices)
cargo ndk -t arm64-v8a build

# Build for multiple architectures
cargo ndk -t arm64-v8a -t armeabi-v7a build
</code></pre>
<h3 id="release-build"><a class="header" href="#release-build">Release Build</a></h3>
<pre><code class="language-bash">cargo ndk -t arm64-v8a build --release
</code></pre>
<h3 id="using-gradle"><a class="header" href="#using-gradle">Using Gradle</a></h3>
<p>From the <code>platforms/android</code> directory:</p>
<pre><code class="language-bash">./gradlew assembleDebug
</code></pre>
<p>The APK will be at <code>app/build/outputs/apk/debug/app-debug.apk</code>.</p>
<h2 id="project-configuration"><a class="header" href="#project-configuration">Project Configuration</a></h2>
<h3 id="cargotoml"><a class="header" href="#cargotoml">Cargo.toml</a></h3>
<pre><code class="language-toml">[lib]
name = "my_app"
crate-type = ["cdylib", "staticlib"]

[target.'cfg(target_os = "android")'.dependencies]
junita_app = { version = "0.1", features = ["android"] }
junita_platform_android = "0.1"
android-activity = { version = "0.6", features = ["native-activity"] }
log = "0.4"
android_logger = "0.14"
</code></pre>
<h3 id="androidmanifestxml"><a class="header" href="#androidmanifestxml">AndroidManifest.xml</a></h3>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android"&gt;
    &lt;uses-feature android:glEsVersion="0x00030000" android:required="true" /&gt;

    &lt;application
        android:label="My App"
        android:theme="@android:style/Theme.DeviceDefault.NoActionBar.Fullscreen"
        android:hardwareAccelerated="true"&gt;

        &lt;activity
            android:name=".MainActivity"
            android:configChanges="orientation|screenSize|keyboardHidden"
            android:exported="true"&gt;

            &lt;meta-data
                android:name="android.app.lib_name"
                android:value="my_app" /&gt;

            &lt;intent-filter&gt;
                &lt;action android:name="android.intent.action.MAIN" /&gt;
                &lt;category android:name="android.intent.category.LAUNCHER" /&gt;
            &lt;/intent-filter&gt;
        &lt;/activity&gt;
    &lt;/application&gt;
&lt;/manifest&gt;
</code></pre>
<h2 id="touch-event-handling"><a class="header" href="#touch-event-handling">Touch Event Handling</a></h2>
<p>Android touch events are automatically routed to your UI. The touch phases map as follows:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Android Action</th><th>Junita Event</th></tr>
</thead>
<tbody>
<tr><td>ACTION_DOWN</td><td>pointer_down</td></tr>
<tr><td>ACTION_MOVE</td><td>pointer_move</td></tr>
<tr><td>ACTION_UP</td><td>pointer_up + pointer_leave</td></tr>
<tr><td>ACTION_CANCEL</td><td>pointer_leave</td></tr>
</tbody>
</table>
</div>
<p>Two-finger pinch gestures emit the layout <code>PINCH</code> event with the gesture center
and per-frame scale delta. One-finger drag scrolling is unchanged.</p>
<h2 id="debugging"><a class="header" href="#debugging">Debugging</a></h2>
<h3 id="view-logs"><a class="header" href="#view-logs">View Logs</a></h3>
<pre><code class="language-bash">adb logcat | grep -E "(junita|JunitaApp)"
</code></pre>
<h3 id="common-issues"><a class="header" href="#common-issues">Common Issues</a></h3>
<p><strong>“Library not found”</strong></p>
<p>Ensure the native library is built and copied to <code>app/src/main/jniLibs/</code>:</p>
<pre><code class="language-bash">cargo ndk -t arm64-v8a build
cp target/aarch64-linux-android/debug/libmy_app.so \
   platforms/android/app/src/main/jniLibs/arm64-v8a/
</code></pre>
<p><strong>“Vulkan not supported”</strong></p>
<p>Check device compatibility:</p>
<pre><code class="language-bash">adb shell getprop ro.hardware.vulkan
</code></pre>
<p>Most devices with API 24+ support Vulkan, but some older devices may not.</p>
<p><strong>Touch events not working</strong></p>
<ol>
<li>Verify the render context is created successfully</li>
<li>Check that <code>android.app.lib_name</code> in manifest matches your library name</li>
<li>Look for errors in logcat</li>
</ol>
<h2 id="performance-tips"><a class="header" href="#performance-tips">Performance Tips</a></h2>
<ol>
<li><strong>Use release builds</strong> for performance testing</li>
<li><strong>Enable LTO</strong> in Cargo.toml:
<pre><code class="language-toml">[profile.release]
lto = "thin"
opt-level = "z"
</code></pre>
</li>
<li><strong>Test on real devices</strong> - emulators have different GPU characteristics</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="ios-development"><a class="header" href="#ios-development">iOS Development</a></h1>
<p>This guide covers setting up your environment and building Junita apps for iOS.</p>
<h2 id="prerequisites-2"><a class="header" href="#prerequisites-2">Prerequisites</a></h2>
<h3 id="1-xcode"><a class="header" href="#1-xcode">1. Xcode</a></h3>
<p>Install Xcode 15+ from the Mac App Store or Apple Developer website.</p>
<pre><code class="language-bash"># Verify installation
xcode-select -p
</code></pre>
<h3 id="2-rust-ios-targets"><a class="header" href="#2-rust-ios-targets">2. Rust iOS Targets</a></h3>
<pre><code class="language-bash">rustup target add aarch64-apple-ios        # Device (arm64)
rustup target add aarch64-apple-ios-sim    # Simulator (Apple Silicon)
rustup target add x86_64-apple-ios         # Simulator (Intel)
</code></pre>
<h2 id="building-1"><a class="header" href="#building-1">Building</a></h2>
<h3 id="build-script"><a class="header" href="#build-script">Build Script</a></h3>
<p>Create a build script <code>build-ios.sh</code>:</p>
<pre><code class="language-bash">#!/bin/bash
set -e

MODE=${1:-debug}
PROJECT_NAME="my_app"

if [ "$MODE" = "release" ]; then
    CARGO_FLAGS="--release"
    TARGET_DIR="release"
else
    CARGO_FLAGS=""
    TARGET_DIR="debug"
fi

# Build for device
cargo build --target aarch64-apple-ios $CARGO_FLAGS

# Build for simulator (Apple Silicon)
cargo build --target aarch64-apple-ios-sim $CARGO_FLAGS

# Copy to libs directory
mkdir -p platforms/ios/libs/device
mkdir -p platforms/ios/libs/simulator

cp target/aarch64-apple-ios/$TARGET_DIR/lib${PROJECT_NAME}.a \
   platforms/ios/libs/device/

cp target/aarch64-apple-ios-sim/$TARGET_DIR/lib${PROJECT_NAME}.a \
   platforms/ios/libs/simulator/
</code></pre>
<h3 id="building-1-1"><a class="header" href="#building-1-1">Building</a></h3>
<pre><code class="language-bash"># Debug build
./build-ios.sh

# Release build
./build-ios.sh release
</code></pre>
<h3 id="xcode"><a class="header" href="#xcode">Xcode</a></h3>
<ol>
<li>Open <code>platforms/ios/JunitaApp.xcodeproj</code></li>
<li>Select your target (device or simulator)</li>
<li>Press Cmd+R to build and run</li>
</ol>
<h2 id="project-configuration-1"><a class="header" href="#project-configuration-1">Project Configuration</a></h2>
<h3 id="cargotoml-1"><a class="header" href="#cargotoml-1">Cargo.toml</a></h3>
<pre><code class="language-toml">[lib]
name = "my_app"
crate-type = ["cdylib", "staticlib"]

[target.'cfg(target_os = "ios")'.dependencies]
junita_app = { version = "0.1", features = ["ios"] }
junita_platform_ios = "0.1"
</code></pre>
<h3 id="xcode-build-settings"><a class="header" href="#xcode-build-settings">Xcode Build Settings</a></h3>
<p>In your Xcode project:</p>
<ol>
<li>
<p><strong>Link the static library</strong>:</p>
<ul>
<li>Build Phases → Link Binary With Libraries</li>
<li>Add <code>libmy_app.a</code> from <code>libs/device/</code> or <code>libs/simulator/</code></li>
</ul>
</li>
<li>
<p><strong>Set the bridging header</strong>:</p>
<ul>
<li>Build Settings → Swift Compiler - General</li>
<li>Objective-C Bridging Header: <code>JunitaApp/Junita-Bridging-Header.h</code></li>
</ul>
</li>
<li>
<p><strong>Add required frameworks</strong>:</p>
<ul>
<li>Metal.framework</li>
<li>MetalKit.framework</li>
<li>QuartzCore.framework</li>
</ul>
</li>
</ol>
<h2 id="swift-integration"><a class="header" href="#swift-integration">Swift Integration</a></h2>
<h3 id="bridging-header"><a class="header" href="#bridging-header">Bridging Header</a></h3>
<p>The bridging header (<code>Junita-Bridging-Header.h</code>) declares the C FFI functions:</p>
<pre><code class="language-c">// Context lifecycle
IOSRenderContext* junita_create_context(uint32_t width, uint32_t height, double scale);
void junita_destroy_context(IOSRenderContext* ctx);

// Rendering
bool junita_needs_render(IOSRenderContext* ctx);
void junita_build_frame(IOSRenderContext* ctx);
bool junita_render_frame(IOSGpuRenderer* gpu);

// Input
void junita_handle_touch(IOSRenderContext* ctx, uint64_t id, float x, float y, int32_t phase);
</code></pre>
<h3 id="view-controller"><a class="header" href="#view-controller">View Controller</a></h3>
<p>The <code>JunitaViewController</code> manages:</p>
<ul>
<li>CADisplayLink for 60fps frame timing</li>
<li>Metal layer for GPU rendering</li>
<li>Touch event forwarding to Rust</li>
</ul>
<h2 id="touch-event-handling-1"><a class="header" href="#touch-event-handling-1">Touch Event Handling</a></h2>
<p>iOS touch events are routed through the view controller:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>iOS Phase</th><th>Junita Event</th></tr>
</thead>
<tbody>
<tr><td>touchesBegan</td><td>pointer_down</td></tr>
<tr><td>touchesMoved</td><td>pointer_move</td></tr>
<tr><td>touchesEnded</td><td>pointer_up + pointer_leave</td></tr>
<tr><td>touchesCancelled</td><td>pointer_leave</td></tr>
</tbody>
</table>
</div>
<p>The <code>pointer_leave</code> after <code>pointer_up</code> is important for proper button state transitions on touch devices.</p>
<p>Two-finger pinch gestures emit a <code>PINCH</code> event using the pinch center and a per-move scale ratio
clamped to 0.90..1.10.</p>
<h2 id="debugging-1"><a class="header" href="#debugging-1">Debugging</a></h2>
<h3 id="console-logs"><a class="header" href="#console-logs">Console Logs</a></h3>
<p>View Rust logs in Xcode’s console or use Console.app with a filter:</p>
<pre><code>subsystem:com.junita.my_app
</code></pre>
<h3 id="common-issues-1"><a class="header" href="#common-issues-1">Common Issues</a></h3>
<p><strong>“Library not found: -lmy_app”</strong></p>
<p>Run the build script first:</p>
<pre><code class="language-bash">./build-ios.sh
</code></pre>
<p><strong>Black screen on simulator</strong></p>
<ol>
<li>Ensure you built for the correct simulator target (<code>aarch64-apple-ios-sim</code>)</li>
<li>Verify the library is in <code>libs/simulator/</code></li>
<li>Check Xcode console for Metal initialization errors</li>
</ol>
<p><strong>Touch events not working</strong></p>
<ol>
<li>Verify <code>junita_create_context</code> succeeds (check console logs)</li>
<li>Ensure <code>ios_app_init()</code> is called before creating the context</li>
<li>Check that touch coordinates are in logical points, not pixels</li>
</ol>
<h2 id="performance-tips-1"><a class="header" href="#performance-tips-1">Performance Tips</a></h2>
<ol>
<li>
<p><strong>Use release builds</strong> for performance testing:</p>
<pre><code class="language-bash">./build-ios.sh release
</code></pre>
</li>
<li>
<p><strong>Enable LTO</strong> in Cargo.toml:</p>
<pre><code class="language-toml">[profile.release]
lto = "thin"
opt-level = "z"
strip = true
</code></pre>
</li>
<li>
<p><strong>Test on real devices</strong> - simulators use software rendering for some operations</p>
</li>
<li>
<p><strong>Profile with Instruments</strong> - use Xcode’s Metal debugger for GPU analysis</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="cli-reference"><a class="header" href="#cli-reference">CLI Reference</a></h1>
<p>The Junita CLI simplifies creating and building mobile projects.</p>
<h2 id="creating-a-project"><a class="header" href="#creating-a-project">Creating a Project</a></h2>
<h3 id="new-project"><a class="header" href="#new-project">New Project</a></h3>
<pre><code class="language-bash">junita new my-app --template rust
</code></pre>
<p>This creates a new Junita project with:</p>
<ul>
<li>Cargo.toml configured for mobile targets</li>
<li>Platform directories for Android and iOS</li>
<li>Build scripts for each platform</li>
<li>Example UI code</li>
</ul>
<h3 id="options"><a class="header" href="#options">Options</a></h3>
<pre><code class="language-bash">junita new &lt;name&gt; [options]

Options:
  --template &lt;type&gt;   Project template (rust, swift, kotlin)
  --platforms &lt;list&gt;  Target platforms (desktop,android,ios)
  --no-git            Skip git initialization
</code></pre>
<h2 id="building-2"><a class="header" href="#building-2">Building</a></h2>
<h3 id="build-for-android"><a class="header" href="#build-for-android">Build for Android</a></h3>
<pre><code class="language-bash">junita build android
</code></pre>
<p>Options:</p>
<pre><code class="language-bash">junita build android [options]

Options:
  --release           Build in release mode
  --target &lt;arch&gt;     Target architecture (arm64-v8a, armeabi-v7a, x86_64, x86)
  --all-targets       Build for all architectures
</code></pre>
<h3 id="build-for-ios"><a class="header" href="#build-for-ios">Build for iOS</a></h3>
<pre><code class="language-bash">junita build ios
</code></pre>
<p>Options:</p>
<pre><code class="language-bash">junita build ios [options]

Options:
  --release           Build in release mode
  --device            Build for physical device only
  --simulator         Build for simulator only
</code></pre>
<h2 id="running"><a class="header" href="#running">Running</a></h2>
<h3 id="run-on-android"><a class="header" href="#run-on-android">Run on Android</a></h3>
<pre><code class="language-bash">junita run android
</code></pre>
<p>This will:</p>
<ol>
<li>Build the native library</li>
<li>Build the APK with Gradle</li>
<li>Install on connected device/emulator</li>
<li>Launch the app</li>
</ol>
<p>Options:</p>
<pre><code class="language-bash">junita run android [options]

Options:
  --release           Run release build
  --device &lt;id&gt;       Target specific device (from adb devices)
  --no-install        Build only, don't install
</code></pre>
<h3 id="run-on-ios"><a class="header" href="#run-on-ios">Run on iOS</a></h3>
<pre><code class="language-bash">junita run ios
</code></pre>
<p>This will:</p>
<ol>
<li>Build the static library</li>
<li>Open Xcode project</li>
<li>Build and run on selected target</li>
</ol>
<p>Options:</p>
<pre><code class="language-bash">junita run ios [options]

Options:
  --release           Run release build
  --simulator &lt;name&gt;  Target specific simulator
  --device            Run on physical device
</code></pre>
<h2 id="project-configuration-2"><a class="header" href="#project-configuration-2">Project Configuration</a></h2>
<h3 id="junitatoml"><a class="header" href="#junitatoml">junita.toml</a></h3>
<p>The project configuration file:</p>
<pre><code class="language-toml">[project]
name = "my-app"
version = "0.1.0"
template = "rust"
entry = "Cargo.toml"

[targets]
default = "desktop"
supported = ["desktop", "android", "ios"]

[targets.desktop]
enabled = true
command = "cargo run --features desktop"

[targets.android]
enabled = true
platform_dir = "platforms/android"

[targets.ios]
enabled = true
platform_dir = "platforms/ios"

[build]
junita_path = "../.."  # Path to Junita framework
</code></pre>
<h3 id="configuration-options"><a class="header" href="#configuration-options">Configuration Options</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Key</th><th>Description</th><th>Default</th></tr>
</thead>
<tbody>
<tr><td><code>project.name</code></td><td>Project name</td><td>Required</td></tr>
<tr><td><code>project.version</code></td><td>Version string</td><td>“0.1.0”</td></tr>
<tr><td><code>project.template</code></td><td>Template type</td><td>“rust”</td></tr>
<tr><td><code>targets.default</code></td><td>Default build target</td><td>“desktop”</td></tr>
<tr><td><code>targets.supported</code></td><td>List of supported platforms</td><td>[“desktop”]</td></tr>
<tr><td><code>build.junita_path</code></td><td>Path to Junita framework</td><td>“../..”</td></tr>
</tbody>
</table>
</div>
<h2 id="cleaning"><a class="header" href="#cleaning">Cleaning</a></h2>
<pre><code class="language-bash"># Clean all build artifacts
junita clean

# Clean specific platform
junita clean android
junita clean ios
</code></pre>
<h2 id="checking-configuration"><a class="header" href="#checking-configuration">Checking Configuration</a></h2>
<pre><code class="language-bash"># Validate project configuration
junita check

# Check specific platform setup
junita check android
junita check ios
</code></pre>
<p>This verifies:</p>
<ul>
<li>Required tools are installed</li>
<li>Environment variables are set</li>
<li>Project configuration is valid</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="elements--layout"><a class="header" href="#elements--layout">Elements &amp; Layout</a></h1>
<p>Junita provides a set of core elements that can be composed to build any UI. All elements implement the <code>ElementBuilder</code> trait and use a fluent builder pattern.</p>
<h2 id="core-elements"><a class="header" href="#core-elements">Core Elements</a></h2>
<h3 id="div---the-universal-container"><a class="header" href="#div---the-universal-container">Div - The Universal Container</a></h3>
<p><code>div()</code> is the primary building block. It’s a flexible container that supports:</p>
<ul>
<li>Flexbox layout</li>
<li>Background colors and materials</li>
<li>Borders and shadows</li>
<li>Event handling</li>
<li>Child elements</li>
</ul>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>div()
    .w(200.0)
    .h(100.0)
    .bg(Color::rgba(0.2, 0.2, 0.3, 1.0))
    .rounded(8.0)
    .flex_center()
    .child(text("Hello"))
<span class="boring">}</span></code></pre>
<h3 id="text---typography"><a class="header" href="#text---typography">Text - Typography</a></h3>
<p><code>text(content)</code> renders text with customizable typography:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>text("Hello, World!")
    .size(24.0)
    .weight(FontWeight::Bold)
    .color(Color::WHITE)
    .family("Inter")
<span class="boring">}</span></code></pre>
<p><strong>Text Properties:</strong></p>
<ul>
<li><code>.size(px)</code> - Font size in pixels</li>
<li><code>.weight(FontWeight)</code> - Bold, SemiBold, Medium, Regular, Light</li>
<li><code>.color(Color)</code> - Text color</li>
<li><code>.family(name)</code> - Font family</li>
<li><code>.italic()</code> - Italic style</li>
<li><code>.underline()</code> - Underline decoration</li>
<li><code>.line_height(multiplier)</code> - Line height as multiplier of font size</li>
<li><code>.letter_spacing(px)</code> - Space between characters</li>
<li><code>.align(TextAlign)</code> - Left, Center, Right, Justify</li>
</ul>
<p><strong>Typography Helpers:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>h1("Heading 1")      // 32px bold
h2("Heading 2")      // 28px bold
h3("Heading 3")      // 24px bold
h4("Heading 4")      // 20px semibold
h5("Heading 5")      // 16px semibold
h6("Heading 6")      // 14px semibold
p("Paragraph")       // 14px regular
caption("Caption")   // 12px regular
label("Label")       // 14px medium
muted("Muted text")  // Reduced opacity
b("Bold text")       // Bold weight
small("Small")       // 12px
<span class="boring">}</span></code></pre>
<h3 id="stack---overlapping-layers"><a class="header" href="#stack---overlapping-layers">Stack - Overlapping Layers</a></h3>
<p><code>stack()</code> positions children on top of each other, useful for overlays and layered designs:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>stack()
    .w(200.0)
    .h(200.0)
    // Background layer
    .child(
        div().w_full().h_full().bg(Color::BLUE)
    )
    // Foreground layer
    .child(
        div()
            .absolute()
            .right(10.0)
            .bottom(10.0)
            .w(50.0)
            .h(50.0)
            .bg(Color::RED)
    )
<span class="boring">}</span></code></pre>
<h3 id="canvas---custom-drawing"><a class="header" href="#canvas---custom-drawing">Canvas - Custom Drawing</a></h3>
<p><code>canvas(render_fn)</code> provides direct GPU drawing access:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>canvas(|ctx: &amp;mut dyn DrawContext, bounds| {
    ctx.fill_rect(
        Rect::new(0.0, 0.0, bounds.width, bounds.height),
        CornerRadius::uniform(8.0),
        Brush::Solid(Color::RED),
    );
})
.w(200.0)
.h(100.0)
<span class="boring">}</span></code></pre>
<p>See <a href="#canvas-drawing">Canvas Drawing</a> for more details.</p>
<h3 id="image--svg"><a class="header" href="#image--svg">Image &amp; SVG</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Raster images
image("path/to/image.png")
    .w(200.0)
    .h(150.0)
    .cover()  // Object-fit: cover

// SVG with tint
svg("path/to/icon.svg")
    .w(24.0)
    .h(24.0)
    .tint(Color::WHITE)
<span class="boring">}</span></code></pre>
<p>See <a href="#images--svg">Images &amp; SVG</a> for more details.</p>
<hr>
<h2 id="layout-system"><a class="header" href="#layout-system">Layout System</a></h2>
<p>Junita uses Flexbox for layout, powered by <a href="https://github.com/DioxusLabs/taffy">Taffy</a>.</p>
<h3 id="sizing"><a class="header" href="#sizing">Sizing</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>div()
    .w(200.0)           // Fixed width in pixels
    .h(100.0)           // Fixed height in pixels
    .w_full()           // 100% width
    .h_full()           // 100% height
    .w_auto()           // Auto width (content-based)
    .h_auto()           // Auto height (content-based)
    .w_fit()            // Shrink-wrap to content
    .size(200.0, 100.0) // Set both dimensions
    .square(100.0)      // Square element
    .min_w(50.0)        // Minimum width
    .max_w(500.0)       // Maximum width
    .min_h(50.0)        // Minimum height
    .max_h(300.0)       // Maximum height
    .aspect_ratio(16.0 / 9.0)  // Maintain aspect ratio
<span class="boring">}</span></code></pre>
<h3 id="flex-container"><a class="header" href="#flex-container">Flex Container</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>div()
    .flex()             // Enable flexbox
    .flex_row()         // Horizontal layout (default)
    .flex_col()         // Vertical layout
    .flex_row_reverse() // Right to left
    .flex_col_reverse() // Bottom to top
    .flex_wrap()        // Wrap children
<span class="boring">}</span></code></pre>
<h3 id="flex-items"><a class="header" href="#flex-items">Flex Items</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>div()
    .flex_grow()        // Grow to fill space (flex-grow: 1)
    .flex_shrink()      // Allow shrinking (flex-shrink: 1)
    .flex_shrink_0()    // Don't shrink (flex-shrink: 0)
    .flex_1()           // flex: 1 1 0% (grow and shrink)
    .flex_auto()        // flex: 1 1 auto
<span class="boring">}</span></code></pre>
<h3 id="alignment"><a class="header" href="#alignment">Alignment</a></h3>
<p><strong>Align Items</strong> (cross-axis alignment):</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>div()
    .items_start()      // Align to start
    .items_center()     // Center alignment
    .items_end()        // Align to end
    .items_stretch()    // Stretch to fill
    .items_baseline()   // Align baselines
<span class="boring">}</span></code></pre>
<p><strong>Justify Content</strong> (main-axis distribution):</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>div()
    .justify_start()    // Pack at start
    .justify_center()   // Center items
    .justify_end()      // Pack at end
    .justify_between()  // Space between items
    .justify_around()   // Space around items
    .justify_evenly()   // Equal spacing
<span class="boring">}</span></code></pre>
<p><strong>Convenience Methods:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>div().flex_center()     // Center both axes
div().flex_col().justify_center().items_center()  // Same as above
<span class="boring">}</span></code></pre>
<h3 id="gap-spacing-between-children"><a class="header" href="#gap-spacing-between-children">Gap (Spacing Between Children)</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>div()
    .gap(16.0)          // Gap in pixels
    .gap_x(8.0)         // Horizontal gap only
    .gap_y(12.0)        // Vertical gap only
<span class="boring">}</span></code></pre>
<h3 id="padding"><a class="header" href="#padding">Padding</a></h3>
<p>Padding uses a 4px unit system (like Tailwind CSS):</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>div()
    .p(4.0)             // 16px padding all sides (4 * 4px)
    .px(2.0)            // 8px horizontal padding
    .py(3.0)            // 12px vertical padding
    .pt(1.0)            // 4px top padding
    .pr(2.0)            // 8px right padding
    .pb(3.0)            // 12px bottom padding
    .pl(4.0)            // 16px left padding
    .p_px(20.0)         // 20px (exact pixels, not units)
<span class="boring">}</span></code></pre>
<h3 id="margin"><a class="header" href="#margin">Margin</a></h3>
<p>Same unit system as padding:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>div()
    .m(4.0)             // 16px margin all sides
    .mx(2.0)            // 8px horizontal margin
    .my(3.0)            // 12px vertical margin
    .mt(1.0)            // 4px top margin
    .mr(2.0)            // 8px right margin
    .mb(3.0)            // 12px bottom margin
    .ml(4.0)            // 16px left margin
    .mx_auto()          // Auto horizontal margins (centering)
<span class="boring">}</span></code></pre>
<h3 id="positioning"><a class="header" href="#positioning">Positioning</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>div()
    .relative()         // Position relative
    .absolute()         // Position absolute
    .inset(10.0)        // 10px from all edges
    .top(20.0)          // 20px from top
    .right(20.0)        // 20px from right
    .bottom(20.0)       // 20px from bottom
    .left(20.0)         // 20px from left
<span class="boring">}</span></code></pre>
<h3 id="overflow"><a class="header" href="#overflow">Overflow</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>div()
    .overflow_clip()    // Clip overflowing content
    .overflow_visible() // Allow overflow
    .overflow_scroll()  // Enable scrolling
<span class="boring">}</span></code></pre>
<hr>
<h2 id="common-layout-patterns"><a class="header" href="#common-layout-patterns">Common Layout Patterns</a></h2>
<h3 id="centered-content"><a class="header" href="#centered-content">Centered Content</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>div()
    .w_full()
    .h_full()
    .flex_center()
    .child(content)
<span class="boring">}</span></code></pre>
<h3 id="sidebar-layout"><a class="header" href="#sidebar-layout">Sidebar Layout</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>div()
    .w_full()
    .h_full()
    .flex_row()
    .child(
        div().w(250.0).h_full()  // Sidebar
    )
    .child(
        div().flex_1().h_full()  // Main content
    )
<span class="boring">}</span></code></pre>
<h3 id="card-grid"><a class="header" href="#card-grid">Card Grid</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>div()
    .w_full()
    .flex_row()
    .flex_wrap()
    .gap(16.0)
    .child(card().w(300.0))
    .child(card().w(300.0))
    .child(card().w(300.0))
<span class="boring">}</span></code></pre>
<h3 id="headercontentfooter"><a class="header" href="#headercontentfooter">Header/Content/Footer</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>div()
    .w_full()
    .h_full()
    .flex_col()
    .child(
        div().h(60.0).w_full()  // Header
    )
    .child(
        div().flex_1().w_full() // Content (fills remaining)
    )
    .child(
        div().h(40.0).w_full()  // Footer
    )
<span class="boring">}</span></code></pre>
<h3 id="horizontal-navigation"><a class="header" href="#horizontal-navigation">Horizontal Navigation</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>div()
    .w_full()
    .h(60.0)
    .flex_row()
    .items_center()
    .justify_between()
    .px(4.0)
    .child(logo())
    .child(
        div()
            .flex_row()
            .gap(24.0)
            .child(nav_item("Home"))
            .child(nav_item("About"))
            .child(nav_item("Contact"))
    )
<span class="boring">}</span></code></pre>
<hr>
<h2 id="the-child-pattern"><a class="header" href="#the-child-pattern">The <code>.child()</code> Pattern</a></h2>
<p>Add children with <code>.child()</code>. For multiple children of the same type, use iterators:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Single child
div().child(text("Hello"))

// Multiple children
div()
    .child(text("First"))
    .child(text("Second"))
    .child(text("Third"))

// From iterator
let items = vec!["Apple", "Banana", "Cherry"];
div().child(
    items.into_iter().map(|item| text(item))
)
<span class="boring">}</span></code></pre>
<hr>
<h2 id="elementbuilder-trait"><a class="header" href="#elementbuilder-trait">ElementBuilder Trait</a></h2>
<p>All elements implement <code>ElementBuilder</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait ElementBuilder {
    fn build(self, tree: &amp;mut LayoutTree) -&gt; LayoutNodeId;
}
<span class="boring">}</span></code></pre>
<p>This allows composing any element type:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn my_component() -&gt; impl ElementBuilder {
    div().child(text("Hello"))
}

// Use it
div().child(my_component())
<span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="styling--materials"><a class="header" href="#styling--materials">Styling &amp; Materials</a></h1>
<p>Junita provides comprehensive styling options from simple colors to advanced GPU-accelerated material effects.</p>
<h2 id="colors"><a class="header" href="#colors">Colors</a></h2>
<h3 id="basic-colors"><a class="header" href="#basic-colors">Basic Colors</a></h3>
<p>Colors are RGBA with values from 0.0 to 1.0:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// RGBA constructor
Color::rgba(0.2, 0.4, 0.8, 1.0)  // Blue, fully opaque
Color::rgba(1.0, 0.0, 0.0, 0.5)  // Red, 50% transparent

// From array (common pattern)
Color::from([0.2, 0.4, 0.8, 1.0])

// Predefined colors
Color::WHITE
Color::BLACK
Color::RED
Color::GREEN
Color::BLUE
Color::TRANSPARENT
<span class="boring">}</span></code></pre>
<h3 id="background-colors"><a class="header" href="#background-colors">Background Colors</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>div()
    .bg(Color::rgba(0.1, 0.1, 0.15, 1.0))

// From array shorthand
div().bg([0.1, 0.1, 0.15, 1.0])
<span class="boring">}</span></code></pre>
<h3 id="gradients"><a class="header" href="#gradients">Gradients</a></h3>
<p>For gradients, use the <code>.background()</code> method with a <code>Brush</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use junita_core::{Brush, Gradient, GradientStop, Point};

div()
    .w(200.0)
    .h(100.0)
    .background(Brush::Gradient(Gradient::linear_with_stops(
        Point::new(0.0, 0.0),       // Start point
        Point::new(200.0, 0.0),     // End point
        vec![
            GradientStop::new(0.0, Color::rgba(0.9, 0.2, 0.5, 1.0)),
            GradientStop::new(0.5, Color::rgba(0.9, 0.5, 0.2, 1.0)),
            GradientStop::new(1.0, Color::rgba(0.2, 0.8, 0.6, 1.0)),
        ],
    )))
<span class="boring">}</span></code></pre>
<hr>
<h2 id="borders--corners"><a class="header" href="#borders--corners">Borders &amp; Corners</a></h2>
<h3 id="corner-radius"><a class="header" href="#corner-radius">Corner Radius</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>div()
    .rounded(8.0)           // Uniform radius
    .rounded_full()         // Pill shape (50% of smallest dimension)
    .rounded_corners(
        16.0,  // Top-left
        16.0,  // Top-right
        8.0,   // Bottom-right
        8.0,   // Bottom-left
    )
<span class="boring">}</span></code></pre>
<hr>
<h2 id="shadows"><a class="header" href="#shadows">Shadows</a></h2>
<h3 id="preset-shadows"><a class="header" href="#preset-shadows">Preset Shadows</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>div()
    .shadow_sm()    // Small shadow
    .shadow_md()    // Medium shadow
    .shadow_lg()    // Large shadow
    .shadow_xl()    // Extra large shadow
<span class="boring">}</span></code></pre>
<h3 id="custom-shadows"><a class="header" href="#custom-shadows">Custom Shadows</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>div().shadow_params(
    2.0,   // Offset X
    4.0,   // Offset Y
    12.0,  // Blur radius
    Color::rgba(0.0, 0.0, 0.0, 0.3)
)
<span class="boring">}</span></code></pre>
<hr>
<h2 id="opacity"><a class="header" href="#opacity">Opacity</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>div()
    .opacity(0.5)       // 50% opacity
    .opaque()           // opacity: 1.0
    .translucent()      // opacity: 0.5
    .invisible()        // opacity: 0.0
<span class="boring">}</span></code></pre>
<hr>
<h2 id="transforms"><a class="header" href="#transforms">Transforms</a></h2>
<p>Apply 2D transforms to any element:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>div()
    .translate(10.0, 20.0)    // Move by (x, y)
    .scale(1.5)               // Uniform scale
    .scale_xy(1.5, 0.8)       // Non-uniform scale
    .rotate(45.0_f32.to_radians())  // Rotate (radians)
    .rotate_deg(45.0)         // Rotate (degrees)
<span class="boring">}</span></code></pre>
<p>For combined transforms:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use junita_core::Transform;

div().transform(
    Transform::translate(100.0, 50.0)
        .then_scale(1.2, 1.2)
        .then_rotate(0.1)
)
<span class="boring">}</span></code></pre>
<hr>
<h2 id="materials"><a class="header" href="#materials">Materials</a></h2>
<p>Junita includes GPU-accelerated material effects for modern, polished UIs.</p>
<h3 id="glass-material"><a class="header" href="#glass-material">Glass Material</a></h3>
<p>Creates a frosted glass effect with background blur:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Quick glass
div().glass()

// Customized glass
use junita_core::GlassMaterial;

div().material(Material::Glass(
    GlassMaterial::new()
        .blur(20.0)           // Blur intensity (0-50)
        .tint(Color::rgba(1.0, 1.0, 1.0, 0.1))
        .saturation(1.2)      // Color saturation
        .brightness(1.0)      // Brightness adjustment
        .noise(0.03)          // Frosted texture
        .border(0.8)          // Border highlight intensity
))
<span class="boring">}</span></code></pre>
<p><strong>Glass Presets:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>GlassMaterial::ultra_thin()  // Very subtle
GlassMaterial::thin()        // Light blur
GlassMaterial::regular()     // Standard (default)
GlassMaterial::thick()       // Heavy blur
GlassMaterial::frosted()     // Frosted window style
GlassMaterial::card()        // Card-like appearance
<span class="boring">}</span></code></pre>
<h3 id="metallic-material"><a class="header" href="#metallic-material">Metallic Material</a></h3>
<p>Creates reflective metallic surfaces:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use junita_core::MetallicMaterial;

div().material(Material::Metallic(
    MetallicMaterial::new()
        .color(Color::WHITE)
        .roughness(0.3)       // 0 = mirror, 1 = matte
        .metallic(1.0)        // Metal intensity
        .reflection(0.5)      // Reflection strength
))
<span class="boring">}</span></code></pre>
<p><strong>Metallic Presets:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>MetallicMaterial::chrome()   // Polished chrome
MetallicMaterial::brushed()  // Brushed metal
MetallicMaterial::gold()     // Gold finish
MetallicMaterial::silver()   // Silver finish
MetallicMaterial::copper()   // Copper finish
<span class="boring">}</span></code></pre>
<h3 id="quick-material-methods"><a class="header" href="#quick-material-methods">Quick Material Methods</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>div().glass()       // Default glass material
div().metallic()    // Default metallic material
div().chrome()      // Chrome preset
div().gold()        // Gold preset
<span class="boring">}</span></code></pre>
<hr>
<h2 id="render-layers"><a class="header" href="#render-layers">Render Layers</a></h2>
<p>Control rendering order with layers:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use junita_core::RenderLayer;

div()
    .layer(RenderLayer::Background)  // Rendered first
    .child(background_content())

div()
    .layer(RenderLayer::Foreground)  // Rendered on top
    .child(overlay_content())
<span class="boring">}</span></code></pre>
<p>For glass effects, content behind glass should be on <code>.background()</code> layer:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>stack()
    .child(
        div().background()  // Behind glass
            .child(colorful_background())
    )
    .child(
        div().glass()       // Glass overlay
            .foreground()   // On top
            .child(content())
    )
<span class="boring">}</span></code></pre>
<hr>
<h2 id="common-styling-patterns"><a class="header" href="#common-styling-patterns">Common Styling Patterns</a></h2>
<h3 id="card-style"><a class="header" href="#card-style">Card Style</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn card() -&gt; Div {
    div()
        .p(16.0)
        .rounded(12.0)
        .bg(Color::rgba(0.15, 0.15, 0.2, 1.0))
        .shadow_md()
}
<span class="boring">}</span></code></pre>
<h3 id="glass-card"><a class="header" href="#glass-card">Glass Card</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn glass_card() -&gt; Div {
    div()
        .p(16.0)
        .rounded(16.0)
        .glass()
        .shadow_lg()
}
<span class="boring">}</span></code></pre>
<h3 id="button-styles"><a class="header" href="#button-styles">Button Styles</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn primary_button() -&gt; Div {
    div()
        .px(4.0)
        .py(2.0)
        .rounded(8.0)
        .bg(Color::rgba(0.3, 0.5, 0.9, 1.0))
}

fn secondary_button() -&gt; Div {
    div()
        .px(4.0)
        .py(2.0)
        .rounded(8.0)
        .bg(Color::rgba(0.2, 0.2, 0.25, 1.0))
}

fn ghost_button() -&gt; Div {
    div()
        .px(4.0)
        .py(2.0)
        .rounded(8.0)
        .bg(Color::TRANSPARENT)
}
<span class="boring">}</span></code></pre>
<h3 id="hover-effects-with-state"><a class="header" href="#hover-effects-with-state">Hover Effects with State</a></h3>
<p>Use <code>stateful(handle)</code> to create elements with automatic hover/press state transitions:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use junita_layout::stateful::stateful;

fn hoverable_card(ctx: &amp;WindowedContext) -&gt; impl ElementBuilder {
    let handle = ctx.use_state(ButtonState::Idle);

    stateful(handle)
        .p(16.0)
        .rounded(12.0)
        .on_state(|state, div| {
            let bg = match state {
                ButtonState::Idle =&gt; Color::rgba(0.15, 0.15, 0.2, 1.0),
                ButtonState::Hovered =&gt; Color::rgba(0.18, 0.18, 0.24, 1.0),
                ButtonState::Pressed =&gt; Color::rgba(0.12, 0.12, 0.16, 1.0),
                _ =&gt; Color::rgba(0.15, 0.15, 0.2, 1.0),
            };
            div.set_bg(bg);
        })
        .child(text("Hover me").color(Color::WHITE))
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="dark-theme-color-palette"><a class="header" href="#dark-theme-color-palette">Dark Theme Color Palette</a></h2>
<p>Common colors for dark-themed UIs:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Backgrounds
let bg_primary = Color::rgba(0.08, 0.08, 0.12, 1.0);
let bg_secondary = Color::rgba(0.12, 0.12, 0.16, 1.0);
let bg_tertiary = Color::rgba(0.16, 0.16, 0.2, 1.0);

// Surfaces
let surface = Color::rgba(0.15, 0.15, 0.2, 1.0);
let surface_hover = Color::rgba(0.18, 0.18, 0.24, 1.0);

// Text
let text_primary = Color::WHITE;
let text_secondary = Color::rgba(0.7, 0.7, 0.8, 1.0);
let text_muted = Color::rgba(0.5, 0.5, 0.6, 1.0);

// Accent
let accent = Color::rgba(0.4, 0.6, 1.0, 1.0);
let accent_hover = Color::rgba(0.5, 0.7, 1.0, 1.0);

// Status
let success = Color::rgba(0.2, 0.8, 0.4, 1.0);
let warning = Color::rgba(0.9, 0.7, 0.2, 1.0);
let error = Color::rgba(0.9, 0.3, 0.3, 1.0);
<span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="css-styling"><a class="header" href="#css-styling">CSS Styling</a></h1>
<p>Junita includes a powerful CSS parser that allows you to define styles using familiar CSS syntax. This enables separation of concerns between layout code and visual styling.</p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>The CSS system supports:</p>
<ul>
<li><strong>ID-based selectors</strong> (<code>#element-id</code>)</li>
<li><strong>State modifiers</strong> (<code>:hover</code>, <code>:active</code>, <code>:focus</code>, <code>:disabled</code>)</li>
<li><strong>CSS custom properties</strong> (<code>:root</code> and <code>var()</code>)</li>
<li><strong>Keyframe animations</strong> (<code>@keyframes</code>)</li>
<li><strong>Automatic animation application</strong> via the <code>animation:</code> property</li>
<li><strong>Theme integration</strong> (<code>theme()</code> function)</li>
<li><strong>Length units</strong> (<code>px</code>, <code>sp</code>, <code>%</code>)</li>
<li><strong>Gradients</strong> (<code>linear-gradient</code>, <code>radial-gradient</code>, <code>conic-gradient</code>)</li>
</ul>
<hr>
<h2 id="basic-usage"><a class="header" href="#basic-usage">Basic Usage</a></h2>
<h3 id="parsing-css"><a class="header" href="#parsing-css">Parsing CSS</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use junita_layout::prelude::*;

let css = r#"
    #card {
        background: #3498db;
        border-radius: 12px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }
"#;

let result = Stylesheet::parse_with_errors(css);

// Check for errors
if result.has_errors() {
    result.print_colored_diagnostics();
}

let stylesheet = result.stylesheet;
<span class="boring">}</span></code></pre>
<h3 id="applying-styles-to-elements"><a class="header" href="#applying-styles-to-elements">Applying Styles to Elements</a></h3>
<p>Attach the stylesheet to the RenderTree:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::Arc;

// In your render tree setup
render_tree.set_stylesheet(Some(Arc::new(stylesheet)));

// Then use IDs on elements
div()
    .id("card")
    .child(text("Styled with CSS!"))
<span class="boring">}</span></code></pre>
<hr>
<h2 id="supported-properties"><a class="header" href="#supported-properties">Supported Properties</a></h2>
<h3 id="background"><a class="header" href="#background">Background</a></h3>
<pre><code class="language-css">#element {
    background: #ff5733;                    /* Hex color */
    background: rgb(255, 87, 51);           /* RGB */
    background: rgba(255, 87, 51, 0.8);     /* RGBA */
    background: theme(primary);             /* Theme token */
}
</code></pre>
<h3 id="gradients-1"><a class="header" href="#gradients-1">Gradients</a></h3>
<p>CSS gradients are fully supported for the <code>background</code> property:</p>
<h4 id="linear-gradients"><a class="header" href="#linear-gradients">Linear Gradients</a></h4>
<pre><code class="language-css">#element {
    /* Angle-based (0deg = up, 90deg = right, 180deg = down) */
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);

    /* Direction keywords */
    background: linear-gradient(to right, red, blue);
    background: linear-gradient(to bottom right, #fff, #000);

    /* Multiple color stops */
    background: linear-gradient(90deg, red 0%, yellow 50%, green 100%);

    /* Implied positions (evenly distributed) */
    background: linear-gradient(to bottom, red, yellow, green);

    /* Different angle units */
    background: linear-gradient(0.25turn, red, blue);  /* 90deg */
    background: linear-gradient(1.5708rad, red, blue); /* ~90deg */
}
</code></pre>
<h4 id="radial-gradients"><a class="header" href="#radial-gradients">Radial Gradients</a></h4>
<pre><code class="language-css">#element {
    /* Simple circle from center */
    background: radial-gradient(circle, red, blue);

    /* With position */
    background: radial-gradient(circle at center, red, blue);
    background: radial-gradient(circle at 25% 75%, red, blue);

    /* Ellipse shape */
    background: radial-gradient(ellipse at center, red, blue);

    /* Multiple color stops */
    background: radial-gradient(circle, red 0%, yellow 50%, green 100%);
}
</code></pre>
<h4 id="conic-gradients"><a class="header" href="#conic-gradients">Conic Gradients</a></h4>
<pre><code class="language-css">#element {
    /* Simple color wheel */
    background: conic-gradient(red, yellow, green, blue, red);

    /* With starting angle */
    background: conic-gradient(from 45deg, red, blue);

    /* With position */
    background: conic-gradient(at 25% 75%, red, blue);

    /* Combined angle and position */
    background: conic-gradient(from 90deg at center, red, blue);
}
</code></pre>
<h4 id="gradient-color-stops"><a class="header" href="#gradient-color-stops">Gradient Color Stops</a></h4>
<p>Color stops can use any supported color format:</p>
<pre><code class="language-css">#element {
    /* Hex colors with positions */
    background: linear-gradient(to right, #667eea 0%, #764ba2 100%);

    /* RGBA colors */
    background: linear-gradient(45deg, rgba(255, 0, 0, 0.5), rgba(0, 0, 255, 0.8));

    /* Named colors */
    background: linear-gradient(to right, red, orange, yellow, green, blue);

    /* Mixed formats */
    background: linear-gradient(135deg, #ff0000, rgba(0, 255, 0, 0.5) 50%, blue);
}
</code></pre>
<h3 id="border-radius"><a class="header" href="#border-radius">Border Radius</a></h3>
<pre><code class="language-css">#element {
    border-radius: 8px;                     /* Uniform */
    border-radius: theme(radius-lg);        /* Theme token */
}
</code></pre>
<h3 id="box-shadow"><a class="header" href="#box-shadow">Box Shadow</a></h3>
<pre><code class="language-css">#element {
    box-shadow: 2px 4px 12px rgba(0, 0, 0, 0.3);  /* x y blur color */
    box-shadow: theme(shadow-md);                 /* Theme token */
    box-shadow: none;                             /* Remove shadow */
}
</code></pre>
<h3 id="transform"><a class="header" href="#transform">Transform</a></h3>
<pre><code class="language-css">#element {
    transform: scale(1.02);                 /* Uniform scale */
    transform: scale(1.5, 0.8);             /* Non-uniform */
    transform: translate(10px, 20px);       /* Translation */
    transform: translateX(10px);            /* X only */
    transform: translateY(20px);            /* Y only */
    transform: rotate(45deg);               /* Rotation */
}
</code></pre>
<h3 id="opacity-1"><a class="header" href="#opacity-1">Opacity</a></h3>
<pre><code class="language-css">#element {
    opacity: 0.8;
}
</code></pre>
<h3 id="render-layer"><a class="header" href="#render-layer">Render Layer</a></h3>
<pre><code class="language-css">#element {
    render-layer: foreground;               /* On top */
    render-layer: background;               /* Behind */
    render-layer: glass;                    /* Glass layer */
}
</code></pre>
<hr>
<h2 id="length-units"><a class="header" href="#length-units">Length Units</a></h2>
<p>Junita CSS supports three types of length units:</p>
<h3 id="pixels-px"><a class="header" href="#pixels-px">Pixels (<code>px</code>)</a></h3>
<p>Raw pixel values. These are the default when no unit is specified.</p>
<pre><code class="language-css">#element {
    border-radius: 8px;
    box-shadow: 2px 4px 12px rgba(0, 0, 0, 0.3);
    transform: translate(10px, 20px);
}
</code></pre>
<h3 id="spacing-units-sp"><a class="header" href="#spacing-units-sp">Spacing Units (<code>sp</code>)</a></h3>
<p>Spacing units follow a 4px grid system, where <code>1sp = 4px</code>. This helps maintain consistent spacing throughout your application.</p>
<pre><code class="language-css">#card {
    border-radius: 2sp;                    /* 2 * 4 = 8px */
    box-shadow: 1sp 2sp 4sp rgba(0,0,0,0.2); /* 4px 8px 16px */
    transform: translate(4sp, 2sp);         /* 16px, 8px */
}
</code></pre>
<p>Common <code>sp</code> values:</p>
<ul>
<li><code>1sp</code> = 4px</li>
<li><code>2sp</code> = 8px</li>
<li><code>4sp</code> = 16px</li>
<li><code>6sp</code> = 24px</li>
<li><code>8sp</code> = 32px</li>
</ul>
<h3 id="percentages-"><a class="header" href="#percentages-">Percentages (<code>%</code>)</a></h3>
<p>Percentages are supported in gradient color stops and position values.</p>
<pre><code class="language-css">#element {
    /* Gradient color stops use percentages */
    background: linear-gradient(to right, red 0%, blue 100%);

    /* Radial/conic gradient positions */
    background: radial-gradient(circle at 25% 75%, red, blue);
}
</code></pre>
<hr>
<h2 id="state-modifiers"><a class="header" href="#state-modifiers">State Modifiers</a></h2>
<p>Define different styles for interactive states:</p>
<pre><code class="language-css">#button {
    background: theme(primary);
    transform: scale(1.0);
}

#button:hover {
    background: theme(primary-hover);
    transform: scale(1.02);
}

#button:active {
    transform: scale(0.98);
}

#button:focus {
    box-shadow: 0 0 0 3px theme(primary);
}

#button:disabled {
    opacity: 0.5;
}
</code></pre>
<h3 id="querying-state-styles"><a class="header" href="#querying-state-styles">Querying State Styles</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Get base style
let base = stylesheet.get("button");

// Get state-specific style
let hover = stylesheet.get_with_state("button", CssElementState::Hover);
let active = stylesheet.get_with_state("button", CssElementState::Active);

// Get all states at once
let (base, states) = stylesheet.get_all_states("button");
for (state, style) in states {
    println!(":{} =&gt; {:?}", state, style.opacity);
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="css-variables"><a class="header" href="#css-variables">CSS Variables</a></h2>
<p>Define reusable values with custom properties:</p>
<pre><code class="language-css">:root {
    --brand-color: #3498db;
    --hover-opacity: 0.85;
    --card-radius: 12px;
    --spacing-md: 16px;
}

#card {
    background: var(--brand-color);
    border-radius: var(--card-radius);
    opacity: 1.0;
}

#card:hover {
    opacity: var(--hover-opacity);
}
</code></pre>
<h3 id="fallback-values"><a class="header" href="#fallback-values">Fallback Values</a></h3>
<pre><code class="language-css">#element {
    background: var(--undefined-color, #333);  /* Uses fallback */
}
</code></pre>
<h3 id="accessing-variables-programmatically"><a class="header" href="#accessing-variables-programmatically">Accessing Variables Programmatically</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Get a variable value
if let Some(value) = stylesheet.get_variable("brand-color") {
    println!("Brand color: {}", value);
}

// Iterate all variables
for name in stylesheet.variable_names() {
    let value = stylesheet.get_variable(name).unwrap();
    println!("--{}: {}", name, value);
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="theme-integration"><a class="header" href="#theme-integration">Theme Integration</a></h2>
<p>Use the <code>theme()</code> function to reference theme tokens:</p>
<pre><code class="language-css">#card {
    background: theme(surface);
    border-radius: theme(radius-lg);
    box-shadow: theme(shadow-md);
}

#button {
    background: theme(primary);
}

#button:hover {
    background: theme(primary-hover);
}
</code></pre>
<h3 id="available-theme-tokens"><a class="header" href="#available-theme-tokens">Available Theme Tokens</a></h3>
<p><strong>Colors:</strong></p>
<ul>
<li><code>primary</code>, <code>primary-hover</code>, <code>primary-active</code></li>
<li><code>secondary</code>, <code>secondary-hover</code>, <code>secondary-active</code></li>
<li><code>success</code>, <code>success-bg</code></li>
<li><code>warning</code>, <code>warning-bg</code></li>
<li><code>error</code>, <code>error-bg</code></li>
<li><code>info</code>, <code>info-bg</code></li>
<li><code>foreground</code>, <code>foreground-muted</code></li>
<li><code>background</code>, <code>surface</code>, <code>surface-hover</code></li>
<li><code>border</code>, <code>border-muted</code></li>
</ul>
<p><strong>Radii:</strong></p>
<ul>
<li><code>radius-sm</code>, <code>radius-default</code>, <code>radius-md</code></li>
<li><code>radius-lg</code>, <code>radius-xl</code>, <code>radius-2xl</code></li>
</ul>
<p><strong>Shadows:</strong></p>
<ul>
<li><code>shadow-sm</code>, <code>shadow-default</code>, <code>shadow-md</code></li>
<li><code>shadow-lg</code>, <code>shadow-xl</code></li>
</ul>
<hr>
<h2 id="keyframe-animations"><a class="header" href="#keyframe-animations">Keyframe Animations</a></h2>
<p>Define complex animations with <code>@keyframes</code>:</p>
<pre><code class="language-css">@keyframes fade-in {
    from {
        opacity: 0;
        transform: translateY(20px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

@keyframes pulse {
    0%, 100% {
        opacity: 1;
        transform: scale(1);
    }
    50% {
        opacity: 0.8;
        transform: scale(1.05);
    }
}
</code></pre>
<h3 id="percentage-positions"><a class="header" href="#percentage-positions">Percentage Positions</a></h3>
<pre><code class="language-css">@keyframes complex-animation {
    0% { opacity: 0; }
    25% { opacity: 0.5; transform: scale(1.1); }
    50% { opacity: 1; }
    75% { opacity: 0.5; transform: scale(0.9); }
    100% { opacity: 1; transform: scale(1); }
}
</code></pre>
<h3 id="accessing-keyframes"><a class="header" href="#accessing-keyframes">Accessing Keyframes</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Get keyframes by name
if let Some(keyframes) = stylesheet.get_keyframes("fade-in") {
    println!("Animation has {} stops", keyframes.keyframes.len());

    for kf in &amp;keyframes.keyframes {
        println!("  {}%: opacity={:?}",
            (kf.position * 100.0) as i32,
            kf.style.opacity
        );
    }
}
<span class="boring">}</span></code></pre>
<h3 id="converting-to-motion-animation"><a class="header" href="#converting-to-motion-animation">Converting to Motion Animation</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Convert to MotionAnimation (for simple from/to animations)
let motion = keyframes.to_motion_animation(300, 200);  // enter_ms, exit_ms

// Convert to MultiKeyframeAnimation (for complex multi-step animations)
let animation = keyframes.to_multi_keyframe_animation(1000, Easing::EaseInOut);
<span class="boring">}</span></code></pre>
<hr>
<h2 id="animation-property"><a class="header" href="#animation-property">Animation Property</a></h2>
<p>Apply animations to elements with the <code>animation:</code> property:</p>
<pre><code class="language-css">@keyframes slide-in {
    from { opacity: 0; transform: translateY(20px); }
    to { opacity: 1; transform: translateY(0); }
}

#modal {
    animation: slide-in 300ms ease-out;
}
</code></pre>
<h3 id="animation-shorthand"><a class="header" href="#animation-shorthand">Animation Shorthand</a></h3>
<pre><code class="language-css">#element {
    /* animation: name duration timing-function delay iteration-count direction fill-mode */
    animation: pulse 2s ease-in-out 100ms infinite alternate forwards;
}
</code></pre>
<h3 id="individual-properties"><a class="header" href="#individual-properties">Individual Properties</a></h3>
<pre><code class="language-css">#element {
    animation-name: pulse;
    animation-duration: 2s;
    animation-timing-function: ease-in-out;
    animation-delay: 100ms;
    animation-iteration-count: infinite;  /* or a number */
    animation-direction: alternate;        /* normal | reverse | alternate | alternate-reverse */
    animation-fill-mode: forwards;         /* none | forwards | backwards | both */
}
</code></pre>
<h3 id="automatic-application"><a class="header" href="#automatic-application">Automatic Application</a></h3>
<p>When a stylesheet is attached to the RenderTree, elements with IDs automatically receive animations:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let css = r#"
    @keyframes card-enter {
        from { opacity: 0; transform: scale(0.95); }
        to { opacity: 1; transform: scale(1); }
    }

    #card {
        animation: card-enter 300ms ease-out;
    }
"#;

let stylesheet = Stylesheet::parse_with_errors(css).stylesheet;
render_tree.set_stylesheet(Some(Arc::new(stylesheet)));

// This element will automatically animate on render!
div()
    .id("card")
    .child(content())
<span class="boring">}</span></code></pre>
<hr>
<h2 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h2>
<p>The CSS parser collects errors without failing:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let css = r#"
    #card {
        background: red;
        opacity: invalid;        /* Error: invalid value */
        unknown-prop: foo;       /* Warning: unknown property */
    }
"#;

let result = Stylesheet::parse_with_errors(css);

// Check for issues
if result.has_errors() {
    println!("Has {} error(s)", result.errors_only().count());
}
if result.has_warnings() {
    println!("Has {} warning(s)", result.warnings_only().count());
}

// Print colored diagnostics to console
result.print_colored_diagnostics();
result.print_summary();

// The valid properties are still parsed!
let style = result.stylesheet.get("card").unwrap();
assert!(style.background.is_some());  // "red" was parsed
<span class="boring">}</span></code></pre>
<h3 id="error-information"><a class="header" href="#error-information">Error Information</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for error in &amp;result.errors {
    println!("Line {}, Column {}: {}",
        error.line,
        error.column,
        error.message
    );

    if let Some(ref prop) = error.property {
        println!("  Property: {}", prop);
    }
    if let Some(ref val) = error.value {
        println!("  Value: {}", val);
    }
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="motion-container-integration"><a class="header" href="#motion-container-integration">Motion Container Integration</a></h2>
<p>Use CSS keyframes with the <code>Motion</code> container:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let css = r#"
    @keyframes modal-enter {
        from { opacity: 0; transform: scale(0.9) translateY(20px); }
        to { opacity: 1; transform: scale(1) translateY(0); }
    }
"#;

let stylesheet = Stylesheet::parse_with_errors(css).stylesheet;

// Method 1: Using from_stylesheet
motion()
    .from_stylesheet(&amp;stylesheet, "modal-enter", 300, 200)
    .child(modal_content())

// Method 2: Using keyframes_from_stylesheet for multi-step animations
motion()
    .keyframes_from_stylesheet(&amp;stylesheet, "pulse", 1000, Easing::EaseInOut)
    .child(pulsing_element())
<span class="boring">}</span></code></pre>
<hr>
<h2 id="complete-example-1"><a class="header" href="#complete-example-1">Complete Example</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use junita_layout::prelude::*;
use std::sync::Arc;

fn styled_app() -&gt; impl ElementBuilder {
    // Define styles
    let css = r#"
        :root {
            --card-bg: theme(surface);
            --card-radius: theme(radius-lg);
            --brand-gradient: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        @keyframes fade-in {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        #app-container {
            background: theme(background);
        }

        #card {
            background: var(--card-bg);
            border-radius: var(--card-radius);
            box-shadow: theme(shadow-md);
            animation: fade-in 300ms ease-out;
        }

        #card:hover {
            box-shadow: theme(shadow-lg);
            transform: translateY(-2px);
        }

        #gradient-card {
            background: var(--brand-gradient);
            border-radius: theme(radius-lg);
            box-shadow: theme(shadow-md);
        }

        #gradient-card:hover {
            background: linear-gradient(135deg, #7c8ff0 0%, #8b5cb8 100%);
            transform: translateY(-2px);
        }

        #primary-button {
            background: theme(primary);
            border-radius: theme(radius-default);
        }

        #primary-button:hover {
            background: theme(primary-hover);
            transform: scale(1.02);
        }

        #primary-button:active {
            transform: scale(0.98);
        }
    "#;

    let result = Stylesheet::parse_with_errors(css);
    if result.has_errors() {
        result.print_colored_diagnostics();
    }

    // In real usage, attach to render_tree
    // render_tree.set_stylesheet(Some(Arc::new(result.stylesheet)));

    div()
        .id("app-container")
        .flex_col()
        .p(24.0)
        .gap(16.0)
        .child(
            div()
                .id("card")
                .p(16.0)
                .child(text("Styled with CSS!"))
        )
        .child(
            div()
                .id("gradient-card")
                .p(16.0)
                .child(text("Gradient background!"))
        )
        .child(
            button("Click me")
                .id("primary-button")
        )
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<ol>
<li><strong>Use CSS variables</strong> for values you want to reuse or override</li>
<li><strong>Use theme tokens</strong> for colors that should respect the app’s theme</li>
<li><strong>Check for errors</strong> after parsing to catch typos and invalid values</li>
<li><strong>Keep animations short</strong> for UI transitions (150-400ms)</li>
<li><strong>Use state modifiers</strong> for hover/active effects instead of manual callbacks</li>
<li><strong>Prefer ID selectors</strong> (<code>#id</code>) for precise targeting</li>
</ol>
<hr>
<h2 id="comparison-with-builder-api"><a class="header" href="#comparison-with-builder-api">Comparison with Builder API</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>CSS</th><th>Builder API</th></tr>
</thead>
<tbody>
<tr><td><code>background: #3498db;</code></td><td><code>.bg(Color::hex("#3498db"))</code></td></tr>
<tr><td><code>border-radius: 8px;</code></td><td><code>.rounded(8.0)</code></td></tr>
<tr><td><code>transform: scale(1.02);</code></td><td><code>.scale(1.02)</code></td></tr>
<tr><td><code>opacity: 0.8;</code></td><td><code>.opacity(0.8)</code></td></tr>
<tr><td><code>box-shadow: theme(shadow-md);</code></td><td><code>.shadow_md()</code></td></tr>
</tbody>
</table>
</div>
<p>Both approaches can be combined - use CSS for base styles and the builder API for dynamic values.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="theming"><a class="header" href="#theming">Theming</a></h1>
<p>Junita provides a comprehensive theming system with design tokens, light/dark mode support, animated theme transitions, and platform-native color scheme detection.</p>
<h2 id="overview-1"><a class="header" href="#overview-1">Overview</a></h2>
<p>The theming system is built around these core concepts:</p>
<ul>
<li><strong>Design Tokens</strong>: Semantic color, typography, spacing, and radius values</li>
<li><strong>ThemeState</strong>: Global singleton for theme access and switching</li>
<li><strong>Animated Transitions</strong>: Smooth spring-based color interpolation between themes</li>
<li><strong>Platform Detection</strong>: Automatic system dark/light mode detection</li>
</ul>
<hr>
<h2 id="quick-start-1"><a class="header" href="#quick-start-1">Quick Start</a></h2>
<h3 id="accessing-theme-tokens"><a class="header" href="#accessing-theme-tokens">Accessing Theme Tokens</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use junita_theme::{ThemeState, ColorToken};

fn my_component() -&gt; impl ElementBuilder {
    let theme = ThemeState::get();

    // Get semantic colors
    let bg = theme.color(ColorToken::Background);
    let text = theme.color(ColorToken::TextPrimary);
    let primary = theme.color(ColorToken::Primary);

    // Get spacing values
    let padding = theme.spacing().space_4;

    // Get typography
    let font_size = theme.typography().text_base;

    // Get border radius
    let radius = theme.radii().radius_lg;

    div()
        .bg(bg)
        .p(padding)
        .rounded(radius)
        .child(
            text("Hello, themed world!")
                .size(font_size)
                .color(text)
        )
}
<span class="boring">}</span></code></pre>
<h3 id="toggling-color-scheme"><a class="header" href="#toggling-color-scheme">Toggling Color Scheme</a></h3>
<blockquote>
<p>⚠️ <strong>Known Limitation: Dynamic Theme Toggle</strong></p>
<p>Dynamic theme switching at runtime (e.g., toggling between light/dark mode while the app is running) currently has significant limitations:</p>
<ul>
<li><strong>Full UI rebuild required</strong>: Theme changes trigger a complete UI tree rebuild, which is expensive and can cause visual glitches</li>
<li><strong><code>on_ready</code> callbacks fire multiple times</strong>: During theme animation, <code>on_ready</code> may fire repeatedly instead of once</li>
<li><strong>Animation ticks cause rebuilds</strong>: Each frame of the theme transition animation triggers another rebuild</li>
</ul>
<p><strong>Recommendation</strong>: For production apps, set the theme once at startup based on user preference or system settings. Theme changes should require an app restart.</p>
<p>This limitation will be addressed in a future release with token-based color resolution that allows visual-only repaints without tree rebuilds.</p>
</blockquote>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Toggle between light and dark mode
ThemeState::get().toggle_scheme();

// Or set explicitly
use junita_theme::ColorScheme;
ThemeState::get().set_scheme(ColorScheme::Dark);
ThemeState::get().set_scheme(ColorScheme::Light);

// Check current scheme
let scheme = ThemeState::get().scheme();
match scheme {
    ColorScheme::Light =&gt; { /* ... */ }
    ColorScheme::Dark =&gt; { /* ... */ }
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="color-tokens"><a class="header" href="#color-tokens">Color Tokens</a></h2>
<p>Color tokens provide semantic meaning to colors, making it easy to build consistent UIs that adapt to theme changes.</p>
<h3 id="token-categories"><a class="header" href="#token-categories">Token Categories</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Category</th><th>Tokens</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><strong>Brand</strong></td><td><code>Primary</code>, <code>PrimaryHover</code>, <code>PrimaryActive</code>, <code>Secondary</code>, <code>SecondaryHover</code>, <code>SecondaryActive</code></td><td>Main brand colors</td></tr>
<tr><td><strong>Semantic</strong></td><td><code>Success</code>, <code>Warning</code>, <code>Error</code>, <code>Info</code> + <code>*Bg</code> variants</td><td>Status/feedback colors</td></tr>
<tr><td><strong>Surface</strong></td><td><code>Background</code>, <code>Surface</code>, <code>SurfaceElevated</code>, <code>SurfaceOverlay</code></td><td>Background layers</td></tr>
<tr><td><strong>Text</strong></td><td><code>TextPrimary</code>, <code>TextSecondary</code>, <code>TextTertiary</code>, <code>TextInverse</code>, <code>TextLink</code></td><td>Text colors</td></tr>
<tr><td><strong>Border</strong></td><td><code>Border</code>, <code>BorderHover</code>, <code>BorderFocus</code>, <code>BorderError</code></td><td>Border states</td></tr>
<tr><td><strong>Input</strong></td><td><code>InputBg</code>, <code>InputBgHover</code>, <code>InputBgFocus</code>, <code>InputBgDisabled</code></td><td>Form input backgrounds</td></tr>
<tr><td><strong>Selection</strong></td><td><code>Selection</code>, <code>SelectionText</code></td><td>Text selection colors</td></tr>
<tr><td><strong>Accent</strong></td><td><code>Accent</code>, <code>AccentSubtle</code></td><td>Accent highlights</td></tr>
</tbody>
</table>
</div>
<h3 id="usage-example"><a class="header" href="#usage-example">Usage Example</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use junita_theme::{ThemeState, ColorToken};

fn themed_card() -&gt; impl ElementBuilder {
    let theme = ThemeState::get();

    div()
        .bg(theme.color(ColorToken::Surface))
        .border(1.0, theme.color(ColorToken::Border))
        .rounded(theme.radii().radius_lg)
        .p(theme.spacing().space_4)
        .child(
            text("Card Title")
                .size(theme.typography().text_lg)
                .color(theme.color(ColorToken::TextPrimary))
        )
        .child(
            text("Card description text")
                .size(theme.typography().text_sm)
                .color(theme.color(ColorToken::TextSecondary))
        )
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="typography-tokens"><a class="header" href="#typography-tokens">Typography Tokens</a></h2>
<p>Typography tokens define a consistent type scale:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Token</th><th>Size</th><th>Use Case</th></tr>
</thead>
<tbody>
<tr><td><code>text_xs</code></td><td>12px</td><td>Captions, labels</td></tr>
<tr><td><code>text_sm</code></td><td>14px</td><td>Secondary text, buttons</td></tr>
<tr><td><code>text_base</code></td><td>16px</td><td>Body text</td></tr>
<tr><td><code>text_lg</code></td><td>18px</td><td>Large body text</td></tr>
<tr><td><code>text_xl</code></td><td>20px</td><td>Small headings</td></tr>
<tr><td><code>text_2xl</code></td><td>24px</td><td>Section headings</td></tr>
<tr><td><code>text_3xl</code></td><td>30px</td><td>Page headings</td></tr>
<tr><td><code>text_4xl</code></td><td>36px</td><td>Large headings</td></tr>
<tr><td><code>text_5xl</code></td><td>48px</td><td>Hero text</td></tr>
</tbody>
</table>
</div>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let theme = ThemeState::get();
let typo = theme.typography();

text("Heading").size(typo.text_2xl)
text("Body").size(typo.text_base)
text("Caption").size(typo.text_xs)
<span class="boring">}</span></code></pre>
<hr>
<h2 id="spacing-tokens"><a class="header" href="#spacing-tokens">Spacing Tokens</a></h2>
<p>Spacing follows a 4px base scale for consistent rhythm:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Token</th><th>Value</th><th>Use Case</th></tr>
</thead>
<tbody>
<tr><td><code>space_1</code></td><td>4px</td><td>Minimal spacing</td></tr>
<tr><td><code>space_2</code></td><td>8px</td><td>Tight spacing</td></tr>
<tr><td><code>space_2_5</code></td><td>10px</td><td>Between tight and standard</td></tr>
<tr><td><code>space_3</code></td><td>12px</td><td>Standard small</td></tr>
<tr><td><code>space_4</code></td><td>16px</td><td>Standard spacing</td></tr>
<tr><td><code>space_5</code></td><td>20px</td><td>Medium spacing</td></tr>
<tr><td><code>space_6</code></td><td>24px</td><td>Large spacing</td></tr>
<tr><td><code>space_8</code></td><td>32px</td><td>Section spacing</td></tr>
<tr><td><code>space_10</code></td><td>40px</td><td>Large section spacing</td></tr>
<tr><td><code>space_12</code></td><td>48px</td><td>Extra large spacing</td></tr>
</tbody>
</table>
</div>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let theme = ThemeState::get();
let spacing = theme.spacing();

div()
    .p(spacing.space_4)      // 16px padding
    .gap(spacing.space_3)    // 12px gap between children
    .my(spacing.space_6)     // 24px vertical margin
<span class="boring">}</span></code></pre>
<hr>
<h2 id="radius-tokens"><a class="header" href="#radius-tokens">Radius Tokens</a></h2>
<p>Border radius tokens for consistent rounded corners:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Token</th><th>Value</th><th>Use Case</th></tr>
</thead>
<tbody>
<tr><td><code>radius_none</code></td><td>0px</td><td>Sharp corners</td></tr>
<tr><td><code>radius_sm</code></td><td>4px</td><td>Subtle rounding</td></tr>
<tr><td><code>radius_md</code></td><td>6px</td><td>Standard rounding</td></tr>
<tr><td><code>radius_lg</code></td><td>8px</td><td>Pronounced rounding</td></tr>
<tr><td><code>radius_xl</code></td><td>12px</td><td>Large rounding</td></tr>
<tr><td><code>radius_2xl</code></td><td>16px</td><td>Extra large rounding</td></tr>
<tr><td><code>radius_full</code></td><td>9999px</td><td>Pill shape</td></tr>
</tbody>
</table>
</div>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let theme = ThemeState::get();

div().rounded(theme.radii().radius_lg)   // 8px corners
div().rounded(theme.radii().radius_full) // Pill shape
<span class="boring">}</span></code></pre>
<hr>
<h2 id="animated-theme-transitions"><a class="header" href="#animated-theme-transitions">Animated Theme Transitions</a></h2>
<blockquote>
<p>⚠️ <strong>Experimental Feature</strong></p>
<p>Animated theme transitions are currently experimental and have known issues. See the <a href="#toggling-color-scheme">Known Limitation</a> above. For production use, disable animations and require app restart for theme changes.</p>
</blockquote>
<p>When switching between light and dark mode, colors smoothly animate using spring physics. This happens automatically when you call <code>toggle_scheme()</code> or <code>set_scheme()</code>.</p>
<h3 id="how-it-works"><a class="header" href="#how-it-works">How It Works</a></h3>
<ol>
<li>Theme colors are stored as <code>AnimatedValue</code> in the global <code>ThemeState</code></li>
<li>When the scheme changes, target colors animate from current to new values</li>
<li>The animation scheduler drives smooth interpolation</li>
<li>UI rebuilds on each frame with interpolated colors (⚠️ this is the source of current performance issues)</li>
</ol>
<h3 id="configuration"><a class="header" href="#configuration">Configuration</a></h3>
<p>The transition uses a gentle spring configuration for smooth, natural motion:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Internal spring config for theme transitions
SpringConfig::gentle()  // stiffness: 120, damping: 14
<span class="boring">}</span></code></pre>
<h3 id="reading-animated-colors"><a class="header" href="#reading-animated-colors">Reading Animated Colors</a></h3>
<p>Colors are read during each render, automatically getting the interpolated value:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn my_component() -&gt; impl ElementBuilder {
    let theme = ThemeState::get();

    // This color will be interpolated during transitions
    let bg = theme.color(ColorToken::Background);

    div().bg(bg)
}
<span class="boring">}</span></code></pre>
<p><strong>Important</strong>: Always read colors from <code>ThemeState</code> inside your component function, not captured in closures at initialization time. This ensures colors update during animations.</p>
<hr>
<h2 id="reactive-theme-updates"><a class="header" href="#reactive-theme-updates">Reactive Theme Updates</a></h2>
<p>For interactive elements that need to respond to theme changes within event handlers, fetch colors inside the callback:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn themed_button(ctx: &amp;WindowedContext) -&gt; impl ElementBuilder {
    let handle = ctx.use_state_for("btn", ButtonState::Idle);

    stateful(handle)
        .on_state(|state, div| {
            // Fetch colors inside callback for theme reactivity
            let theme = ThemeState::get();
            let primary = theme.color(ColorToken::Primary);
            let primary_hover = theme.color(ColorToken::PrimaryHover);

            match state {
                ButtonState::Idle =&gt; div.set_bg(primary),
                ButtonState::Hovered =&gt; div.set_bg(primary_hover),
                // ...
            }
        })
        .child(text("Click me"))
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="default-theme-catppuccin"><a class="header" href="#default-theme-catppuccin">Default Theme: Catppuccin</a></h2>
<p>Junita’s default theme is derived from <a href="https://catppuccin.com/">Catppuccin</a>, a community-driven pastel theme:</p>
<ul>
<li><strong>Light mode</strong>: Catppuccin Latte</li>
<li><strong>Dark mode</strong>: Catppuccin Mocha</li>
</ul>
<h3 id="latte-light-palette"><a class="header" href="#latte-light-palette">Latte (Light) Palette</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Role</th><th>Color</th></tr>
</thead>
<tbody>
<tr><td>Background</td><td><code>#EFF1F5</code></td></tr>
<tr><td>Surface</td><td><code>#FFFFFF</code></td></tr>
<tr><td>Text Primary</td><td><code>#4C4F69</code></td></tr>
<tr><td>Primary</td><td><code>#1E66F5</code> (Blue)</td></tr>
<tr><td>Success</td><td><code>#40A02B</code> (Green)</td></tr>
<tr><td>Warning</td><td><code>#DF8E1D</code> (Yellow)</td></tr>
<tr><td>Error</td><td><code>#D20F39</code> (Red)</td></tr>
</tbody>
</table>
</div>
<h3 id="mocha-dark-palette"><a class="header" href="#mocha-dark-palette">Mocha (Dark) Palette</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Role</th><th>Color</th></tr>
</thead>
<tbody>
<tr><td>Background</td><td><code>#1E1E2E</code></td></tr>
<tr><td>Surface</td><td><code>#313244</code></td></tr>
<tr><td>Text Primary</td><td><code>#CDD6F4</code></td></tr>
<tr><td>Primary</td><td><code>#89B4FA</code> (Blue)</td></tr>
<tr><td>Success</td><td><code>#A6E3A1</code> (Green)</td></tr>
<tr><td>Warning</td><td><code>#F9E2AF</code> (Yellow)</td></tr>
<tr><td>Error</td><td><code>#F38BA8</code> (Red)</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="platform-color-scheme-detection"><a class="header" href="#platform-color-scheme-detection">Platform Color Scheme Detection</a></h2>
<p>Junita automatically detects the system’s preferred color scheme on supported platforms:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Platform</th><th>Detection Method</th></tr>
</thead>
<tbody>
<tr><td>macOS</td><td><code>AppleInterfaceStyle</code> from UserDefaults</td></tr>
<tr><td>Windows</td><td>Windows.UI.ViewManagement API</td></tr>
<tr><td>Linux</td><td>XDG/GTK settings</td></tr>
<tr><td>iOS</td><td>Native UITraitCollection</td></tr>
<tr><td>Android</td><td>Configuration.uiMode</td></tr>
</tbody>
</table>
</div>
<h3 id="manual-detection"><a class="header" href="#manual-detection">Manual Detection</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use junita_theme::platform::detect_system_color_scheme;

// Get system preference
let scheme = detect_system_color_scheme();

// Initialize theme with system preference
ThemeState::init(JunitaTheme::bundle(), scheme);
<span class="boring">}</span></code></pre>
<p>The <code>WindowedApp</code> automatically initializes the theme with system color scheme detection.</p>
<hr>
<h2 id="system-scheme-watcher-optional"><a class="header" href="#system-scheme-watcher-optional">System Scheme Watcher (Optional)</a></h2>
<blockquote>
<p>⚠️ <strong>Not Recommended for Production</strong></p>
<p>Due to the <a href="#toggling-color-scheme">dynamic theme toggle limitations</a>, the system scheme watcher is not recommended for production apps. When the system theme changes, it triggers the same problematic full UI rebuild. Consider detecting the system scheme once at startup instead.</p>
</blockquote>
<p>For apps that need to automatically follow system theme changes (e.g., when the user toggles dark mode in system settings), Junita provides an optional background watcher.</p>
<h3 id="enabling-the-feature"><a class="header" href="#enabling-the-feature">Enabling the Feature</a></h3>
<p>Add the <code>watcher</code> feature to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
junita_theme = { version = "0.1", features = ["watcher"] }
</code></pre>
<h3 id="basic-usage-1"><a class="header" href="#basic-usage-1">Basic Usage</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use junita_theme::{SystemSchemeWatcher, WatcherConfig};
use std::time::Duration;

// Start watching with default interval (1 second)
let watcher = SystemSchemeWatcher::start();

// Or with a custom polling interval
let watcher = SystemSchemeWatcher::start_with_interval(Duration::from_secs(5));

// The watcher runs in a background thread and automatically updates
// ThemeState when the system color scheme changes.

// Stop watching when done (or let it drop)
// watcher.stop();
<span class="boring">}</span></code></pre>
<h3 id="using-watcherconfig"><a class="header" href="#using-watcherconfig">Using WatcherConfig</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use junita_theme::WatcherConfig;
use std::time::Duration;

// Builder pattern for configuration
let watcher = WatcherConfig::new()
    .poll_interval(Duration::from_secs(2))  // Check every 2 seconds
    .auto_start(true)                        // Start immediately
    .build();
<span class="boring">}</span></code></pre>
<h3 id="how-it-works-1"><a class="header" href="#how-it-works-1">How It Works</a></h3>
<ol>
<li>The watcher runs in a background thread named <code>junita-scheme-watcher</code></li>
<li>It polls the system color scheme at the configured interval</li>
<li>When a change is detected, it calls <code>ThemeState::set_scheme()</code> automatically</li>
<li>Theme transitions are animated smoothly using spring physics</li>
<li>The watcher is thread-safe and cleans up when dropped</li>
</ol>
<h3 id="use-cases"><a class="header" href="#use-cases">Use Cases</a></h3>
<ul>
<li><strong>Desktop apps</strong>: Follow system dark/light mode preference</li>
<li><strong>Long-running apps</strong>: Adapt to user changing system settings</li>
<li><strong>Kiosk/display apps</strong>: Automatically switch themes based on time of day (if OS supports scheduling)</li>
</ul>
<h3 id="performance-notes"><a class="header" href="#performance-notes">Performance Notes</a></h3>
<ul>
<li>The default 1-second interval is a good balance between responsiveness and CPU usage</li>
<li>For less critical apps, consider using 5-10 second intervals</li>
<li>The watcher thread sleeps between checks, consuming minimal resources</li>
</ul>
<hr>
<h2 id="dynamic-token-overrides"><a class="header" href="#dynamic-token-overrides">Dynamic Token Overrides</a></h2>
<p>You can override individual tokens at runtime without changing the entire theme:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use junita_theme::{ThemeState, ColorToken};
use junita_core::Color;

// Override a specific color
ThemeState::get().set_color_override(
    ColorToken::Primary,
    Color::from_hex(0x6366F1)  // Custom brand color
);

// Remove override (revert to theme default)
ThemeState::get().remove_color_override(ColorToken::Primary);

// Clear all overrides
ThemeState::get().clear_overrides();
<span class="boring">}</span></code></pre>
<h3 id="override-types"><a class="header" href="#override-types">Override Types</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Method</th><th>Triggers</th></tr>
</thead>
<tbody>
<tr><td><code>set_color_override()</code></td><td>Repaint only</td></tr>
<tr><td><code>set_spacing_override()</code></td><td>Layout recompute</td></tr>
<tr><td><code>set_radius_override()</code></td><td>Repaint only</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="building-themed-components"><a class="header" href="#building-themed-components">Building Themed Components</a></h2>
<h3 id="pattern-1-direct-token-access"><a class="header" href="#pattern-1-direct-token-access">Pattern 1: Direct Token Access</a></h3>
<p>Best for simple components:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn simple_badge(label: &amp;str) -&gt; impl ElementBuilder {
    let theme = ThemeState::get();

    div()
        .px(theme.spacing().space_2)
        .py(theme.spacing().space_1)
        .rounded(theme.radii().radius_md)
        .bg(theme.color(ColorToken::AccentSubtle))
        .child(
            text(label)
                .size(theme.typography().text_xs)
                .color(theme.color(ColorToken::Accent))
        )
}
<span class="boring">}</span></code></pre>
<h3 id="pattern-2-themed-config-struct"><a class="header" href="#pattern-2-themed-config-struct">Pattern 2: Themed Config Struct</a></h3>
<p>Best for complex widgets with many options:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct CardConfig {
    pub padding: f32,
    pub radius: f32,
    pub show_shadow: bool,
}

impl CardConfig {
    pub fn themed() -&gt; Self {
        let theme = ThemeState::get();
        Self {
            padding: theme.spacing().space_4,
            radius: theme.radii().radius_lg,
            show_shadow: true,
        }
    }
}
<span class="boring">}</span></code></pre>
<h3 id="pattern-3-color-token-parameters"><a class="header" href="#pattern-3-color-token-parameters">Pattern 3: Color Token Parameters</a></h3>
<p>For components that accept different color variants:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn status_badge(label: &amp;str, color_token: ColorToken) -&gt; impl ElementBuilder {
    let theme = ThemeState::get();
    let color = theme.color(color_token);

    div()
        .px(theme.spacing().space_2)
        .py(theme.spacing().space_1)
        .rounded(theme.radii().radius_full)
        .bg(color.with_alpha(0.15))
        .child(
            text(label)
                .size(theme.typography().text_xs)
                .color(color)
        )
}

// Usage
status_badge("Success", ColorToken::Success)
status_badge("Warning", ColorToken::Warning)
status_badge("Error", ColorToken::Error)
<span class="boring">}</span></code></pre>
<hr>
<h2 id="best-practices-1"><a class="header" href="#best-practices-1">Best Practices</a></h2>
<ol>
<li>
<p><strong>Always use semantic tokens</strong> - Use <code>ColorToken::Primary</code> instead of hardcoded colors for automatic theme support.</p>
</li>
<li>
<p><strong>Read colors at render time</strong> - Access <code>ThemeState::get()</code> inside your component function, not at module level.</p>
</li>
<li>
<p><strong>Fetch in callbacks</strong> - For <code>on_state</code> and other callbacks, fetch theme colors inside the callback to respond to theme changes.</p>
</li>
<li>
<p><strong>Use spacing scale</strong> - Use <code>theme.spacing().space_*</code> for consistent visual rhythm.</p>
</li>
<li>
<p><strong>Match radius to context</strong> - Use smaller radii for small elements, larger for cards and panels.</p>
</li>
<li>
<p><strong>Test both themes</strong> - Always verify your UI looks good in both light and dark modes.</p>
</li>
</ol>
<hr>
<h2 id="example-complete-themed-component"><a class="header" href="#example-complete-themed-component">Example: Complete Themed Component</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use junita_app::prelude::*;
use junita_theme::{ThemeState, ColorToken};

fn notification_toast(
    ctx: &amp;WindowedContext,
    message: &amp;str,
    variant: ColorToken,
) -&gt; impl ElementBuilder {
    let theme = ThemeState::get();
    let handle = ctx.use_state_for("toast", ButtonState::Idle);

    let bg_color = theme.color(variant);

    stateful(handle)
        .w(320.0)
        .p(theme.spacing().space_4)
        .rounded(theme.radii().radius_lg)
        .bg(bg_color.with_alpha(0.15))
        .border(1.0, bg_color.with_alpha(0.3))
        .shadow_md()
        .on_state(move |state, div| {
            let theme = ThemeState::get();
            let base = theme.color(variant);

            match state {
                ButtonState::Hovered =&gt; {
                    div.set_bg(base.with_alpha(0.2));
                }
                _ =&gt; {
                    div.set_bg(base.with_alpha(0.15));
                }
            }
        })
        .flex_row()
        .items_center()
        .gap(theme.spacing().space_3)
        .child(
            // Icon placeholder
            div()
                .w(24.0)
                .h(24.0)
                .rounded(theme.radii().radius_full)
                .bg(bg_color)
        )
        .child(
            text(message)
                .size(theme.typography().text_sm)
                .color(theme.color(ColorToken::TextPrimary))
        )
}

// Usage
notification_toast(ctx, "File saved successfully", ColorToken::Success)
notification_toast(ctx, "Network error occurred", ColorToken::Error)
notification_toast(ctx, "New update available", ColorToken::Info)
<span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="event-handling-1"><a class="header" href="#event-handling-1">Event Handling</a></h1>
<p>Junita provides event handling through closures attached to elements. Events bubble up from child to parent elements.</p>
<h2 id="available-events"><a class="header" href="#available-events">Available Events</a></h2>
<h3 id="pointer-events"><a class="header" href="#pointer-events">Pointer Events</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>div()
    .on_click(|ctx| {
        println!("Clicked at ({}, {})", ctx.local_x, ctx.local_y);
    })
    .on_mouse_down(|ctx| {
        println!("Mouse button pressed");
    })
    .on_mouse_up(|ctx| {
        println!("Mouse button released");
    })
<span class="boring">}</span></code></pre>
<h3 id="hover-events"><a class="header" href="#hover-events">Hover Events</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>div()
    .on_hover_enter(|ctx| {
        println!("Mouse entered element");
    })
    .on_hover_leave(|ctx| {
        println!("Mouse left element");
    })
<span class="boring">}</span></code></pre>
<h3 id="focus-events"><a class="header" href="#focus-events">Focus Events</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>div()
    .on_focus(|ctx| {
        println!("Element focused");
    })
    .on_blur(|ctx| {
        println!("Element lost focus");
    })
<span class="boring">}</span></code></pre>
<h3 id="keyboard-events"><a class="header" href="#keyboard-events">Keyboard Events</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>div()
    .on_key_down(|ctx| {
        println!("Key pressed: code={}", ctx.key_code);
        if ctx.ctrl &amp;&amp; ctx.key_code == 83 {  // Ctrl+S
            println!("Save shortcut triggered!");
        }
    })
    .on_key_up(|ctx| {
        println!("Key released");
    })
    .on_text_input(|ctx| {
        if let Some(ch) = ctx.key_char {
            println!("Character typed: {}", ch);
        }
    })
<span class="boring">}</span></code></pre>
<h3 id="scroll-events"><a class="header" href="#scroll-events">Scroll Events</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>div()
    .on_scroll(|ctx| {
        println!("Scrolled: dx={}, dy={}", ctx.scroll_delta_x, ctx.scroll_delta_y);
    })
<span class="boring">}</span></code></pre>
<h3 id="drag-events"><a class="header" href="#drag-events">Drag Events</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>div()
    .on_drag(|ctx| {
        println!("Dragging: delta=({}, {})", ctx.drag_delta_x, ctx.drag_delta_y);
    })
    .on_drag_end(|ctx| {
        println!("Drag ended");
    })
<span class="boring">}</span></code></pre>
<h3 id="lifecycle-events"><a class="header" href="#lifecycle-events">Lifecycle Events</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>div()
    .on_mount(|ctx| {
        println!("Element added to tree");
    })
    .on_unmount(|ctx| {
        println!("Element removed from tree");
    })
    .on_resize(|ctx| {
        println!("Element resized");
    })
<span class="boring">}</span></code></pre>
<hr>
<h2 id="eventcontext"><a class="header" href="#eventcontext">EventContext</a></h2>
<p>All event handlers receive an <code>EventContext</code> with information about the event:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct EventContext {
    pub event_type: EventType,       // Type of event
    pub node_id: LayoutNodeId,       // Element that received the event

    // Mouse position (global coordinates)
    pub mouse_x: f32,
    pub mouse_y: f32,

    // Mouse position (relative to element)
    pub local_x: f32,
    pub local_y: f32,

    // Scroll deltas (for SCROLL events)
    pub scroll_delta_x: f32,
    pub scroll_delta_y: f32,

    // Drag deltas (for DRAG events)
    pub drag_delta_x: f32,
    pub drag_delta_y: f32,

    // Keyboard (for KEY_DOWN, KEY_UP, TEXT_INPUT)
    pub key_char: Option&lt;char&gt;,      // Character for TEXT_INPUT
    pub key_code: u32,               // Virtual key code

    // Modifier keys
    pub shift: bool,
    pub ctrl: bool,
    pub alt: bool,
    pub meta: bool,                  // Cmd on macOS, Win on Windows
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="event-patterns"><a class="header" href="#event-patterns">Event Patterns</a></h2>
<h3 id="toggle-on-click"><a class="header" href="#toggle-on-click">Toggle on Click</a></h3>
<p>Use <code>ToggleState</code> for toggle buttons - it handles click transitions automatically:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use junita_layout::stateful::stateful;

fn toggle_button(ctx: &amp;WindowedContext) -&gt; impl ElementBuilder {
    let handle = ctx.use_state(ToggleState::Off);

    stateful(handle)
        .w(100.0)
        .h(40.0)
        .rounded(8.0)
        .flex_center()
        .on_state(|state, div| {
            let bg = match state {
                ToggleState::Off =&gt; Color::rgba(0.3, 0.3, 0.35, 1.0),
                ToggleState::On =&gt; Color::rgba(0.2, 0.8, 0.4, 1.0),
            };
            div.set_bg(bg);
        })
        .on_click(|_| {
            println!("Toggled!");
            // ToggleState transitions automatically on click
        })
        .child(text("Toggle").color(Color::WHITE))
}
<span class="boring">}</span></code></pre>
<h3 id="drag-to-move"><a class="header" href="#drag-to-move">Drag to Move</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use junita_core::JunitaContextState;

fn draggable_box(ctx: &amp;WindowedContext) -&gt; impl ElementBuilder {
    let pos_x = ctx.use_signal(100.0f32);
    let pos_y = ctx.use_signal(100.0f32);

    let x = ctx.get(pos_x).unwrap_or(100.0);
    let y = ctx.get(pos_y).unwrap_or(100.0);

    div()
        .absolute()
        .left(x)
        .top(y)
        .w(80.0)
        .h(80.0)
        .rounded(8.0)
        .bg(Color::rgba(0.4, 0.6, 1.0, 1.0))
        .on_drag(move |evt| {
            // Signal&lt;T&gt; is Copy, so it can be captured directly
            // Use JunitaContextState to update signals from closures
            JunitaContextState::get().update(pos_x, |v| v + evt.drag_delta_x);
            JunitaContextState::get().update(pos_y, |v| v + evt.drag_delta_y);
        })
}
<span class="boring">}</span></code></pre>
<h3 id="keyboard-shortcuts"><a class="header" href="#keyboard-shortcuts">Keyboard Shortcuts</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn keyboard_handler(ctx: &amp;WindowedContext) -&gt; impl ElementBuilder {
    div()
        .w_full()
        .h_full()
        .on_key_down(|evt| {
            // Ctrl+S or Cmd+S to save
            if (evt.ctrl || evt.meta) &amp;&amp; evt.key_code == 83 {
                println!("Save triggered!");
            }
            // Escape to close
            if evt.key_code == 27 {
                println!("Escape pressed!");
            }
        })
}
<span class="boring">}</span></code></pre>
<h3 id="hover-preview"><a class="header" href="#hover-preview">Hover Preview</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use junita_layout::stateful::stateful;

fn hover_card(ctx: &amp;WindowedContext) -&gt; impl ElementBuilder {
    let handle = ctx.use_state(ButtonState::Idle);

    stateful(handle)
        .w(200.0)
        .h(120.0)
        .rounded(12.0)
        .on_state(|state, div| {
            let (bg, scale) = match state {
                ButtonState::Hovered =&gt; (Color::rgba(0.2, 0.2, 0.3, 1.0), 1.02),
                _ =&gt; (Color::rgba(0.15, 0.15, 0.2, 1.0), 1.0),
            };
            div.set_bg(bg);
            div.set_transform(Transform::scale(scale, scale));
        })
        .child(text("Hover me!").color(Color::WHITE))
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="capturing-state-in-closures"><a class="header" href="#capturing-state-in-closures">Capturing State in Closures</a></h2>
<p>Event handlers are <code>Fn</code> closures. <code>Signal&lt;T&gt;</code> is <code>Copy</code>, so signals can be captured directly. Use <code>JunitaContextState</code> to access signal operations from within closures:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use junita_core::JunitaContextState;

fn counter_buttons(ctx: &amp;WindowedContext) -&gt; impl ElementBuilder {
    let count = ctx.use_signal(0i32);

    div()
        .flex_row()
        .gap(16.0)
        .child(
            div()
                .on_click(move |_| {
                    // Signal is Copy - captured directly in the closure
                    JunitaContextState::get().update(count, |v| v - 1);
                })
                .child(text("-"))
        )
        .child(text(&amp;format!("{}", ctx.get(count).unwrap_or(0))))
        .child(
            div()
                .on_click(move |_| {
                    JunitaContextState::get().update(count, |v| v + 1);
                })
                .child(text("+"))
        )
}
<span class="boring">}</span></code></pre>
<h3 id="thread-safety"><a class="header" href="#thread-safety">Thread Safety</a></h3>
<p><code>JunitaContextState</code> is a thread-safe global singleton:</p>
<ul>
<li>It uses <code>Arc&lt;Mutex&lt;...&gt;&gt;</code> for the reactive graph and hook state</li>
<li>All callbacks use <code>RwLock</code> for safe concurrent access</li>
<li><code>JunitaContextState::get()</code> returns <code>&amp;'static JunitaContextState</code></li>
</ul>
<p>This makes it safe to use in event handler closures:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>div()
    .on_click(move |_| {
        // Safe: JunitaContextState is thread-safe
        JunitaContextState::get().update(my_signal, |v| v + 1);
        JunitaContextState::get().set_focus(Some("my-input"));
        JunitaContextState::get().request_rebuild();
    })
<span class="boring">}</span></code></pre>
<p>For shared mutable state, use <code>Arc&lt;Mutex&lt;T&gt;&gt;</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::{Arc, Mutex};

fn shared_state_example() -&gt; impl ElementBuilder {
    let data = Arc::new(Mutex::new(Vec::&lt;String&gt;::new()));
    let data_click = Arc::clone(&amp;data);

    div()
        .on_click(move |_| {
            data_click.lock().unwrap().push("clicked".to_string());
        })
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="best-practices-2"><a class="header" href="#best-practices-2">Best Practices</a></h2>
<ol>
<li>
<p><strong>Keep handlers lightweight</strong> - Do minimal work in event handlers. For heavy operations, queue work or update state.</p>
</li>
<li>
<p><strong>Use stateful(handle) for hover/press</strong> - Instead of manually tracking hover state, use <code>ctx.use_state()</code> with <code>stateful(handle)</code> which handles state transitions automatically.</p>
</li>
<li>
<p><strong>Clone before closures</strong> - Clone <code>Arc</code>, signals, or context references before moving them into closures.</p>
</li>
<li>
<p><strong>Avoid nested event handlers</strong> - Events bubble up, so you rarely need deeply nested handlers.</p>
</li>
<li>
<p><strong>Use local coordinates</strong> - For hit testing within an element, use <code>ctx.local_x</code> and <code>ctx.local_y</code>.</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="state-management"><a class="header" href="#state-management">State Management</a></h1>
<p>Junita uses <strong>Stateful elements</strong> as the primary way to manage UI state. Stateful elements handle state transitions automatically without rebuilding the entire UI tree.</p>
<h2 id="stateful-elements"><a class="header" href="#stateful-elements">Stateful Elements</a></h2>
<p><code>Stateful</code> is a wrapper element that manages visual states (hover, press, focus, etc.) efficiently. When state changes, only the affected element updates - not the entire UI.</p>
<h3 id="basic-usage-2"><a class="header" href="#basic-usage-2">Basic Usage</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use junita_layout::prelude::*;

fn feature_card(label: &amp;str, accent: Color) -&gt; impl ElementBuilder {
    let label = label.to_string();

    stateful::&lt;ButtonState&gt;()
        .w_fit()
        .p(4.0)
        .rounded(14.0)
        .on_state(move |ctx| {
            let bg = match ctx.state() {
                ButtonState::Idle =&gt; accent,
                ButtonState::Hovered =&gt; Color::rgba(
                    (accent.r * 1.15).min(1.0),
                    (accent.g * 1.15).min(1.0),
                    (accent.b * 1.15).min(1.0),
                    accent.a,
                ),
                ButtonState::Pressed =&gt; Color::rgba(
                    accent.r * 0.85,
                    accent.g * 0.85,
                    accent.b * 0.85,
                    accent.a,
                ),
                ButtonState::Disabled =&gt; Color::GRAY,
            };

            div()
                .bg(bg)
                .on_click({
                    let label = label.clone();
                    move |_| println!("'{}' clicked!", label)
                })
                .child(text(&amp;label).color(Color::WHITE))
        })
}
<span class="boring">}</span></code></pre>
<h3 id="how-it-works-2"><a class="header" href="#how-it-works-2">How It Works</a></h3>
<ol>
<li><code>stateful::&lt;S&gt;()</code> creates a StatefulBuilder for state type S</li>
<li><code>.on_state(|ctx| ...)</code> defines the callback that receives a <code>StateContext</code></li>
<li>Events (hover, click, etc.) trigger automatic state transitions</li>
<li><code>ctx.state()</code> returns the current state for pattern matching</li>
<li>Return a <code>Div</code> from the callback - it’s merged onto the container</li>
</ol>
<hr>
<h2 id="statecontext"><a class="header" href="#statecontext">StateContext</a></h2>
<p>The <code>StateContext</code> provides access to state and scoped utilities within your callback:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>stateful::&lt;ButtonState&gt;()
    .on_state(|ctx| {
        // Get current state
        let state = ctx.state();

        // Create scoped signals (persist across rebuilds)
        let counter = ctx.use_signal("counter", || 0);

        // Create scoped animated values
        let opacity = ctx.use_animated_value("opacity", 1.0);

        // Access dependency values
        let value: i32 = ctx.dep(0).unwrap_or_default();

        // Dispatch events to trigger state transitions
        // ctx.dispatch(CUSTOM_EVENT);

        div().bg(color_for_state(state))
    })
<span class="boring">}</span></code></pre>
<h3 id="statecontext-methods"><a class="header" href="#statecontext-methods">StateContext Methods</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Method</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>ctx.state()</code></td><td>Get the current state value</td></tr>
<tr><td><code>ctx.event()</code></td><td>Get the event that triggered this callback (if any)</td></tr>
<tr><td><code>ctx.use_signal(name, init)</code></td><td>Create/retrieve a scoped signal</td></tr>
<tr><td><code>ctx.use_spring(name, target, config)</code></td><td>Declarative spring animation (recommended)</td></tr>
<tr><td><code>ctx.spring(name, target)</code></td><td>Declarative spring with default stiff config</td></tr>
<tr><td><code>ctx.use_animated_value(name, initial)</code></td><td>Low-level animated value handle</td></tr>
<tr><td><code>ctx.use_timeline(name)</code></td><td>Create/retrieve an animated timeline</td></tr>
<tr><td><code>ctx.dep::&lt;T&gt;(index)</code></td><td>Get dependency value by index</td></tr>
<tr><td><code>ctx.dep_as_state::&lt;T&gt;(index)</code></td><td>Get dependency as State<t> handle</t></td></tr>
<tr><td><code>ctx.dispatch(event)</code></td><td>Trigger a state transition</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="event-access"><a class="header" href="#event-access">Event Access</a></h2>
<p>Use <code>ctx.event()</code> to access the event that triggered the callback:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use junita_core::events::event_types::*;

stateful::&lt;ButtonState&gt;()
    .on_state(|ctx| {
        // ctx.event() returns Some(EventContext) when triggered by user event
        // Returns None when triggered by dependency changes
        if let Some(event) = ctx.event() {
            match event.event_type {
                POINTER_UP =&gt; {
                    println!("Clicked at ({}, {})", event.local_x, event.local_y);
                }
                POINTER_ENTER =&gt; {
                    println!("Mouse entered!");
                }
                KEY_DOWN =&gt; {
                    if event.ctrl &amp;&amp; event.key_code == 83 {  // Ctrl+S
                        println!("Save shortcut pressed!");
                    }
                }
                _ =&gt; {}
            }
        }

        let bg = match ctx.state() {
            ButtonState::Idle =&gt; Color::BLUE,
            ButtonState::Hovered =&gt; Color::CYAN,
            ButtonState::Pressed =&gt; Color::DARK_BLUE,
            _ =&gt; Color::GRAY,
        };

        div().bg(bg)
    })
<span class="boring">}</span></code></pre>
<h3 id="eventcontext-fields"><a class="header" href="#eventcontext-fields">EventContext Fields</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Field</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>event_type</code></td><td><code>u32</code></td><td>Event type (POINTER_UP, POINTER_ENTER, etc.)</td></tr>
<tr><td><code>node_id</code></td><td><code>LayoutNodeId</code></td><td>The node that received the event</td></tr>
<tr><td><code>mouse_x</code>, <code>mouse_y</code></td><td><code>f32</code></td><td>Absolute mouse position</td></tr>
<tr><td><code>local_x</code>, <code>local_y</code></td><td><code>f32</code></td><td>Position relative to element bounds</td></tr>
<tr><td><code>bounds_x</code>, <code>bounds_y</code></td><td><code>f32</code></td><td>Element position (top-left corner)</td></tr>
<tr><td><code>bounds_width</code>, <code>bounds_height</code></td><td><code>f32</code></td><td>Element dimensions</td></tr>
<tr><td><code>scroll_delta_x</code>, <code>scroll_delta_y</code></td><td><code>f32</code></td><td>Scroll delta (for SCROLL events)</td></tr>
<tr><td><code>drag_delta_x</code>, <code>drag_delta_y</code></td><td><code>f32</code></td><td>Drag offset (for DRAG events)</td></tr>
<tr><td><code>key_char</code></td><td><code>Option&lt;char&gt;</code></td><td>Character (for TEXT_INPUT events)</td></tr>
<tr><td><code>key_code</code></td><td><code>u32</code></td><td>Key code (for KEY_DOWN/KEY_UP events)</td></tr>
<tr><td><code>shift</code>, <code>ctrl</code>, <code>alt</code>, <code>meta</code></td><td><code>bool</code></td><td>Modifier key states</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="setting-initial-state"><a class="header" href="#setting-initial-state">Setting Initial State</a></h2>
<p>Use <code>.initial()</code> to set the initial state:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>stateful::&lt;ButtonState&gt;()
    .initial(if disabled { ButtonState::Disabled } else { ButtonState::Idle })
    .on_state(|ctx| {
        // ...
        div()
    })
<span class="boring">}</span></code></pre>
<hr>
<h2 id="signal-dependencies-with-deps"><a class="header" href="#signal-dependencies-with-deps">Signal Dependencies with <code>.deps()</code></a></h2>
<p>When a Stateful element needs to react to external signal changes (not just hover/press events), use <code>.deps()</code> to declare dependencies:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn direction_toggle() -&gt; impl ElementBuilder {
    // External state that affects the element's appearance
    let direction = use_state_keyed("direction", || Direction::Horizontal);

    stateful::&lt;ButtonState&gt;()
        .w(120.0)
        .h(40.0)
        .rounded(8.0)
        // Declare dependency - on_state re-runs when this signal changes
        .deps([direction.signal_id()])
        .on_state(move |ctx| {
            // Read the current direction value
            let dir = direction.get();
            let label = match dir {
                Direction::Horizontal =&gt; "Horizontal",
                Direction::Vertical =&gt; "Vertical",
            };

            let bg = match ctx.state() {
                ButtonState::Idle =&gt; Color::rgba(0.3, 0.5, 0.9, 1.0),
                ButtonState::Hovered =&gt; Color::rgba(0.4, 0.6, 1.0, 1.0),
                _ =&gt; Color::rgba(0.3, 0.5, 0.9, 1.0),
            };

            div()
                .bg(bg)
                .on_click(move |_| {
                    // Toggle direction
                    direction.update(|d| match d {
                        Direction::Horizontal =&gt; Direction::Vertical,
                        Direction::Vertical =&gt; Direction::Horizontal,
                    });
                })
                .child(text(label).color(Color::WHITE))
        })
}
<span class="boring">}</span></code></pre>
<h3 id="accessing-dependencies-via-statecontext"><a class="header" href="#accessing-dependencies-via-statecontext">Accessing Dependencies via StateContext</a></h3>
<p>You can access dependency values directly from the context using <code>ctx.dep()</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let count_signal: State&lt;i32&gt; = use_state(|| 0);
let name_signal: State&lt;String&gt; = use_state(|| "".to_string());

stateful::&lt;ButtonState&gt;()
    .deps([count_signal.signal_id(), name_signal.signal_id()])
    .on_state(|ctx| {
        // Access by index (matches order in .deps())
        let count: i32 = ctx.dep(0).unwrap_or_default();
        let name: String = ctx.dep(1).unwrap_or_default();

        // Or get a full State&lt;T&gt; handle for reading and writing
        if let Some(count_state) = ctx.dep_as_state::&lt;i32&gt;(0) {
            let value = count_state.get();
            // count_state.set(value + 1);
        }

        div().child(text(&amp;format!("{}: {}", name, count)))
    })
<span class="boring">}</span></code></pre>
<h3 id="when-to-use-deps"><a class="header" href="#when-to-use-deps">When to Use <code>.deps()</code></a></h3>
<p>Use <code>.deps()</code> when your <code>on_state</code> callback reads values from signals that can change independently of the element’s internal state transitions.</p>
<p>Without <code>.deps()</code>, the <code>on_state</code> callback only runs when:</p>
<ul>
<li>The element’s state changes (Idle → Hovered, etc.)</li>
</ul>
<p>With <code>.deps()</code>, it also runs when:</p>
<ul>
<li>Any of the declared signal dependencies change</li>
</ul>
<hr>
<h2 id="scoped-signals"><a class="header" href="#scoped-signals">Scoped Signals</a></h2>
<p>Use <code>ctx.use_signal()</code> for state that’s scoped to the stateful container:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>stateful::&lt;ButtonState&gt;()
    .on_state(|ctx| {
        // This signal is keyed to this specific stateful container
        // Format: "{stateful_key}:signal:click_count"
        let click_count = ctx.use_signal("click_count", || 0);

        div()
            .child(text(&amp;format!("Clicks: {}", click_count.get())))
            .on_click(move |_| {
                click_count.update(|n| n + 1);
            })
    })
<span class="boring">}</span></code></pre>
<hr>
<h2 id="animated-values"><a class="header" href="#animated-values">Animated Values</a></h2>
<h3 id="declarative-api-recommended"><a class="header" href="#declarative-api-recommended">Declarative API (Recommended)</a></h3>
<p>Use <code>ctx.use_spring()</code> for declarative spring animations - specify the target and get the current animated value:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>stateful::&lt;ButtonState&gt;()
    .on_state(|ctx| {
        // Declarative: specify target, get current value
        let target_scale = match ctx.state() {
            ButtonState::Hovered =&gt; 1.1,
            _ =&gt; 1.0,
        };
        let current_scale = ctx.use_spring("scale", target_scale, SpringConfig::wobbly());

        // For default stiff spring, use ctx.spring()
        let opacity = ctx.spring("opacity", if ctx.state() == ButtonState::Idle { 0.8 } else { 1.0 });

        div()
            .transform(Transform::scale(current_scale, current_scale))
            .opacity(opacity)
    })
<span class="boring">}</span></code></pre>
<h3 id="low-level-api"><a class="header" href="#low-level-api">Low-Level API</a></h3>
<p>For more control, use <code>ctx.use_animated_value()</code> which returns a <code>SharedAnimatedValue</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>stateful::&lt;ButtonState&gt;()
    .on_state(|ctx| {
        // Get the animated value handle
        let scale = ctx.use_animated_value("scale", 1.0);

        // With custom spring config
        let opacity = ctx.use_animated_value_with_config(
            "opacity",
            1.0,
            SpringConfig::bouncy(),
        );

        // Manually set target and get value
        match ctx.state() {
            ButtonState::Hovered =&gt; {
                scale.lock().unwrap().set_target(1.1);
            }
            _ =&gt; {
                scale.lock().unwrap().set_target(1.0);
            }
        }

        let current_scale = scale.lock().unwrap().get();
        div().transform(Transform::scale(current_scale, current_scale))
    })
<span class="boring">}</span></code></pre>
<hr>
<h2 id="animated-timelines"><a class="header" href="#animated-timelines">Animated Timelines</a></h2>
<p>Use <code>ctx.use_timeline()</code> for complex multi-property animations with keyframes:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>stateful::&lt;ButtonState&gt;()
    .on_state(|ctx| {
        // Persisted timeline scoped to this stateful
        let timeline = ctx.use_timeline("pulse");

        // Configure on first use, get existing entry IDs on subsequent calls
        let opacity_id = timeline.lock().unwrap().configure(|t| {
            let id = t.add(0, 1000, 0.5, 1.0);  // 0ms offset, 1000ms duration
            t.set_loop(-1);  // Loop forever
            t.start();
            id
        });

        let opacity = timeline.lock().unwrap().get(opacity_id);
        div().opacity(opacity)
    })
<span class="boring">}</span></code></pre>
<p>The <code>configure()</code> method is idempotent - it only runs the configuration closure on the first call and returns existing entry IDs on subsequent calls.</p>
<hr>
<h2 id="built-in-state-types"><a class="header" href="#built-in-state-types">Built-in State Types</a></h2>
<p>Junita provides common state types with automatic transitions:</p>
<h3 id="buttonstate"><a class="header" href="#buttonstate">ButtonState</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>ButtonState::Idle      // Default state
ButtonState::Hovered   // Mouse over element
ButtonState::Pressed   // Mouse button down
ButtonState::Disabled  // Non-interactive
<span class="boring">}</span></code></pre>
<p>Transitions:</p>
<ul>
<li><code>Idle</code> → <code>Hovered</code> (on pointer enter)</li>
<li><code>Hovered</code> → <code>Idle</code> (on pointer leave)</li>
<li><code>Hovered</code> → <code>Pressed</code> (on pointer down)</li>
<li><code>Pressed</code> → <code>Hovered</code> (on pointer up)</li>
</ul>
<h3 id="nostate"><a class="header" href="#nostate">NoState</a></h3>
<p>For containers that only need dependency tracking without state transitions:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>stateful::&lt;NoState&gt;()
    .deps([some_signal.signal_id()])
    .on_state(|_ctx| {
        // Rebuilds when dependencies change
        div().child(text("Content"))
    })
<span class="boring">}</span></code></pre>
<hr>
<h2 id="custom-state-types"><a class="header" href="#custom-state-types">Custom State Types</a></h2>
<p>Define your own state enum for complex interactions:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use junita_layout::stateful::StateTransitions;
use junita_core::events::event_types::*;

#[derive(Clone, Copy, PartialEq, Eq, Hash, Default)]
enum DragState {
    #[default]
    Idle,
    Hovering,
    Dragging,
}

impl StateTransitions for DragState {
    fn on_event(&amp;self, event: u32) -&gt; Option&lt;Self&gt; {
        match (self, event) {
            (DragState::Idle, POINTER_ENTER) =&gt; Some(DragState::Hovering),
            (DragState::Hovering, POINTER_LEAVE) =&gt; Some(DragState::Idle),
            (DragState::Hovering, POINTER_DOWN) =&gt; Some(DragState::Dragging),
            (DragState::Dragging, POINTER_UP) =&gt; Some(DragState::Idle),
            _ =&gt; None,
        }
    }
}

fn draggable_item() -&gt; impl ElementBuilder {
    stateful::&lt;DragState&gt;()
        .w(100.0)
        .h(100.0)
        .rounded(8.0)
        .on_state(|ctx| {
            let bg = match ctx.state() {
                DragState::Idle =&gt; Color::BLUE,
                DragState::Hovering =&gt; Color::CYAN,
                DragState::Dragging =&gt; Color::GREEN,
            };
            div().bg(bg)
        })
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="keyed-state-global-signals"><a class="header" href="#keyed-state-global-signals">Keyed State (Global Signals)</a></h2>
<p>For state persisted across UI rebuilds with a string key:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let is_expanded = use_state_keyed("sidebar_expanded", || false);

// Read
let expanded = is_expanded.get();

// Update
is_expanded.set(true);
is_expanded.update(|v| !v);

// Get signal ID for use with .deps()
let signal_id = is_expanded.signal_id();
<span class="boring">}</span></code></pre>
<hr>
<h2 id="best-practices-3"><a class="header" href="#best-practices-3">Best Practices</a></h2>
<ol>
<li>
<p><strong>Use <code>stateful::&lt;S&gt;()</code> builder</strong> - This is the primary pattern for stateful UI elements.</p>
</li>
<li>
<p><strong>Return Div from callbacks</strong> - The new API expects you to return a Div, not mutate a container.</p>
</li>
<li>
<p><strong>Use <code>.initial()</code> for non-default states</strong> - Set initial state explicitly when needed.</p>
</li>
<li>
<p><strong>Use <code>ctx.use_signal()</code> for local state</strong> - Scoped signals are automatically keyed.</p>
</li>
<li>
<p><strong>Use <code>ctx.dep()</code> for dependency access</strong> - Cleaner than capturing signals in closures.</p>
</li>
<li>
<p><strong>Prefer built-in state types</strong> - They have correct transitions already defined.</p>
</li>
<li>
<p><strong>Custom states for complex flows</strong> - Define your own when built-in types don’t fit.</p>
</li>
<li>
<p><strong>Use <code>.deps()</code> for external dependencies</strong> - When <code>on_state</code> needs to react to signal changes.</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="spring-physics"><a class="header" href="#spring-physics">Spring Physics</a></h1>
<p>Junita uses spring physics for natural, responsive animations. Springs provide smooth motion that feels organic compared to fixed-duration easing.</p>
<h2 id="springconfig"><a class="header" href="#springconfig">SpringConfig</a></h2>
<p>All spring animations are configured with <code>SpringConfig</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use junita_animation::SpringConfig;

// Custom spring
let config = SpringConfig {
    stiffness: 180.0,    // How "tight" the spring is
    damping: 12.0,       // How quickly oscillation settles
    mass: 1.0,           // Virtual mass of the object
    ..Default::default()
};
<span class="boring">}</span></code></pre>
<h3 id="presets"><a class="header" href="#presets">Presets</a></h3>
<p>Junita provides common spring presets:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>SpringConfig::stiff()    // Fast, minimal overshoot (stiffness: 400, damping: 30)
SpringConfig::snappy()   // Quick with slight bounce (stiffness: 300, damping: 20)
SpringConfig::gentle()   // Soft, slower motion (stiffness: 120, damping: 14)
SpringConfig::wobbly()   // Bouncy, playful (stiffness: 180, damping: 12)
<span class="boring">}</span></code></pre>
<h3 id="choosing-a-spring"><a class="header" href="#choosing-a-spring">Choosing a Spring</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Use Case</th><th>Preset</th><th>Feel</th></tr>
</thead>
<tbody>
<tr><td>Button press feedback</td><td><code>stiff()</code></td><td>Immediate, snappy</td></tr>
<tr><td>Menu/panel transitions</td><td><code>snappy()</code></td><td>Quick with character</td></tr>
<tr><td>Drag release</td><td><code>gentle()</code></td><td>Smooth, natural</td></tr>
<tr><td>Playful interactions</td><td><code>wobbly()</code></td><td>Fun, bouncy</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="animatedvalue"><a class="header" href="#animatedvalue">AnimatedValue</a></h2>
<p><code>AnimatedValue</code> wraps a single f32 value with spring physics:</p>
<h3 id="creating-animatedvalues"><a class="header" href="#creating-animatedvalues">Creating AnimatedValues</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn my_component(ctx: &amp;WindowedContext) -&gt; impl ElementBuilder {
    // Create a persisted animated value
    let scale = ctx.use_animated_value(1.0, SpringConfig::snappy());

    // With a custom key
    let x_pos = ctx.use_animated_value_for("card_x", 0.0, SpringConfig::gentle());

    // ...
}
<span class="boring">}</span></code></pre>
<h3 id="reading-values"><a class="header" href="#reading-values">Reading Values</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Get current animated value
let current = scale.lock().unwrap().get();

// Use in transforms
div().scale(current)
<span class="boring">}</span></code></pre>
<h3 id="setting-targets"><a class="header" href="#setting-targets">Setting Targets</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Animate to new target
scale.lock().unwrap().set_target(1.2);

// Immediate set (no animation)
scale.lock().unwrap().set(1.0);
<span class="boring">}</span></code></pre>
<h3 id="example-hover-scale-with-spring-animation"><a class="header" href="#example-hover-scale-with-spring-animation">Example: Hover Scale with Spring Animation</a></h3>
<p>For smooth spring-animated hover effects, use <code>motion()</code> with animated values:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::Arc;
use junita_layout::motion::motion;

fn hover_scale_card(ctx: &amp;WindowedContext) -&gt; impl ElementBuilder {
    let scale = ctx.use_animated_value(1.0, SpringConfig::snappy());

    let hover_scale = Arc::clone(&amp;scale);
    let leave_scale = Arc::clone(&amp;scale);

    // motion() is a container - apply transforms to it, style the child
    motion()
        .scale(scale.lock().unwrap().get())
        .on_hover_enter(move |_| {
            hover_scale.lock().unwrap().set_target(1.05);
        })
        .on_hover_leave(move |_| {
            leave_scale.lock().unwrap().set_target(1.0);
        })
        .child(
            div()
                .w(200.0)
                .h(120.0)
                .rounded(12.0)
                .bg(Color::rgba(0.2, 0.2, 0.3, 1.0))
                .flex_center()
                .child(text("Hover me").color(Color::WHITE))
        )
}
<span class="boring">}</span></code></pre>
<p><strong>Note:</strong> For simple hover state changes without spring physics (e.g., just color changes), prefer <code>stateful(handle)</code> which is more efficient. Use <code>motion()</code> when you specifically need spring-animated values.</p>
<h3 id="example-drag-position"><a class="header" href="#example-drag-position">Example: Drag Position</a></h3>
<p>Use <code>motion()</code> for elements with animated position:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use junita_layout::motion::motion;

fn draggable_element(ctx: &amp;WindowedContext) -&gt; impl ElementBuilder {
    let x = ctx.use_animated_value(100.0, SpringConfig::wobbly());
    let y = ctx.use_animated_value(100.0, SpringConfig::wobbly());

    let drag_x = Arc::clone(&amp;x);
    let drag_y = Arc::clone(&amp;y);

    // motion() handles the animated position, child has the styling
    motion()
        .absolute()
        .left(x.lock().unwrap().get())
        .top(y.lock().unwrap().get())
        .on_drag(move |evt| {
            let mut x = drag_x.lock().unwrap();
            let mut y = drag_y.lock().unwrap();
            x.set_target(x.target() + evt.drag_delta_x);
            y.set_target(y.target() + evt.drag_delta_y);
        })
        .child(
            div()
                .w(80.0)
                .h(80.0)
                .rounded(8.0)
                .bg(Color::rgba(0.4, 0.6, 1.0, 1.0))
        )
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="motion-containers"><a class="header" href="#motion-containers">Motion Containers</a></h2>
<p>For declarative enter/exit animations, use <code>motion()</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use junita_layout::motion::motion;

motion()
    .fade_in(300)      // Fade in over 300ms
    .child(my_content())

motion()
    .scale_in(300)     // Scale from 0 to 1
    .child(my_content())

motion()
    .slide_in(SlideDirection::Left, 300)
    .child(my_content())
<span class="boring">}</span></code></pre>
<p>See <a href="#motion-containers-1">Motion Containers</a> for full details.</p>
<hr>
<h2 id="best-practices-4"><a class="header" href="#best-practices-4">Best Practices</a></h2>
<ol>
<li>
<p><strong>Match spring to interaction</strong> - Use stiffer springs for immediate feedback, gentler for ambient motion.</p>
</li>
<li>
<p><strong>Persist animated values</strong> - Use <code>ctx.use_animated_value()</code> so animations survive UI rebuilds.</p>
</li>
<li>
<p><strong>Clone Arc before closures</strong> - Always <code>Arc::clone()</code> before moving into event handlers.</p>
</li>
<li>
<p><strong>Don’t fight the spring</strong> - Let animations complete naturally. Interrupting with new targets is fine.</p>
</li>
<li>
<p><strong>Use JunitaComponent</strong> - For complex components with multiple animations, use the derive macro for type-safe hooks.</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="keyframe-timelines"><a class="header" href="#keyframe-timelines">Keyframe Timelines</a></h1>
<p>For time-based animations with precise control, use <code>AnimatedTimeline</code>. Timelines support multiple animation entries, looping, alternate (ping-pong) mode, and coordinated playback.</p>
<h2 id="creating-timelines"><a class="header" href="#creating-timelines">Creating Timelines</a></h2>
<h3 id="in-windowedcontext"><a class="header" href="#in-windowedcontext">In WindowedContext</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn my_component(ctx: &amp;WindowedContext) -&gt; impl ElementBuilder {
    // Create a persisted timeline
    let timeline = ctx.use_animated_timeline();

    // With a custom key
    let loader_timeline = ctx.use_animated_timeline_for("loader");

    // ...
}
<span class="boring">}</span></code></pre>
<h3 id="in-statecontext-stateful-elements"><a class="header" href="#in-statecontext-stateful-elements">In StateContext (Stateful Elements)</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>stateful::&lt;ButtonState&gt;().on_state(|ctx| {
    // use_timeline returns (entry_ids, TimelineHandle)
    let ((entry1, entry2), timeline) = ctx.use_timeline("fade", |t| {
        let e1 = t.add(0, 500, 0.0, 1.0);
        let e2 = t.add(250, 500, 0.0, 100.0);
        t.set_loop(-1);
        t.start();
        (e1, e2)
    });

    let value1 = timeline.get(entry1).unwrap_or(0.0);
    let value2 = timeline.get(entry2).unwrap_or(0.0);

    div()
})
<span class="boring">}</span></code></pre>
<h2 id="configuring-timelines"><a class="header" href="#configuring-timelines">Configuring Timelines</a></h2>
<p>Use the <code>configure()</code> method to set up animations once:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let timeline = ctx.use_animated_timeline();

// Configure returns entry IDs for accessing values later
let entry_id = timeline.lock().unwrap().configure(|t| {
    let id = t.add(0, 1000, 0.0, 360.0);  // 0ms start, 1000ms duration, 0° to 360°
    t.set_loop(-1);  // Loop forever (-1 = infinite)
    t.start();
    id
});
<span class="boring">}</span></code></pre>
<p>The closure only runs on first call. Subsequent calls return existing entry IDs.</p>
<h2 id="adding-animations"><a class="header" href="#adding-animations">Adding Animations</a></h2>
<h3 id="basic-entry"><a class="header" href="#basic-entry">Basic Entry</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>timeline.lock().unwrap().configure(|t| {
    // add(offset_ms, duration_ms, start_value, end_value)
    let rotation = t.add(0, 1000, 0.0, 360.0);
    let scale = t.add(0, 500, 1.0, 1.5);       // Same start, shorter duration
    let opacity = t.add(500, 500, 1.0, 0.0);   // Starts at 500ms

    (rotation, scale, opacity)  // Return tuple of IDs
});
<span class="boring">}</span></code></pre>
<h3 id="with-easing"><a class="header" href="#with-easing">With Easing</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use junita_animation::Easing;

timeline.lock().unwrap().configure(|t| {
    // add_with_easing(offset_ms, duration_ms, start, end, easing)
    let smooth = t.add_with_easing(0, 500, 0.0, 60.0, Easing::EaseInOut);
    let bouncy = t.add_with_easing(0, 500, 0.0, 1.0, Easing::EaseOutQuad);

    (smooth, bouncy)
});
<span class="boring">}</span></code></pre>
<h3 id="using-staggerbuilder"><a class="header" href="#using-staggerbuilder">Using StaggerBuilder</a></h3>
<p>For multiple entries with automatic offset calculation:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>timeline.lock().unwrap().configure(|t| {
    // stagger(base_offset, stagger_amount)
    let mut stagger = t.stagger(0, 100);  // 0ms base, 100ms between each

    let bar1 = stagger.add(500, 0.0, 60.0);  // offset: 0ms
    let bar2 = stagger.add(500, 0.0, 60.0);  // offset: 100ms
    let bar3 = stagger.add(500, 0.0, 60.0);  // offset: 200ms

    // With easing
    let bar4 = stagger.add_with_easing(500, 0.0, 60.0, Easing::EaseInOut);

    (bar1, bar2, bar3, bar4)
});
<span class="boring">}</span></code></pre>
<h2 id="reading-values-1"><a class="header" href="#reading-values-1">Reading Values</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let value = timeline.lock().unwrap().get(entry_id).unwrap_or(0.0);

// Get entry progress (0.0 to 1.0)
let progress = timeline.lock().unwrap().entry_progress(entry_id);

// Get overall timeline progress
let total_progress = timeline.lock().unwrap().progress();
<span class="boring">}</span></code></pre>
<h2 id="playback-control"><a class="header" href="#playback-control">Playback Control</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut t = timeline.lock().unwrap();

t.start();              // Start playing
t.pause();              // Pause (can resume)
t.resume();             // Resume from pause
t.stop();               // Stop and reset
t.restart();            // Start from beginning
t.reverse();            // Toggle playback direction
t.seek(500.0);          // Jump to 500ms position

t.set_loop(3);          // Loop 3 times
t.set_loop(-1);         // Loop forever
t.set_alternate(true);  // Ping-pong mode
t.set_playback_rate(2.0); // 2x speed

t.is_playing();         // Check if playing
t.progress();           // Overall progress (0.0 to 1.0)
<span class="boring">}</span></code></pre>
<hr>
<h2 id="alternate-ping-pong-mode"><a class="header" href="#alternate-ping-pong-mode">Alternate (Ping-Pong) Mode</a></h2>
<p>Enable <code>alternate</code> mode for back-and-forth animations that maintain stagger across loops:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let ((bar1, bar2, bar3), timeline) = ctx.use_timeline("bars", |t| {
    // Three staggered entries
    let b1 = t.add_with_easing(0, 500, 0.0, 60.0, Easing::EaseInOut);
    let b2 = t.add_with_easing(100, 500, 0.0, 60.0, Easing::EaseInOut);
    let b3 = t.add_with_easing(200, 500, 0.0, 60.0, Easing::EaseInOut);

    t.set_alternate(true);  // Reverse on each loop
    t.set_loop(-1);         // Loop forever
    t.start();

    (b1, b2, b3)
});
<span class="boring">}</span></code></pre>
<p>With alternate mode:</p>
<ul>
<li>Timeline plays forward (0 → duration)</li>
<li>On completion, reverses direction (duration → 0)</li>
<li>Stagger offsets maintain their relative timing</li>
<li>No jump back to start - smooth continuous motion</li>
</ul>
<hr>
<h2 id="example-staggered-wave-animation"><a class="header" href="#example-staggered-wave-animation">Example: Staggered Wave Animation</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn sliding_bars() -&gt; impl ElementBuilder {
    stateful::&lt;NoState&gt;().on_state(|ctx| {
        let ((bar1_id, bar2_id, bar3_id), timeline) = ctx.use_timeline("bars", |t| {
            // Staggered entries with easing
            let bar1 = t.add_with_easing(0, 500, 0.0, 60.0, Easing::EaseInOut);
            let bar2 = t.add_with_easing(100, 500, 0.0, 60.0, Easing::EaseInOut);
            let bar3 = t.add_with_easing(200, 500, 0.0, 60.0, Easing::EaseInOut);

            t.set_alternate(true);
            t.set_loop(-1);
            t.start();

            (bar1, bar2, bar3)
        });

        let bar1_x = timeline.get(bar1_id).unwrap_or(0.0);
        let bar2_x = timeline.get(bar2_id).unwrap_or(0.0);
        let bar3_x = timeline.get(bar3_id).unwrap_or(0.0);

        div()
            .flex_col()
            .gap(12.0)
            .child(div().w(30.0).h(12.0).bg(Color::GREEN)
                .transform(Transform::translate(bar1_x, 0.0)))
            .child(div().w(30.0).h(12.0).bg(Color::YELLOW)
                .transform(Transform::translate(bar2_x, 0.0)))
            .child(div().w(30.0).h(12.0).bg(Color::RED)
                .transform(Transform::translate(bar3_x, 0.0)))
    })
}
<span class="boring">}</span></code></pre>
<h2 id="example-spinning-loader"><a class="header" href="#example-spinning-loader">Example: Spinning Loader</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::f32::consts::PI;

fn spinning_loader(ctx: &amp;WindowedContext) -&gt; impl ElementBuilder {
    let timeline = ctx.use_animated_timeline();

    let entry_id = timeline.lock().unwrap().configure(|t| {
        let id = t.add(0, 1000, 0.0, 360.0);
        t.set_loop(-1);
        t.start();
        id
    });

    let render_timeline = Arc::clone(&amp;timeline);

    canvas(move |draw_ctx, bounds| {
        let angle_deg = render_timeline.lock().unwrap().get(entry_id).unwrap_or(0.0);
        let angle_rad = angle_deg * PI / 180.0;

        let cx = bounds.width / 2.0;
        let cy = bounds.height / 2.0;
        let radius = 30.0;

        // Draw spinning arc
        // ... drawing code
    })
    .w(80.0)
    .h(80.0)
}
<span class="boring">}</span></code></pre>
<h2 id="example-pulsing-ring"><a class="header" href="#example-pulsing-ring">Example: Pulsing Ring</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn pulsing_ring() -&gt; impl ElementBuilder {
    stateful::&lt;ButtonState&gt;().on_state(|ctx| {
        let is_running = ctx.use_signal("running", || false);

        // Keyframe animations with ping-pong
        let scale = ctx.use_keyframes("scale", |k| {
            k.at(0, 0.8)
             .at(800, 1.2)
             .ease(Easing::EaseInOut)
             .ping_pong()
             .loop_infinite()
        });

        let opacity = ctx.use_keyframes("opacity", |k| {
            k.at(0, 0.4)
             .at(800, 1.0)
             .ease(Easing::EaseInOut)
             .ping_pong()
             .loop_infinite()
        });

        // Toggle on click
        if let Some(event) = ctx.event() {
            if event.event_type == POINTER_UP {
                if is_running.get() {
                    scale.stop();
                    opacity.stop();
                    is_running.set(false);
                } else {
                    scale.start();
                    opacity.start();
                    is_running.set(true);
                }
            }
        }

        let s = scale.get();
        let o = opacity.get();

        div()
            .w(60.0).h(60.0)
            .border(4.0, Color::rgba(1.0, 0.5, 0.3, o))
            .rounded(30.0)
            .transform(Transform::scale(s, s))
    })
}
<span class="boring">}</span></code></pre>
<h2 id="example-progress-bar"><a class="header" href="#example-progress-bar">Example: Progress Bar</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn animated_progress(ctx: &amp;WindowedContext) -&gt; impl ElementBuilder {
    let timeline = ctx.use_animated_timeline();

    let entry_id = timeline.lock().unwrap().configure(|t| {
        let id = t.add(0, 2000, 0.0, 1.0);  // 2 second fill
        t.start();
        id
    });

    let click_timeline = Arc::clone(&amp;timeline);
    let render_timeline = Arc::clone(&amp;timeline);

    div()
        .w(200.0)
        .h(20.0)
        .rounded(10.0)
        .bg(Color::rgba(0.2, 0.2, 0.25, 1.0))
        .on_click(move |_| {
            // Restart on click
            let mut t = click_timeline.lock().unwrap();
            t.stop();
            t.start();
        })
        .child(
            canvas(move |draw_ctx, bounds| {
                let progress = render_timeline.lock().unwrap()
                    .get(entry_id)
                    .unwrap_or(0.0);

                let fill_width = bounds.width * progress;
                draw_ctx.fill_rect(
                    Rect::new(0.0, 0.0, fill_width, bounds.height),
                    CornerRadius::uniform(10.0),
                    Brush::Solid(Color::rgba(0.4, 0.6, 1.0, 1.0)),
                );
            })
            .w_full()
            .h_full()
        )
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="configureresult-types"><a class="header" href="#configureresult-types">ConfigureResult Types</a></h2>
<p>The <code>configure()</code> method supports various return types:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Single entry
let id: TimelineEntryId = t.configure(|t| t.add(...));

// Tuple of entries
let (a, b): (TimelineEntryId, TimelineEntryId) = t.configure(|t| {
    (t.add(...), t.add(...))
});

// Triple
let (a, b, c) = t.configure(|t| {
    (t.add(...), t.add(...), t.add(...))
});

// Vec for dynamic counts
let ids: Vec&lt;TimelineEntryId&gt; = t.configure(|t| {
    (0..5).map(|i| t.add(i * 100, 500, 0.0, 1.0)).collect()
});
<span class="boring">}</span></code></pre>
<hr>
<h2 id="available-easing-functions"><a class="header" href="#available-easing-functions">Available Easing Functions</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use junita_animation::Easing;

Easing::Linear          // No easing
Easing::EaseIn          // Slow start (cubic)
Easing::EaseOut         // Slow end (cubic)
Easing::EaseInOut       // Slow start and end (cubic)
Easing::EaseInQuad      // Quadratic ease in
Easing::EaseOutQuad     // Quadratic ease out
Easing::EaseInOutQuad   // Quadratic ease in-out
Easing::EaseInCubic     // Cubic ease in
Easing::EaseOutCubic    // Cubic ease out
Easing::EaseInOutCubic  // Cubic ease in-out
Easing::EaseInQuart     // Quartic ease in
Easing::EaseOutQuart    // Quartic ease out
Easing::EaseInOutQuart  // Quartic ease in-out
Easing::CubicBezier(x1, y1, x2, y2)  // Custom bezier curve
<span class="boring">}</span></code></pre>
<hr>
<h2 id="timeline-vs-spring"><a class="header" href="#timeline-vs-spring">Timeline vs Spring</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Feature</th><th>Timeline</th><th>Spring</th></tr>
</thead>
<tbody>
<tr><td>Duration</td><td>Fixed</td><td>Physics-based</td></tr>
<tr><td>Looping</td><td>Built-in</td><td>Manual</td></tr>
<tr><td>Multiple values</td><td>Single timeline</td><td>Individual values</td></tr>
<tr><td>Ping-pong</td><td>set_alternate(true)</td><td>Manual reverse</td></tr>
<tr><td>Interruption</td><td>Restart needed</td><td>Natural blend</td></tr>
<tr><td>Use case</td><td>Continuous loops, sequences</td><td>Interactive, responsive</td></tr>
</tbody>
</table>
</div>
<p><strong>Use timelines for:</strong></p>
<ul>
<li>Loading spinners</li>
<li>Background animations</li>
<li>Sequenced animations</li>
<li>Staggered wave effects</li>
<li>Precise timing control</li>
</ul>
<p><strong>Use springs for:</strong></p>
<ul>
<li>User interactions</li>
<li>Drag and drop</li>
<li>Hover effects</li>
<li>Natural motion</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="motion-containers-1"><a class="header" href="#motion-containers-1">Motion Containers</a></h1>
<p>The <code>motion()</code> element provides declarative enter/exit animations for content. It’s ideal for animated lists, page transitions, and conditional rendering.</p>
<h2 id="basic-usage-3"><a class="header" href="#basic-usage-3">Basic Usage</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use junita_layout::motion::motion;

motion()
    .fade_in(300)     // Duration in milliseconds
    .child(my_content())
<span class="boring">}</span></code></pre>
<h2 id="animation-presets"><a class="header" href="#animation-presets">Animation Presets</a></h2>
<h3 id="fade"><a class="header" href="#fade">Fade</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>motion()
    .fade_in(300)
    .fade_out(200)
    .child(content)
<span class="boring">}</span></code></pre>
<h3 id="scale"><a class="header" href="#scale">Scale</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>motion()
    .scale_in(300)    // Scale from 0 to 1
    .scale_out(200)   // Scale from 1 to 0
    .child(content)
<span class="boring">}</span></code></pre>
<h3 id="slide"><a class="header" href="#slide">Slide</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use junita_layout::motion::SlideDirection;

motion()
    .slide_in(SlideDirection::Left, 300)
    .slide_out(SlideDirection::Right, 200)
    .child(content)

// Available directions:
// SlideDirection::Top
// SlideDirection::Bottom
// SlideDirection::Left
// SlideDirection::Right
<span class="boring">}</span></code></pre>
<h3 id="bounce"><a class="header" href="#bounce">Bounce</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>motion()
    .bounce_in(400)   // Bouncy entrance
    .bounce_out(200)
    .child(content)
<span class="boring">}</span></code></pre>
<h3 id="pop"><a class="header" href="#pop">Pop</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>motion()
    .pop_in(300)      // Scale with overshoot
    .pop_out(200)
    .child(content)
<span class="boring">}</span></code></pre>
<hr>
<h2 id="combining-animations"><a class="header" href="#combining-animations">Combining Animations</a></h2>
<p>Apply multiple effects:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>motion()
    .fade_in(300)
    .scale_in(300)
    .child(content)
<span class="boring">}</span></code></pre>
<hr>
<h2 id="staggered-lists"><a class="header" href="#staggered-lists">Staggered Lists</a></h2>
<p>Animate list items with delays between each:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use junita_layout::motion::{motion, StaggerConfig, AnimationPreset};

let items = vec!["Item 1", "Item 2", "Item 3", "Item 4"];

motion()
    .stagger(
        StaggerConfig::new(100, AnimationPreset::fade_in(300))
    )
    .children(
        items.iter().map(|item| {
            div()
                .p(12.0)
                .bg(Color::rgba(0.2, 0.2, 0.25, 1.0))
                .child(text(*item).color(Color::WHITE))
        })
    )
<span class="boring">}</span></code></pre>
<h3 id="stagger-configuration"><a class="header" href="#stagger-configuration">Stagger Configuration</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>StaggerConfig::new(delay_ms, preset)
    .reverse()          // Animate last to first
    .from_center()      // Animate from center outward
    .limit(10)          // Only stagger first N items
<span class="boring">}</span></code></pre>
<h3 id="stagger-directions"><a class="header" href="#stagger-directions">Stagger Directions</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Forward (default): 0, 1, 2, 3, 4...
StaggerConfig::new(100, preset)

// Reverse: 4, 3, 2, 1, 0...
StaggerConfig::new(100, preset).reverse()

// From center: 2, 1/3, 0/4 (for 5 items)
StaggerConfig::new(100, preset).from_center()
<span class="boring">}</span></code></pre>
<hr>
<h2 id="binding-to-animatedvalue"><a class="header" href="#binding-to-animatedvalue">Binding to AnimatedValue</a></h2>
<p>For continuous animation control, bind motion transforms to AnimatedValue:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn pull_to_refresh(ctx: &amp;WindowedContext) -&gt; impl ElementBuilder {
    let offset_y = ctx.use_animated_value(0.0, SpringConfig::wobbly());
    let icon_scale = ctx.use_animated_value(0.5, SpringConfig::snappy());
    let icon_opacity = ctx.use_animated_value(0.0, SpringConfig::snappy());

    stack()
        // Refresh icon (behind content)
        .child(
            motion()
                .scale(icon_scale.clone())
                .opacity(icon_opacity.clone())
                .child(refresh_icon())
        )
        // Content (translates down to reveal icon)
        .child(
            motion()
                .translate_y(offset_y.clone())
                .child(content_list())
        )
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="example-animated-card-list"><a class="header" href="#example-animated-card-list">Example: Animated Card List</a></h2>
<p>Use a stateful element with <code>.deps()</code> to react to visibility state changes:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn animated_card_list(ctx: &amp;WindowedContext) -&gt; impl ElementBuilder {
    let show_cards = ctx.use_state_keyed("show_cards", || true);
    let button_handle = ctx.use_state(ButtonState::Idle);

    stateful(button_handle)
        .flex_col()
        .gap(16.0)
        .deps(&amp;[show_cards.signal_id()])
        .on_state(move |state, container| {
            let visible = show_cards.get();
            let label = if visible { "Hide Cards" } else { "Show Cards" };

            let bg = match state {
                ButtonState::Idle =&gt; Color::rgba(0.3, 0.5, 0.9, 1.0),
                ButtonState::Hovered =&gt; Color::rgba(0.4, 0.6, 1.0, 1.0),
                _ =&gt; Color::rgba(0.3, 0.5, 0.9, 1.0),
            };

            // Build content based on visibility
            let mut content = div()
                .bg(bg)
                .px(16.0)
                .py(8.0)
                .rounded(8.0)
                .child(text(label).color(Color::WHITE));

            container.merge(content);
        })
        .on_click(move |_| {
            show_cards.update(|v| !v);
        })
        .child(card_list(ctx))
}

fn card_list(ctx: &amp;WindowedContext) -&gt; impl ElementBuilder {
    // Cards with staggered animation
    motion()
        .stagger(StaggerConfig::new(80, AnimationPreset::fade_in(300)))
        .children(
            (0..5).map(|i| {
                div()
                    .w(300.0)
                    .p(16.0)
                    .rounded(12.0)
                    .bg(Color::rgba(0.15, 0.15, 0.2, 1.0))
                    .child(text(&amp;format!("Card {}", i + 1)).color(Color::WHITE))
            })
        )
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="example-page-transition"><a class="header" href="#example-page-transition">Example: Page Transition</a></h2>
<p>Use a custom state type for page navigation:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use junita_layout::stateful::{stateful, StateTransitions};

#[derive(Clone, Copy, PartialEq, Eq, Hash)]
enum Page {
    Home,
    Settings,
    Profile,
}

// Pages don't auto-transition - we change them programmatically
impl StateTransitions for Page {
    fn on_event(&amp;self, _event: u32) -&gt; Option&lt;Self&gt; {
        None  // No automatic transitions
    }
}

fn page_transition(ctx: &amp;WindowedContext) -&gt; impl ElementBuilder {
    let page_handle = ctx.use_state(Page::Home);

    stateful(page_handle.clone())
        .w_full()
        .h_full()
        .on_state(move |page, container| {
            // Render different content based on current page
            let content = match page {
                Page::Home =&gt; div().child(text("Home Page").color(Color::WHITE)),
                Page::Settings =&gt; div().child(text("Settings Page").color(Color::WHITE)),
                Page::Profile =&gt; div().child(text("Profile Page").color(Color::WHITE)),
            };

            container.merge(
                div()
                    .child(
                        motion()
                            .fade_in(200)
                            .slide_in(SlideDirection::Right, 200)
                            .child(content)
                    )
            );
        })
}

// Navigate programmatically
fn nav_button(ctx: &amp;WindowedContext, target: Page, label: &amp;str) -&gt; impl ElementBuilder {
    let page_handle = ctx.use_state(Page::Home);  // Same handle
    let handle = ctx.use_state_for(label, ButtonState::Idle);

    stateful(handle)
        .px(16.0)
        .py(8.0)
        .rounded(8.0)
        .on_state(|state, div| {
            let bg = match state {
                ButtonState::Idle =&gt; Color::rgba(0.3, 0.5, 0.9, 1.0),
                ButtonState::Hovered =&gt; Color::rgba(0.4, 0.6, 1.0, 1.0),
                _ =&gt; Color::rgba(0.3, 0.5, 0.9, 1.0),
            };
            div.set_bg(bg);
        })
        .on_click(move |_| {
            page_handle.set(target);
        })
        .child(text(label).color(Color::WHITE))
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="motion-vs-manual-animation"><a class="header" href="#motion-vs-manual-animation">Motion vs Manual Animation</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Feature</th><th>Motion</th><th>AnimatedValue</th></tr>
</thead>
<tbody>
<tr><td>Setup</td><td>Declarative</td><td>Imperative</td></tr>
<tr><td>Control</td><td>Preset-based</td><td>Full control</td></tr>
<tr><td>Enter/Exit</td><td>Built-in</td><td>Manual</td></tr>
<tr><td>Lists</td><td>Stagger support</td><td>Manual delays</td></tr>
<tr><td>Use case</td><td>Transitions</td><td>Interactive</td></tr>
</tbody>
</table>
</div>
<p><strong>Use motion for:</strong></p>
<ul>
<li>List item animations</li>
<li>Page transitions</li>
<li>Conditional content</li>
<li>Staggered reveals</li>
</ul>
<p><strong>Use AnimatedValue for:</strong></p>
<ul>
<li>Drag interactions</li>
<li>Hover effects</li>
<li>Custom physics</li>
<li>Continuous binding</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="junitacomponent-macro"><a class="header" href="#junitacomponent-macro">JunitaComponent Macro</a></h1>
<p>The <code>JunitaComponent</code> derive macro generates type-safe hooks for <strong>state and animations</strong>, eliminating manual string keys and reducing boilerplate. Use it to define component-scoped state that persists across UI rebuilds.</p>
<h2 id="overview-2"><a class="header" href="#overview-2">Overview</a></h2>
<p><code>JunitaComponent</code> is designed for two primary use cases:</p>
<ol>
<li><strong>State Management</strong> - Generate <code>State&lt;T&gt;</code> hooks for component data (counters, toggles, form values)</li>
<li><strong>Animations</strong> - Generate <code>SharedAnimatedValue</code> hooks for spring-based animations</li>
</ol>
<h2 id="basic-usage-4"><a class="header" href="#basic-usage-4">Basic Usage</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use junita_app::prelude::*;

#[derive(JunitaComponent)]
struct MyComponent;
<span class="boring">}</span></code></pre>
<p>This generates:</p>
<ul>
<li><code>MyComponent::COMPONENT_KEY</code> - Unique compile-time key</li>
<li><code>MyComponent::use_animated_value(ctx, initial, config)</code> - Spring animation</li>
<li><code>MyComponent::use_animated_value_with(ctx, suffix, initial, config)</code> - Named spring</li>
<li><code>MyComponent::use_animated_timeline(ctx)</code> - Keyframe timeline</li>
<li><code>MyComponent::use_animated_timeline_with(ctx, suffix)</code> - Named timeline</li>
</ul>
<hr>
<h2 id="state-fields"><a class="header" href="#state-fields">State Fields</a></h2>
<p>Fields without <code>#[animation]</code> generate state hooks:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(JunitaComponent)]
struct Counter {
    count: i32,              // Generates: use_count(ctx, initial) -&gt; State&lt;i32&gt;
    step: i32,               // Generates: use_step(ctx, initial) -&gt; State&lt;i32&gt;
}
<span class="boring">}</span></code></pre>
<h3 id="using-state-fields"><a class="header" href="#using-state-fields">Using State Fields</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn counter_demo(ctx: &amp;WindowedContext) -&gt; impl ElementBuilder {
    // JunitaComponent generates type-safe state hooks
    let count = Counter::use_count(ctx, 0);
    let step = Counter::use_step(ctx, 1);

    // Create persistent button state handle
    let button_handle = ctx.use_state(ButtonState::Idle);

    // Use stateful(handle) with .deps() to react to state changes
    stateful(button_handle)
        .flex_col()
        .gap(16.0)
        .p(16.0)
        .deps(&amp;[count.signal_id(), step.signal_id()])
        .on_state(move |state, container| {
            // Read current values inside on_state
            let current_count = count.get();
            let current_step = step.get();

            let bg = match state {
                ButtonState::Idle =&gt; Color::rgba(0.15, 0.15, 0.2, 1.0),
                ButtonState::Hovered =&gt; Color::rgba(0.18, 0.18, 0.25, 1.0),
                _ =&gt; Color::rgba(0.15, 0.15, 0.2, 1.0),
            };

            // Update container with dynamic content
            container.merge(
                div()
                    .bg(bg)
                    .child(text(&amp;format!("Count: {}", current_count)).color(Color::WHITE))
                    .child(text(&amp;format!("Step: {}", current_step)).color(Color::WHITE))
            );
        })
        .on_click(move |_| {
            let current_step = step.get();
            count.update(|v| v + current_step);
        })
        .child(increment_button(ctx))
}

fn increment_button(ctx: &amp;WindowedContext) -&gt; impl ElementBuilder {
    let handle = ctx.use_state(ButtonState::Idle);

    stateful(handle)
        .px(16.0)
        .py(8.0)
        .rounded(8.0)
        .on_state(|state, div| {
            let bg = match state {
                ButtonState::Idle =&gt; Color::rgba(0.3, 0.5, 0.9, 1.0),
                ButtonState::Hovered =&gt; Color::rgba(0.4, 0.6, 1.0, 1.0),
                ButtonState::Pressed =&gt; Color::rgba(0.2, 0.4, 0.8, 1.0),
                _ =&gt; Color::rgba(0.3, 0.5, 0.9, 1.0),
            };
            div.set_bg(bg);
        })
        .child(text("Increment").color(Color::WHITE))
}
<span class="boring">}</span></code></pre>
<p><strong>Key point:</strong> When UI content depends on state values that can change, use <code>stateful(handle)</code> with <code>.deps()</code> to declare the dependency. The <code>on_state</code> callback re-runs whenever those signals change, and you update the display via <code>container.merge()</code> or <code>div.set_*()</code> methods.</p>
<h3 id="common-state-patterns"><a class="header" href="#common-state-patterns">Common State Patterns</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(JunitaComponent)]
struct TodoList {
    items: Vec&lt;String&gt;,      // List of items
    filter: Filter,          // Current filter mode
    selected_index: Option&lt;usize&gt;,  // Currently selected item
}

#[derive(JunitaComponent)]
struct FormData {
    username: String,
    email: String,
    is_valid: bool,
}

#[derive(JunitaComponent)]
struct Settings {
    theme: Theme,
    notifications_enabled: bool,
    volume: f32,
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="animation-fields"><a class="header" href="#animation-fields">Animation Fields</a></h2>
<p>Fields with <code>#[animation]</code> generate spring animation hooks:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(JunitaComponent)]
struct PullToRefresh {
    #[animation]
    content_offset: f32,    // Generates: use_content_offset(ctx, initial, config)

    #[animation]
    icon_scale: f32,        // Generates: use_icon_scale(ctx, initial, config)

    #[animation]
    icon_opacity: f32,      // Generates: use_icon_opacity(ctx, initial, config)
}
<span class="boring">}</span></code></pre>
<h3 id="using-animation-fields"><a class="header" href="#using-animation-fields">Using Animation Fields</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn pull_to_refresh_demo(ctx: &amp;WindowedContext) -&gt; impl ElementBuilder {
    // Each field gets its own type-safe hook
    let content_offset = PullToRefresh::use_content_offset(ctx, 0.0, SpringConfig::wobbly());
    let icon_scale = PullToRefresh::use_icon_scale(ctx, 0.5, SpringConfig::snappy());
    let icon_opacity = PullToRefresh::use_icon_opacity(ctx, 0.0, SpringConfig::snappy());

    // Use with motion() for animated rendering
    motion()
        .translate_y(content_offset.lock().unwrap().get())
        .child(/* content */)
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="combining-state-and-animation"><a class="header" href="#combining-state-and-animation">Combining State and Animation</a></h2>
<p>A component can have both state and animation fields:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(JunitaComponent)]
struct ExpandableCard {
    // State fields
    is_expanded: bool,
    content: String,

    // Animation fields
    #[animation]
    height: f32,
    #[animation]
    arrow_rotation: f32,
}

fn expandable_card(ctx: &amp;WindowedContext) -&gt; impl ElementBuilder {
    let is_expanded = ExpandableCard::use_is_expanded(ctx, false);
    let height = ExpandableCard::use_height(ctx, 60.0, SpringConfig::snappy());
    let arrow_rotation = ExpandableCard::use_arrow_rotation(ctx, 0.0, SpringConfig::snappy());

    let expanded = is_expanded.get();

    motion()
        .h(height.lock().unwrap().get())
        .on_click(move |_| {
            is_expanded.update(|v| !v);
            let target_height = if !expanded { 200.0 } else { 60.0 };
            let target_rotation = if !expanded { 180.0 } else { 0.0 };
            height.lock().unwrap().set_target(target_height);
            arrow_rotation.lock().unwrap().set_target(target_rotation);
        })
        .child(/* card content */)
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="multiple-values-per-component"><a class="header" href="#multiple-values-per-component">Multiple Values per Component</a></h2>
<p>Use <code>_with</code> suffix methods for multiple values of the same type:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(JunitaComponent)]
struct DraggableBox;

fn draggable(ctx: &amp;WindowedContext) -&gt; impl ElementBuilder {
    // Multiple animated values with suffixes
    let x = DraggableBox::use_animated_value_with(ctx, "x", 100.0, SpringConfig::wobbly());
    let y = DraggableBox::use_animated_value_with(ctx, "y", 100.0, SpringConfig::wobbly());

    // ...
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="timelines-with-junitacomponent"><a class="header" href="#timelines-with-junitacomponent">Timelines with JunitaComponent</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(JunitaComponent)]
struct SpinningLoader;

fn loader(ctx: &amp;WindowedContext) -&gt; impl ElementBuilder {
    let timeline = SpinningLoader::use_animated_timeline(ctx);

    let entry_id = timeline.lock().unwrap().configure(|t| {
        let id = t.add(0, 1000, 0.0, 360.0);
        t.set_loop(-1);
        t.start();
        id
    });

    // ...
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="how-it-works-3"><a class="header" href="#how-it-works-3">How It Works</a></h2>
<p>The macro generates a unique key from <code>module_path!()</code> and the struct name:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl MyCard {
    pub const COMPONENT_KEY: &amp;'static str = concat!(module_path!(), "::", stringify!(MyCard));
    // e.g., "my_app::components::MyCard"
}
<span class="boring">}</span></code></pre>
<p>This ensures:</p>
<ul>
<li><strong>Uniqueness</strong> - Keys are unique across your entire codebase</li>
<li><strong>Stability</strong> - Keys don’t change unless you move/rename the struct</li>
<li><strong>No collisions</strong> - Different modules can have same-named components</li>
</ul>
<hr>
<h2 id="generated-methods"><a class="header" href="#generated-methods">Generated Methods</a></h2>
<h3 id="for-unit-structs"><a class="header" href="#for-unit-structs">For Unit Structs</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(JunitaComponent)]
struct MyComponent;

// Generates:
impl MyComponent {
    pub const COMPONENT_KEY: &amp;'static str;

    pub fn use_animated_value(
        ctx: &amp;WindowedContext,
        initial: f32,
        config: SpringConfig,
    ) -&gt; SharedAnimatedValue;

    pub fn use_animated_value_with(
        ctx: &amp;WindowedContext,
        suffix: &amp;str,
        initial: f32,
        config: SpringConfig,
    ) -&gt; SharedAnimatedValue;

    pub fn use_animated_timeline(
        ctx: &amp;WindowedContext,
    ) -&gt; SharedAnimatedTimeline;

    pub fn use_animated_timeline_with(
        ctx: &amp;WindowedContext,
        suffix: &amp;str,
    ) -&gt; SharedAnimatedTimeline;
}
<span class="boring">}</span></code></pre>
<h3 id="for-structs-with-fields"><a class="header" href="#for-structs-with-fields">For Structs with Fields</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(JunitaComponent)]
struct MyComponent {
    #[animation]
    scale: f32,
    count: i32,
}

// Additionally generates:
impl MyComponent {
    pub fn use_scale(
        ctx: &amp;WindowedContext,
        initial: f32,
        config: SpringConfig,
    ) -&gt; SharedAnimatedValue;

    pub fn use_count(
        ctx: &amp;WindowedContext,
        initial: i32,
    ) -&gt; State&lt;i32&gt;;
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="best-practices-5"><a class="header" href="#best-practices-5">Best Practices</a></h2>
<ol>
<li>
<p><strong>Group related state and animations</strong> - A component should represent one logical UI element with its related state and animations.</p>
</li>
<li>
<p><strong>Use fields for named values</strong> - Prefer <code>#[animation] scale: f32</code> over <code>use_animated_value_with(ctx, "scale", ...)</code>.</p>
</li>
<li>
<p><strong>Combine state and animations</strong> - Use state fields for data, animation fields for visual transitions.</p>
</li>
<li>
<p><strong>Document fields</strong> - Add doc comments to fields for generated method documentation.</p>
</li>
</ol>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(JunitaComponent)]
struct ExpandableSection {
    /// Whether the section is currently expanded
    is_expanded: bool,

    /// Animated height for smooth expand/collapse
    #[animation]
    height: f32,
}
<span class="boring">}</span></code></pre>
<ol start="5">
<li><strong>Use <code>motion()</code> with animated values</strong> - Wrap content using animated values in <code>motion()</code> for proper redraws.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="building-reusable-components"><a class="header" href="#building-reusable-components">Building Reusable Components</a></h1>
<p>This guide covers patterns for creating composable, reusable UI components in Junita.</p>
<h2 id="component-patterns"><a class="header" href="#component-patterns">Component Patterns</a></h2>
<h3 id="simple-function-components"><a class="header" href="#simple-function-components">Simple Function Components</a></h3>
<p>The simplest pattern - a function returning an element:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn card(title: &amp;str) -&gt; Div {
    div()
        .p(16.0)
        .rounded(12.0)
        .bg(Color::rgba(0.15, 0.15, 0.2, 1.0))
        .child(
            text(title)
                .size(18.0)
                .weight(FontWeight::SemiBold)
                .color(Color::WHITE)
        )
}

// Usage
div().child(card("My Card"))
<span class="boring">}</span></code></pre>
<h3 id="components-with-children"><a class="header" href="#components-with-children">Components with Children</a></h3>
<p>Accept generic children with <code>impl ElementBuilder</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn card_with_content&lt;E: ElementBuilder&gt;(title: &amp;str, content: E) -&gt; Div {
    div()
        .p(16.0)
        .rounded(12.0)
        .bg(Color::rgba(0.15, 0.15, 0.2, 1.0))
        .flex_col()
        .gap(12.0)
        .child(
            text(title)
                .size(18.0)
                .weight(FontWeight::SemiBold)
                .color(Color::WHITE)
        )
        .child(content)
}

// Usage
card_with_content("Settings",
    div()
        .flex_col()
        .gap(8.0)
        .child(text("Option 1"))
        .child(text("Option 2"))
)
<span class="boring">}</span></code></pre>
<h3 id="components-with-context"><a class="header" href="#components-with-context">Components with Context</a></h3>
<p>For components needing state or animations:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use junita_layout::stateful::stateful;

fn counter_card(ctx: &amp;WindowedContext) -&gt; impl ElementBuilder {
    let count = ctx.use_state_keyed("counter_card_count", || 0i32);
    let card_handle = ctx.use_state(ButtonState::Idle);

    stateful(card_handle)
        .p(16.0)
        .rounded(12.0)
        .bg(Color::rgba(0.15, 0.15, 0.2, 1.0))
        .flex_col()
        .gap(12.0)
        .deps(&amp;[count.signal_id()])
        .on_state(move |_state, container| {
            let current = count.get();
            container.merge(
                div()
                    .child(text(&amp;format!("Count: {}", current)).color(Color::WHITE))
            );
        })
        .child(increment_btn(ctx, count))
}

fn increment_btn(ctx: &amp;WindowedContext, count: State&lt;i32&gt;) -&gt; impl ElementBuilder {
    let handle = ctx.use_state(ButtonState::Idle);

    stateful(handle)
        .px(16.0)
        .py(8.0)
        .rounded(8.0)
        .on_state(|state, div| {
            let bg = match state {
                ButtonState::Idle =&gt; Color::rgba(0.3, 0.5, 0.9, 1.0),
                ButtonState::Hovered =&gt; Color::rgba(0.4, 0.6, 1.0, 1.0),
                _ =&gt; Color::rgba(0.3, 0.5, 0.9, 1.0),
            };
            div.set_bg(bg);
        })
        .on_click(move |_| {
            count.update(|v| v + 1);
        })
        .child(text("+").color(Color::WHITE))
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="animated-components"><a class="header" href="#animated-components">Animated Components</a></h2>
<p>Use <code>motion()</code> for components with spring animations:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use junita_layout::motion::motion;

#[derive(JunitaComponent)]
struct AnimatedCard {
    #[animation]
    scale: f32,
    #[animation]
    opacity: f32,
}

fn animated_card(ctx: &amp;WindowedContext, title: &amp;str) -&gt; impl ElementBuilder {
    let scale = AnimatedCard::use_scale(ctx, 1.0, SpringConfig::snappy());
    let opacity = AnimatedCard::use_opacity(ctx, 1.0, SpringConfig::gentle());

    let hover_scale = Arc::clone(&amp;scale);
    let leave_scale = Arc::clone(&amp;scale);

    // motion() is a container - apply transforms to it, style the child
    motion()
        .scale(scale.lock().unwrap().get())
        .opacity(opacity.lock().unwrap().get())
        .on_hover_enter(move |_| {
            hover_scale.lock().unwrap().set_target(1.05);
        })
        .on_hover_leave(move |_| {
            leave_scale.lock().unwrap().set_target(1.0);
        })
        .child(
            div()
                .p(16.0)
                .rounded(12.0)
                .bg(Color::rgba(0.15, 0.15, 0.2, 1.0))
                .child(text(title).color(Color::WHITE))
        )
}
<span class="boring">}</span></code></pre>
<p><strong>Note:</strong> For hover-only visual effects without animations, prefer <code>Stateful</code> instead - it’s more efficient as it doesn’t require continuous redraws.</p>
<hr>
<h2 id="stateful-components"><a class="header" href="#stateful-components">Stateful Components</a></h2>
<p>Use <code>stateful(handle)</code> for components with visual states:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use junita_layout::stateful::stateful;

fn interactive_card(ctx: &amp;WindowedContext, title: &amp;str) -&gt; impl ElementBuilder {
    // Use use_state_for with title as key for reusable component
    let handle = ctx.use_state_for(title, ButtonState::Idle);

    stateful(handle)
        .p(16.0)
        .rounded(12.0)
        .on_state(|state, div| {
            let bg = match state {
                ButtonState::Idle =&gt; Color::rgba(0.15, 0.15, 0.2, 1.0),
                ButtonState::Hovered =&gt; Color::rgba(0.18, 0.18, 0.25, 1.0),
                ButtonState::Pressed =&gt; Color::rgba(0.12, 0.12, 0.16, 1.0),
                _ =&gt; Color::rgba(0.15, 0.15, 0.2, 1.0),
            };
            div.set_bg(bg);
        })
        .child(text(title).color(Color::WHITE))
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="builder-pattern"><a class="header" href="#builder-pattern">Builder Pattern</a></h2>
<p>For highly configurable components:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct CardBuilder {
    title: String,
    subtitle: Option&lt;String&gt;,
    icon: Option&lt;String&gt;,
    bg_color: Color,
    on_click: Option&lt;Box&lt;dyn Fn()&gt;&gt;,
}

impl CardBuilder {
    pub fn new(title: impl Into&lt;String&gt;) -&gt; Self {
        Self {
            title: title.into(),
            subtitle: None,
            icon: None,
            bg_color: Color::rgba(0.15, 0.15, 0.2, 1.0),
            on_click: None,
        }
    }

    pub fn subtitle(mut self, text: impl Into&lt;String&gt;) -&gt; Self {
        self.subtitle = Some(text.into());
        self
    }

    pub fn icon(mut self, path: impl Into&lt;String&gt;) -&gt; Self {
        self.icon = Some(path.into());
        self
    }

    pub fn bg(mut self, color: Color) -&gt; Self {
        self.bg_color = color;
        self
    }

    pub fn build(self) -&gt; Div {
        let mut card = div()
            .p(16.0)
            .rounded(12.0)
            .bg(self.bg_color)
            .flex_col()
            .gap(8.0);

        if let Some(icon_path) = self.icon {
            card = card.child(
                svg(&amp;icon_path).w(24.0).h(24.0).tint(Color::WHITE)
            );
        }

        card = card.child(
            text(&amp;self.title)
                .size(18.0)
                .weight(FontWeight::SemiBold)
                .color(Color::WHITE)
        );

        if let Some(sub) = self.subtitle {
            card = card.child(
                text(&amp;sub)
                    .size(14.0)
                    .color(Color::rgba(0.6, 0.6, 0.7, 1.0))
            );
        }

        card
    }
}

// Usage
CardBuilder::new("Settings")
    .subtitle("Manage your preferences")
    .icon("icons/settings.svg")
    .build()
<span class="boring">}</span></code></pre>
<hr>
<h2 id="component-libraries"><a class="header" href="#component-libraries">Component Libraries</a></h2>
<p>Organize related components in modules:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/components/cards.rs
pub mod cards {
    use junita_app::prelude::*;

    pub fn simple_card(title: &amp;str) -&gt; Div {
        // ...
    }

    pub fn image_card(title: &amp;str, image_url: &amp;str) -&gt; Div {
        // ...
    }

    pub fn action_card&lt;F: Fn() + 'static&gt;(title: &amp;str, on_action: F) -&gt; Div {
        // ...
    }
}

// src/components/mod.rs
pub mod cards;
pub mod buttons;
pub mod inputs;

// Usage
use crate::components::cards::*;
<span class="boring">}</span></code></pre>
<hr>
<h2 id="prop-structs"><a class="header" href="#prop-structs">Prop Structs</a></h2>
<p>For components with many parameters:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct NotificationProps {
    pub title: String,
    pub message: String,
    pub variant: NotificationVariant,
    pub dismissible: bool,
    pub on_dismiss: Option&lt;Box&lt;dyn Fn()&gt;&gt;,
}

pub enum NotificationVariant {
    Info,
    Success,
    Warning,
    Error,
}

pub fn notification(props: NotificationProps) -&gt; Div {
    let (bg, icon) = match props.variant {
        NotificationVariant::Info =&gt; (Color::rgba(0.2, 0.4, 0.8, 1.0), "info.svg"),
        NotificationVariant::Success =&gt; (Color::rgba(0.2, 0.7, 0.4, 1.0), "check.svg"),
        NotificationVariant::Warning =&gt; (Color::rgba(0.8, 0.6, 0.2, 1.0), "warning.svg"),
        NotificationVariant::Error =&gt; (Color::rgba(0.8, 0.3, 0.3, 1.0), "error.svg"),
    };

    div()
        .p(16.0)
        .rounded(8.0)
        .bg(bg)
        .flex_row()
        .gap(12.0)
        .items_center()
        .child(svg(icon).w(20.0).h(20.0).tint(Color::WHITE))
        .child(
            div()
                .flex_1()
                .flex_col()
                .gap(4.0)
                .child(text(&amp;props.title).weight(FontWeight::SemiBold).color(Color::WHITE))
                .child(text(&amp;props.message).size(14.0).color(Color::rgba(1.0, 1.0, 1.0, 0.8)))
        )
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="best-practices-6"><a class="header" href="#best-practices-6">Best Practices</a></h2>
<ol>
<li>
<p><strong>Keep components focused</strong> - One component, one responsibility.</p>
</li>
<li>
<p><strong>Use <code>impl ElementBuilder</code></strong> - For maximum flexibility in return types.</p>
</li>
<li>
<p><strong>Document public components</strong> - Add doc comments explaining usage.</p>
</li>
<li>
<p><strong>Consistent naming</strong> - Use descriptive names that indicate the component’s purpose.</p>
</li>
<li>
<p><strong>Default sensible styles</strong> - Provide good defaults, allow overrides.</p>
</li>
<li>
<p><strong>Separate stateless and stateful</strong> - Pure components are easier to test and reuse.</p>
</li>
<li>
<p><strong>Use JunitaComponent for state and animations</strong> - Type-safe hooks for both <code>State&lt;T&gt;</code> and <code>SharedAnimatedValue</code> prevent key collisions.</p>
</li>
<li>
<p><strong>Use Stateful for visual states</strong> - Hover, press, focus effects should use <code>Stateful</code> rather than signals.</p>
</li>
<li>
<p><strong>Use motion() for animated values</strong> - Wrap animated content in <code>motion()</code> for proper redraws.</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="component-library-overview"><a class="header" href="#component-library-overview">Component Library Overview</a></h1>
<p><code>junita_cn</code> is a comprehensive component library for Junita UI, inspired by <a href="https://ui.shadcn.com/">shadcn/ui</a>. It provides 40+ production-ready, themeable components built on top of <code>junita_layout</code>.</p>
<h2 id="installation-1"><a class="header" href="#installation-1">Installation</a></h2>
<p>Add <code>junita_cn</code> to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
junita_cn = { path = "path/to/junita_cn" }
</code></pre>
<h2 id="quick-start-2"><a class="header" href="#quick-start-2">Quick Start</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use junita_cn::prelude::*;

fn build_ui() -&gt; impl ElementBuilder {
    div()
        .flex_col()
        .gap(16.0)
        .p(24.0)
        .child(
            card()
                .child(card_header()
                    .child(card_title("Welcome"))
                    .child(card_description("Get started with junita_cn")))
                .child(card_content()
                    .child(text("Beautiful, accessible components.")))
                .child(card_footer()
                    .child(button("Get Started")))
        )
}
<span class="boring">}</span></code></pre>
<h2 id="design-principles"><a class="header" href="#design-principles">Design Principles</a></h2>
<h3 id="composable"><a class="header" href="#composable">Composable</a></h3>
<p>Components are built from smaller primitives that can be combined:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Compose dialog from parts
dialog()
    .child(dialog_trigger().child(button("Open")))
    .child(dialog_content()
        .child(dialog_header().child(dialog_title("Title")))
        .child(/* content */)
        .child(dialog_footer().child(button("Close"))))
<span class="boring">}</span></code></pre>
<h3 id="themeable"><a class="header" href="#themeable">Themeable</a></h3>
<p>All components use theme tokens and automatically support dark mode:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Components adapt to theme automatically
button("Click me") // Uses theme.colors.primary

// Override theme
ThemeState::set_color_scheme(ColorScheme::Dark);
<span class="boring">}</span></code></pre>
<h3 id="accessible"><a class="header" href="#accessible">Accessible</a></h3>
<p>Components include keyboard navigation and proper semantics:</p>
<ul>
<li>Focus management</li>
<li>Keyboard shortcuts</li>
<li>Screen reader support (planned)</li>
</ul>
<h2 id="component-categories"><a class="header" href="#component-categories">Component Categories</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Category</th><th>Components</th></tr>
</thead>
<tbody>
<tr><td><strong>Buttons</strong></td><td>Button</td></tr>
<tr><td><strong>Cards</strong></td><td>Card, CardHeader, CardContent, CardFooter</td></tr>
<tr><td><strong>Dialogs</strong></td><td>Dialog, AlertDialog, Sheet, Drawer</td></tr>
<tr><td><strong>Forms</strong></td><td>Input, Textarea, Checkbox, Switch, Radio, Select, Slider</td></tr>
<tr><td><strong>Navigation</strong></td><td>Tabs, DropdownMenu, ContextMenu, Breadcrumb, Sidebar</td></tr>
<tr><td><strong>Feedback</strong></td><td>Alert, Badge, Progress, Spinner, Skeleton, Toast</td></tr>
<tr><td><strong>Layout</strong></td><td>Avatar, Separator, AspectRatio, ScrollArea, Accordion</td></tr>
<tr><td><strong>Data</strong></td><td>Tooltip, HoverCard, Popover, Chart</td></tr>
</tbody>
</table>
</div>
<h2 id="prelude"><a class="header" href="#prelude">Prelude</a></h2>
<p>Import common components with the prelude:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use junita_cn::prelude::*;

// Includes:
// - All component builders (button, card, dialog, etc.)
// - Variant enums (ButtonVariant, AlertVariant, etc.)
// - Size enums (ButtonSize, AvatarSize, etc.)
// - Common types and traits
<span class="boring">}</span></code></pre>
<h2 id="next-steps-3"><a class="header" href="#next-steps-3">Next Steps</a></h2>
<ul>
<li><a href="#button">Button</a> - Learn about button variants and usage</li>
<li><a href="#card">Card</a> - Build card-based layouts</li>
<li><a href="#dialog">Dialog</a> - Create modal dialogs</li>
<li><a href="#form-components">Form Components</a> - Build forms with inputs</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="button"><a class="header" href="#button">Button</a></h1>
<p>Buttons trigger actions or events.</p>
<h2 id="basic-usage-5"><a class="header" href="#basic-usage-5">Basic Usage</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use junita_cn::prelude::*;

button("Click me")
    .on_click(|| println!("Clicked!"))
<span class="boring">}</span></code></pre>
<h2 id="variants"><a class="header" href="#variants">Variants</a></h2>
<p>Buttons come in several visual variants:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Primary (default) - Main actions
button("Save").variant(ButtonVariant::Primary)

// Secondary - Alternative actions
button("Cancel").variant(ButtonVariant::Secondary)

// Destructive - Dangerous actions
button("Delete").variant(ButtonVariant::Destructive)

// Outline - Bordered style
button("Edit").variant(ButtonVariant::Outline)

// Ghost - Minimal style
button("More").variant(ButtonVariant::Ghost)

// Link - Looks like a link
button("Learn more").variant(ButtonVariant::Link)
<span class="boring">}</span></code></pre>
<h2 id="sizes"><a class="header" href="#sizes">Sizes</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Small
button("Small").size(ButtonSize::Sm)

// Default
button("Default").size(ButtonSize::Default)

// Large
button("Large").size(ButtonSize::Lg)

// Icon only (square)
button("").size(ButtonSize::Icon).icon(icons::SETTINGS)
<span class="boring">}</span></code></pre>
<h2 id="with-icons"><a class="header" href="#with-icons">With Icons</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use junita_icons::icons;

// Icon before text
button("Settings")
    .icon(icons::SETTINGS)

// Icon after text
button("Next")
    .icon_right(icons::ARROW_RIGHT)

// Icon only
button("")
    .size(ButtonSize::Icon)
    .icon(icons::PLUS)
<span class="boring">}</span></code></pre>
<h2 id="states"><a class="header" href="#states">States</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Disabled
button("Disabled")
    .disabled(true)

// Loading
button("Saving...")
    .loading(true)

// Full width
button("Submit")
    .full_width(true)
<span class="boring">}</span></code></pre>
<h2 id="event-handling-2"><a class="header" href="#event-handling-2">Event Handling</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>button("Submit")
    .on_click(|| {
        // Handle click
        submit_form();
    })
    .on_hover(|hovering| {
        // Handle hover state
        if hovering {
            show_tooltip();
        }
    })
<span class="boring">}</span></code></pre>
<h2 id="button-groups"><a class="header" href="#button-groups">Button Groups</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>div()
    .flex_row()
    .gap(8.0)
    .child(button("Save").variant(ButtonVariant::Primary))
    .child(button("Cancel").variant(ButtonVariant::Outline))
<span class="boring">}</span></code></pre>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<h3 id="form-submit-button"><a class="header" href="#form-submit-button">Form Submit Button</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>button("Create Account")
    .variant(ButtonVariant::Primary)
    .size(ButtonSize::Lg)
    .full_width(true)
    .on_click(|| handle_submit())
<span class="boring">}</span></code></pre>
<h3 id="icon-button"><a class="header" href="#icon-button">Icon Button</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>button("")
    .size(ButtonSize::Icon)
    .variant(ButtonVariant::Ghost)
    .icon(icons::X)
    .on_click(|| close_dialog())
<span class="boring">}</span></code></pre>
<h3 id="loading-button"><a class="header" href="#loading-button">Loading Button</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let is_loading = use_state(false);

button(if is_loading { "Saving..." } else { "Save" })
    .loading(is_loading)
    .disabled(is_loading)
    .on_click(|| {
        set_loading(true);
        save_data().then(|| set_loading(false));
    })
<span class="boring">}</span></code></pre>
<h2 id="api-reference"><a class="header" href="#api-reference">API Reference</a></h2>
<h3 id="props"><a class="header" href="#props">Props</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Prop</th><th>Type</th><th>Default</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>variant</code></td><td><code>ButtonVariant</code></td><td><code>Primary</code></td><td>Visual style</td></tr>
<tr><td><code>size</code></td><td><code>ButtonSize</code></td><td><code>Default</code></td><td>Button size</td></tr>
<tr><td><code>disabled</code></td><td><code>bool</code></td><td><code>false</code></td><td>Disable interaction</td></tr>
<tr><td><code>loading</code></td><td><code>bool</code></td><td><code>false</code></td><td>Show loading state</td></tr>
<tr><td><code>full_width</code></td><td><code>bool</code></td><td><code>false</code></td><td>Expand to full width</td></tr>
<tr><td><code>icon</code></td><td><code>&amp;str</code></td><td><code>None</code></td><td>Icon before text</td></tr>
<tr><td><code>icon_right</code></td><td><code>&amp;str</code></td><td><code>None</code></td><td>Icon after text</td></tr>
</tbody>
</table>
</div>
<h3 id="events"><a class="header" href="#events">Events</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Event</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>on_click</code></td><td><code>Fn()</code></td><td>Called when clicked</td></tr>
<tr><td><code>on_hover</code></td><td><code>Fn(bool)</code></td><td>Called on hover change</td></tr>
</tbody>
</table>
</div>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="card"><a class="header" href="#card">Card</a></h1>
<p>Cards group related content and actions.</p>
<h2 id="basic-usage-6"><a class="header" href="#basic-usage-6">Basic Usage</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use junita_cn::prelude::*;

card()
    .child(card_header()
        .child(card_title("Card Title"))
        .child(card_description("Card description text")))
    .child(card_content()
        .child(text("Card content goes here.")))
    .child(card_footer()
        .child(button("Action")))
<span class="boring">}</span></code></pre>
<h2 id="card-parts"><a class="header" href="#card-parts">Card Parts</a></h2>
<h3 id="card-1"><a class="header" href="#card-1">card()</a></h3>
<p>The container that wraps all card content.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>card()
    .w(400.0)  // Custom width
    .child(/* card parts */)
<span class="boring">}</span></code></pre>
<h3 id="card_header"><a class="header" href="#card_header">card_header()</a></h3>
<p>Contains the title and description.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>card_header()
    .child(card_title("Title"))
    .child(card_description("Description"))
<span class="boring">}</span></code></pre>
<h3 id="card_title"><a class="header" href="#card_title">card_title()</a></h3>
<p>The main heading of the card.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>card_title("Account Settings")
<span class="boring">}</span></code></pre>
<h3 id="card_description"><a class="header" href="#card_description">card_description()</a></h3>
<p>Secondary text below the title.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>card_description("Manage your account preferences")
<span class="boring">}</span></code></pre>
<h3 id="card_content"><a class="header" href="#card_content">card_content()</a></h3>
<p>The main content area.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>card_content()
    .child(/* any content */)
<span class="boring">}</span></code></pre>
<h3 id="card_footer"><a class="header" href="#card_footer">card_footer()</a></h3>
<p>Actions and secondary information at the bottom.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>card_footer()
    .child(button("Cancel").variant(ButtonVariant::Outline))
    .child(button("Save"))
<span class="boring">}</span></code></pre>
<h2 id="examples-1"><a class="header" href="#examples-1">Examples</a></h2>
<h3 id="simple-card"><a class="header" href="#simple-card">Simple Card</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>card()
    .child(card_header()
        .child(card_title("Notifications"))
        .child(card_description("Configure notification settings")))
    .child(card_content()
        .child(
            div()
                .flex_col()
                .gap(12.0)
                .child(checkbox().checked(true).child(label("Email notifications")))
                .child(checkbox().child(label("Push notifications")))
        ))
<span class="boring">}</span></code></pre>
<h3 id="card-with-image"><a class="header" href="#card-with-image">Card with Image</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>card()
    .overflow_clip()
    .child(
        img("cover.jpg")
            .w_full()
            .h(200.0)
            .cover()
    )
    .child(card_header()
        .child(card_title("Beautiful Sunset"))
        .child(card_description("Photo by @photographer")))
    .child(card_footer()
        .child(button("View").variant(ButtonVariant::Outline))
        .child(button("Download")))
<span class="boring">}</span></code></pre>
<h3 id="card-with-form"><a class="header" href="#card-with-form">Card with Form</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>card()
    .w(350.0)
    .child(card_header()
        .child(card_title("Login"))
        .child(card_description("Enter your credentials")))
    .child(card_content()
        .child(
            div()
                .flex_col()
                .gap(16.0)
                .child(
                    div()
                        .flex_col()
                        .gap(4.0)
                        .child(label("Email"))
                        .child(input().placeholder("name@example.com"))
                )
                .child(
                    div()
                        .flex_col()
                        .gap(4.0)
                        .child(label("Password"))
                        .child(input().input_type("password"))
                )
        ))
    .child(card_footer()
        .child(button("Sign in").full_width(true)))
<span class="boring">}</span></code></pre>
<h3 id="card-grid-1"><a class="header" href="#card-grid-1">Card Grid</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>div()
    .grid()
    .grid_cols(3)
    .gap(16.0)
    .child(
        card()
            .child(card_header().child(card_title("Plan A")))
            .child(card_content().child(text("$9/month")))
            .child(card_footer().child(button("Select")))
    )
    .child(
        card()
            .child(card_header().child(card_title("Plan B")))
            .child(card_content().child(text("$19/month")))
            .child(card_footer().child(button("Select")))
    )
    .child(
        card()
            .child(card_header().child(card_title("Plan C")))
            .child(card_content().child(text("$29/month")))
            .child(card_footer().child(button("Select")))
    )
<span class="boring">}</span></code></pre>
<h3 id="interactive-card"><a class="header" href="#interactive-card">Interactive Card</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>card()
    .on_click(|| navigate_to("/details"))
    .cursor("pointer")
    .child(card_header()
        .child(card_title("Click Me"))
        .child(card_description("This entire card is clickable")))
    .child(card_content()
        .child(text("Card content...")))
<span class="boring">}</span></code></pre>
<h2 id="styling"><a class="header" href="#styling">Styling</a></h2>
<p>Cards automatically use theme tokens:</p>
<ul>
<li>Background: <code>theme.colors.card</code></li>
<li>Border: <code>theme.colors.border</code></li>
<li>Radius: <code>theme.radius.lg</code></li>
<li>Shadow: <code>theme.shadows.sm</code></li>
</ul>
<p>Override with custom styles:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>card()
    .bg(Color::rgb(0.1, 0.1, 0.1))
    .border(2.0, Color::BLUE)
    .rounded(16.0)
    .shadow(Shadow::lg())
<span class="boring">}</span></code></pre>
<h2 id="api-reference-1"><a class="header" href="#api-reference-1">API Reference</a></h2>
<h3 id="card-2"><a class="header" href="#card-2">card()</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Prop</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>Standard div props</td><td>-</td><td>All div styling props</td></tr>
</tbody>
</table>
</div>
<h3 id="card_header-1"><a class="header" href="#card_header-1">card_header()</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Prop</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>Standard div props</td><td>-</td><td>All div styling props</td></tr>
</tbody>
</table>
</div>
<h3 id="card_title-1"><a class="header" href="#card_title-1">card_title()</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Prop</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>Text content</td><td><code>&amp;str</code></td><td>Title text</td></tr>
</tbody>
</table>
</div>
<h3 id="card_description-1"><a class="header" href="#card_description-1">card_description()</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Prop</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>Text content</td><td><code>&amp;str</code></td><td>Description text</td></tr>
</tbody>
</table>
</div>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="dialog"><a class="header" href="#dialog">Dialog</a></h1>
<p>Dialogs display content in a modal overlay that requires user interaction.</p>
<h2 id="basic-usage-7"><a class="header" href="#basic-usage-7">Basic Usage</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use junita_cn::prelude::*;

let is_open = use_state(false);

dialog()
    .open(is_open)
    .on_open_change(|open| set_is_open(open))
    .child(dialog_trigger()
        .child(button("Open Dialog")))
    .child(dialog_content()
        .child(dialog_header()
            .child(dialog_title("Dialog Title"))
            .child(dialog_description("Dialog description")))
        .child(text("Dialog content goes here."))
        .child(dialog_footer()
            .child(button("Close").on_click(|| set_is_open(false)))))
<span class="boring">}</span></code></pre>
<h2 id="dialog-parts"><a class="header" href="#dialog-parts">Dialog Parts</a></h2>
<h3 id="dialog-1"><a class="header" href="#dialog-1">dialog()</a></h3>
<p>The root component that manages open state.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>dialog()
    .open(is_open)
    .on_open_change(|open| set_open(open))
<span class="boring">}</span></code></pre>
<h3 id="dialog_trigger"><a class="header" href="#dialog_trigger">dialog_trigger()</a></h3>
<p>The element that opens the dialog when clicked.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>dialog_trigger()
    .child(button("Open"))
<span class="boring">}</span></code></pre>
<h3 id="dialog_content"><a class="header" href="#dialog_content">dialog_content()</a></h3>
<p>The modal content container with backdrop.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>dialog_content()
    .child(/* dialog parts */)
<span class="boring">}</span></code></pre>
<h3 id="dialog_header"><a class="header" href="#dialog_header">dialog_header()</a></h3>
<p>Contains title and description.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>dialog_header()
    .child(dialog_title("Title"))
    .child(dialog_description("Description"))
<span class="boring">}</span></code></pre>
<h3 id="dialog_footer"><a class="header" href="#dialog_footer">dialog_footer()</a></h3>
<p>Contains action buttons.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>dialog_footer()
    .child(button("Cancel").variant(ButtonVariant::Outline))
    .child(button("Confirm"))
<span class="boring">}</span></code></pre>
<h3 id="dialog_close"><a class="header" href="#dialog_close">dialog_close()</a></h3>
<p>A button that closes the dialog.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>dialog_close()
    .child(button("Close"))
<span class="boring">}</span></code></pre>
<h2 id="alert-dialog"><a class="header" href="#alert-dialog">Alert Dialog</a></h2>
<p>For destructive or important confirmations:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let is_open = use_state(false);

alert_dialog()
    .open(is_open)
    .on_open_change(|open| set_is_open(open))
    .child(alert_dialog_trigger()
        .child(button("Delete").variant(ButtonVariant::Destructive)))
    .child(alert_dialog_content()
        .child(alert_dialog_header()
            .child(alert_dialog_title("Are you sure?"))
            .child(alert_dialog_description(
                "This action cannot be undone."
            )))
        .child(alert_dialog_footer()
            .child(alert_dialog_cancel().child(button("Cancel")))
            .child(alert_dialog_action()
                .child(button("Delete").variant(ButtonVariant::Destructive)))))
<span class="boring">}</span></code></pre>
<h2 id="sheet"><a class="header" href="#sheet">Sheet</a></h2>
<p>A panel that slides in from the edge:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let is_open = use_state(false);

sheet()
    .open(is_open)
    .side(SheetSide::Right)  // Left, Right, Top, Bottom
    .on_open_change(|open| set_is_open(open))
    .child(sheet_trigger()
        .child(button("Open Sheet")))
    .child(sheet_content()
        .child(sheet_header()
            .child(sheet_title("Settings")))
        .child(/* content */)
        .child(sheet_footer()
            .child(button("Save changes"))))
<span class="boring">}</span></code></pre>
<h2 id="drawer"><a class="header" href="#drawer">Drawer</a></h2>
<p>A mobile-friendly bottom sheet:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let is_open = use_state(false);

drawer()
    .open(is_open)
    .on_open_change(|open| set_is_open(open))
    .child(drawer_trigger()
        .child(button("Open Drawer")))
    .child(drawer_content()
        .child(drawer_header()
            .child(drawer_title("Menu")))
        .child(/* content */))
<span class="boring">}</span></code></pre>
<h2 id="examples-2"><a class="header" href="#examples-2">Examples</a></h2>
<h3 id="form-dialog"><a class="header" href="#form-dialog">Form Dialog</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let is_open = use_state(false);
let name = use_state(String::new());
let email = use_state(String::new());

dialog()
    .open(is_open)
    .on_open_change(|open| set_is_open(open))
    .child(dialog_trigger()
        .child(button("Edit Profile")))
    .child(dialog_content()
        .child(dialog_header()
            .child(dialog_title("Edit Profile"))
            .child(dialog_description("Update your profile information")))
        .child(
            div()
                .flex_col()
                .gap(16.0)
                .child(
                    div().flex_col().gap(4.0)
                        .child(label("Name"))
                        .child(input()
                            .value(&amp;name)
                            .on_change(|v| set_name(v)))
                )
                .child(
                    div().flex_col().gap(4.0)
                        .child(label("Email"))
                        .child(input()
                            .value(&amp;email)
                            .on_change(|v| set_email(v)))
                )
        )
        .child(dialog_footer()
            .child(dialog_close().child(
                button("Cancel").variant(ButtonVariant::Outline)
            ))
            .child(button("Save").on_click(|| {
                save_profile();
                set_is_open(false);
            }))))
<span class="boring">}</span></code></pre>
<h3 id="confirmation-dialog"><a class="header" href="#confirmation-dialog">Confirmation Dialog</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let is_open = use_state(false);

alert_dialog()
    .open(is_open)
    .on_open_change(|open| set_is_open(open))
    .child(alert_dialog_trigger()
        .child(button("Delete Account").variant(ButtonVariant::Destructive)))
    .child(alert_dialog_content()
        .child(alert_dialog_header()
            .child(alert_dialog_title("Delete Account"))
            .child(alert_dialog_description(
                "Are you sure you want to delete your account? \
                 All your data will be permanently removed."
            )))
        .child(alert_dialog_footer()
            .child(alert_dialog_cancel().child(
                button("Cancel").variant(ButtonVariant::Outline)
            ))
            .child(alert_dialog_action().child(
                button("Delete")
                    .variant(ButtonVariant::Destructive)
                    .on_click(|| delete_account())
            ))))
<span class="boring">}</span></code></pre>
<h2 id="api-reference-2"><a class="header" href="#api-reference-2">API Reference</a></h2>
<h3 id="dialog-2"><a class="header" href="#dialog-2">dialog()</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Prop</th><th>Type</th><th>Default</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>open</code></td><td><code>bool</code></td><td><code>false</code></td><td>Whether dialog is open</td></tr>
<tr><td><code>on_open_change</code></td><td><code>Fn(bool)</code></td><td>-</td><td>Called when open state changes</td></tr>
</tbody>
</table>
</div>
<h3 id="sheet-1"><a class="header" href="#sheet-1">sheet()</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Prop</th><th>Type</th><th>Default</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>open</code></td><td><code>bool</code></td><td><code>false</code></td><td>Whether sheet is open</td></tr>
<tr><td><code>side</code></td><td><code>SheetSide</code></td><td><code>Right</code></td><td>Which side to slide from</td></tr>
<tr><td><code>on_open_change</code></td><td><code>Fn(bool)</code></td><td>-</td><td>Called when open state changes</td></tr>
</tbody>
</table>
</div>
<h3 id="sheetside"><a class="header" href="#sheetside">SheetSide</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum SheetSide {
    Left,
    Right,
    Top,
    Bottom,
}
<span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="form-components"><a class="header" href="#form-components">Form Components</a></h1>
<p>Components for building forms: inputs, checkboxes, selects, and more.</p>
<h2 id="input"><a class="header" href="#input">Input</a></h2>
<p>Text input field:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use junita_cn::prelude::*;

input()
    .placeholder("Enter your name...")
    .value(name)
    .on_change(|value| set_name(value))
<span class="boring">}</span></code></pre>
<h3 id="input-types"><a class="header" href="#input-types">Input Types</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Text (default)
input().placeholder("Name")

// Email
input().input_type("email").placeholder("Email")

// Password
input().input_type("password").placeholder("Password")

// Number
input().input_type("number").placeholder("Age")

// Search
input().input_type("search").placeholder("Search...")
<span class="boring">}</span></code></pre>
<h3 id="input-states"><a class="header" href="#input-states">Input States</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Disabled
input().disabled(true)

// Read-only
input().readonly(true)

// With error
input().error(true)
<span class="boring">}</span></code></pre>
<h2 id="textarea"><a class="header" href="#textarea">Textarea</a></h2>
<p>Multi-line text input:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>textarea()
    .placeholder("Enter description...")
    .rows(4)
    .value(description)
    .on_change(|value| set_description(value))
<span class="boring">}</span></code></pre>
<h2 id="checkbox"><a class="header" href="#checkbox">Checkbox</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>checkbox()
    .checked(is_checked)
    .on_change(|checked| set_checked(checked))
    .child(label("Accept terms and conditions"))
<span class="boring">}</span></code></pre>
<h3 id="indeterminate-state"><a class="header" href="#indeterminate-state">Indeterminate State</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>checkbox()
    .checked(some_checked)
    .indeterminate(some_checked &amp;&amp; !all_checked)
    .on_change(|checked| toggle_all(checked))
    .child(label("Select all"))
<span class="boring">}</span></code></pre>
<h2 id="switch"><a class="header" href="#switch">Switch</a></h2>
<p>Toggle switch:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>switch_()
    .checked(is_enabled)
    .on_change(|enabled| set_enabled(enabled))
<span class="boring">}</span></code></pre>
<h3 id="with-label"><a class="header" href="#with-label">With Label</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>div()
    .flex_row()
    .items_center()
    .gap(8.0)
    .child(switch_().checked(dark_mode).on_change(|v| set_dark_mode(v)))
    .child(label("Dark mode"))
<span class="boring">}</span></code></pre>
<h2 id="radio-group"><a class="header" href="#radio-group">Radio Group</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>radio_group()
    .value(selected)
    .on_change(|value| set_selected(value))
    .child(
        div().flex_col().gap(8.0)
            .child(radio_item("small").child(label("Small")))
            .child(radio_item("medium").child(label("Medium")))
            .child(radio_item("large").child(label("Large")))
    )
<span class="boring">}</span></code></pre>
<h2 id="select"><a class="header" href="#select">Select</a></h2>
<p>Dropdown selection:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>select()
    .value(selected)
    .on_change(|value| set_selected(value))
    .child(select_trigger()
        .child(select_value().placeholder("Select option...")))
    .child(select_content()
        .child(select_item("opt1").child(text("Option 1")))
        .child(select_item("opt2").child(text("Option 2")))
        .child(select_item("opt3").child(text("Option 3"))))
<span class="boring">}</span></code></pre>
<h3 id="grouped-options"><a class="header" href="#grouped-options">Grouped Options</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>select()
    .child(select_trigger().child(select_value()))
    .child(select_content()
        .child(select_group()
            .child(select_label("Fruits"))
            .child(select_item("apple").child(text("Apple")))
            .child(select_item("banana").child(text("Banana"))))
        .child(select_separator())
        .child(select_group()
            .child(select_label("Vegetables"))
            .child(select_item("carrot").child(text("Carrot")))
            .child(select_item("broccoli").child(text("Broccoli")))))
<span class="boring">}</span></code></pre>
<h2 id="combobox"><a class="header" href="#combobox">Combobox</a></h2>
<p>Searchable select with autocomplete:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>combobox()
    .value(selected)
    .on_change(|value| set_selected(value))
    .child(combobox_trigger()
        .child(combobox_input().placeholder("Search...")))
    .child(combobox_content()
        .child(combobox_empty().child(text("No results found")))
        .child(combobox_item("react").child(text("React")))
        .child(combobox_item("vue").child(text("Vue")))
        .child(combobox_item("svelte").child(text("Svelte"))))
<span class="boring">}</span></code></pre>
<h2 id="slider"><a class="header" href="#slider">Slider</a></h2>
<p>Range slider:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>slider()
    .value(volume)
    .min(0.0)
    .max(100.0)
    .step(1.0)
    .on_change(|value| set_volume(value))
<span class="boring">}</span></code></pre>
<h3 id="range-slider"><a class="header" href="#range-slider">Range Slider</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>slider()
    .value_range(min_price, max_price)
    .min(0.0)
    .max(1000.0)
    .on_change_range(|min, max| {
        set_min_price(min);
        set_max_price(max);
    })
<span class="boring">}</span></code></pre>
<h2 id="label"><a class="header" href="#label">Label</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Associated with input via for
label("Email").for_id("email-input")

// Direct child of input
checkbox()
    .child(label("Remember me"))
<span class="boring">}</span></code></pre>
<h2 id="form-layout-example"><a class="header" href="#form-layout-example">Form Layout Example</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>div()
    .flex_col()
    .gap(24.0)
    .max_w(400.0)
    // Name field
    .child(
        div().flex_col().gap(4.0)
            .child(label("Name"))
            .child(input()
                .placeholder("John Doe")
                .value(&amp;name)
                .on_change(|v| set_name(v)))
    )
    // Email field
    .child(
        div().flex_col().gap(4.0)
            .child(label("Email"))
            .child(input()
                .input_type("email")
                .placeholder("john@example.com")
                .value(&amp;email)
                .on_change(|v| set_email(v)))
    )
    // Country select
    .child(
        div().flex_col().gap(4.0)
            .child(label("Country"))
            .child(select()
                .value(&amp;country)
                .on_change(|v| set_country(v))
                .child(select_trigger().child(select_value()))
                .child(select_content()
                    .child(select_item("us").child(text("United States")))
                    .child(select_item("uk").child(text("United Kingdom")))
                    .child(select_item("ca").child(text("Canada")))))
    )
    // Terms checkbox
    .child(
        checkbox()
            .checked(accepted_terms)
            .on_change(|v| set_accepted_terms(v))
            .child(label("I accept the terms and conditions"))
    )
    // Submit button
    .child(
        button("Submit")
            .full_width(true)
            .disabled(!accepted_terms)
            .on_click(|| submit_form())
    )
<span class="boring">}</span></code></pre>
<h2 id="validation"><a class="header" href="#validation">Validation</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let email = use_state(String::new());
let email_error = use_derived(|| {
    if email.is_empty() {
        None
    } else if !email.contains('@') {
        Some("Invalid email address")
    } else {
        None
    }
});

div().flex_col().gap(4.0)
    .child(label("Email"))
    .child(input()
        .value(&amp;email)
        .error(email_error.is_some())
        .on_change(|v| set_email(v)))
    .child(
        email_error.map(|err|
            text(err).size(12.0).color(Color::RED)
        )
    )
<span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="navigation-components"><a class="header" href="#navigation-components">Navigation Components</a></h1>
<p>Components for navigation: tabs, menus, breadcrumbs, and sidebars.</p>
<h2 id="tabs"><a class="header" href="#tabs">Tabs</a></h2>
<p>Organize content into tabbed sections:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use junita_cn::prelude::*;

tabs()
    .value(active_tab)
    .on_change(|tab| set_active_tab(tab))
    .child(tabs_list()
        .child(tabs_trigger("account").child(text("Account")))
        .child(tabs_trigger("password").child(text("Password")))
        .child(tabs_trigger("settings").child(text("Settings"))))
    .child(tabs_content("account")
        .child(text("Account settings...")))
    .child(tabs_content("password")
        .child(text("Password settings...")))
    .child(tabs_content("settings")
        .child(text("Other settings...")))
<span class="boring">}</span></code></pre>
<h2 id="dropdown-menu"><a class="header" href="#dropdown-menu">Dropdown Menu</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>dropdown_menu()
    .child(dropdown_menu_trigger()
        .child(button("Options").icon_right(icons::CHEVRON_DOWN)))
    .child(dropdown_menu_content()
        .child(dropdown_menu_label("Actions"))
        .child(dropdown_menu_item("edit")
            .child(icon(icons::EDIT))
            .child(text("Edit"))
            .on_click(|| edit_item()))
        .child(dropdown_menu_item("duplicate")
            .child(icon(icons::COPY))
            .child(text("Duplicate")))
        .child(dropdown_menu_separator())
        .child(dropdown_menu_item("delete")
            .child(icon(icons::TRASH))
            .child(text("Delete"))
            .variant(MenuItemVariant::Destructive)))
<span class="boring">}</span></code></pre>
<h3 id="with-keyboard-shortcuts"><a class="header" href="#with-keyboard-shortcuts">With Keyboard Shortcuts</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>dropdown_menu_item("save")
    .child(icon(icons::SAVE))
    .child(text("Save"))
    .child(dropdown_menu_shortcut("⌘S"))
<span class="boring">}</span></code></pre>
<h3 id="submenu"><a class="header" href="#submenu">Submenu</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>dropdown_menu_content()
    .child(dropdown_menu_item("new").child(text("New")))
    .child(dropdown_menu_sub()
        .child(dropdown_menu_sub_trigger()
            .child(text("Share")))
        .child(dropdown_menu_sub_content()
            .child(dropdown_menu_item("email").child(text("Email")))
            .child(dropdown_menu_item("link").child(text("Copy Link")))))
<span class="boring">}</span></code></pre>
<h2 id="context-menu"><a class="header" href="#context-menu">Context Menu</a></h2>
<p>Right-click menu:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>context_menu()
    .child(context_menu_trigger()
        .child(div().w(200.0).h(150.0).bg(Color::GRAY)
            .child(text("Right-click me"))))
    .child(context_menu_content()
        .child(context_menu_item("cut").child(text("Cut")))
        .child(context_menu_item("copy").child(text("Copy")))
        .child(context_menu_item("paste").child(text("Paste")))
        .child(context_menu_separator())
        .child(context_menu_item("delete").child(text("Delete"))))
<span class="boring">}</span></code></pre>
<h2 id="menubar"><a class="header" href="#menubar">Menubar</a></h2>
<p>Application menu bar:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>menubar()
    .child(menubar_menu()
        .child(menubar_trigger().child(text("File")))
        .child(menubar_content()
            .child(menubar_item("new").child(text("New File")))
            .child(menubar_item("open").child(text("Open...")))
            .child(menubar_separator())
            .child(menubar_item("save").child(text("Save")))
            .child(menubar_item("save-as").child(text("Save As...")))))
    .child(menubar_menu()
        .child(menubar_trigger().child(text("Edit")))
        .child(menubar_content()
            .child(menubar_item("undo").child(text("Undo")))
            .child(menubar_item("redo").child(text("Redo")))))
<span class="boring">}</span></code></pre>
<h2 id="breadcrumb"><a class="header" href="#breadcrumb">Breadcrumb</a></h2>
<p>Navigation path:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>breadcrumb()
    .child(breadcrumb_list()
        .child(breadcrumb_item()
            .child(breadcrumb_link("Home").href("/")))
        .child(breadcrumb_separator())
        .child(breadcrumb_item()
            .child(breadcrumb_link("Products").href("/products")))
        .child(breadcrumb_separator())
        .child(breadcrumb_item()
            .child(breadcrumb_page("Details"))))  // Current page (not a link)
<span class="boring">}</span></code></pre>
<h3 id="with-ellipsis"><a class="header" href="#with-ellipsis">With Ellipsis</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>breadcrumb()
    .child(breadcrumb_list()
        .child(breadcrumb_item().child(breadcrumb_link("Home")))
        .child(breadcrumb_separator())
        .child(breadcrumb_ellipsis())  // Collapsed items
        .child(breadcrumb_separator())
        .child(breadcrumb_item().child(breadcrumb_link("Category")))
        .child(breadcrumb_separator())
        .child(breadcrumb_item().child(breadcrumb_page("Current"))))
<span class="boring">}</span></code></pre>
<h2 id="pagination"><a class="header" href="#pagination">Pagination</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pagination()
    .total(100)
    .page_size(10)
    .current_page(current_page)
    .on_page_change(|page| set_current_page(page))
    .child(pagination_content()
        .child(pagination_previous())
        .child(pagination_items())
        .child(pagination_next()))
<span class="boring">}</span></code></pre>
<h2 id="sidebar"><a class="header" href="#sidebar">Sidebar</a></h2>
<p>Application sidebar navigation:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>sidebar()
    .child(sidebar_header()
        .child(
            div().flex_row().items_center().gap(8.0)
                .child(icon(icons::BOX).size(24.0))
                .child(text("My App").weight(FontWeight::Bold))
        ))
    .child(sidebar_content()
        .child(sidebar_group()
            .child(sidebar_group_label("Main"))
            .child(sidebar_menu()
                .child(sidebar_menu_item("dashboard")
                    .icon(icons::HOME)
                    .active(current_route == "dashboard")
                    .on_click(|| navigate("/dashboard"))
                    .child(text("Dashboard")))
                .child(sidebar_menu_item("projects")
                    .icon(icons::FOLDER)
                    .on_click(|| navigate("/projects"))
                    .child(text("Projects")))
                .child(sidebar_menu_item("tasks")
                    .icon(icons::CHECK_SQUARE)
                    .on_click(|| navigate("/tasks"))
                    .child(text("Tasks")))))
        .child(sidebar_group()
            .child(sidebar_group_label("Settings"))
            .child(sidebar_menu()
                .child(sidebar_menu_item("settings")
                    .icon(icons::SETTINGS)
                    .on_click(|| navigate("/settings"))
                    .child(text("Settings")))
                .child(sidebar_menu_item("help")
                    .icon(icons::HELP_CIRCLE)
                    .on_click(|| navigate("/help"))
                    .child(text("Help"))))))
    .child(sidebar_footer()
        .child(
            div().flex_row().items_center().gap(8.0)
                .child(avatar().src("user.jpg").size(AvatarSize::Sm))
                .child(text("John Doe"))
        ))
<span class="boring">}</span></code></pre>
<h3 id="collapsible-sidebar"><a class="header" href="#collapsible-sidebar">Collapsible Sidebar</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let is_collapsed = use_state(false);

sidebar()
    .collapsed(is_collapsed)
    .child(sidebar_header()
        .child(sidebar_trigger()
            .on_click(|| set_is_collapsed(!is_collapsed))))
    .child(/* rest of sidebar */)
<span class="boring">}</span></code></pre>
<h2 id="navigation-menu"><a class="header" href="#navigation-menu">Navigation Menu</a></h2>
<p>Horizontal navigation with dropdowns:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>navigation_menu()
    .child(navigation_menu_list()
        .child(navigation_menu_item()
            .child(navigation_menu_trigger().child(text("Products")))
            .child(navigation_menu_content()
                .child(navigation_menu_link("analytics").child(text("Analytics")))
                .child(navigation_menu_link("reports").child(text("Reports")))))
        .child(navigation_menu_item()
            .child(navigation_menu_link("pricing").child(text("Pricing"))))
        .child(navigation_menu_item()
            .child(navigation_menu_link("about").child(text("About")))))
<span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="feedback-components"><a class="header" href="#feedback-components">Feedback Components</a></h1>
<p>Components for user feedback: alerts, badges, progress indicators, and toasts.</p>
<h2 id="alert"><a class="header" href="#alert">Alert</a></h2>
<p>Display important messages:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use junita_cn::prelude::*;

alert()
    .child(alert_title("Heads up!"))
    .child(alert_description("This is an important message."))
<span class="boring">}</span></code></pre>
<h3 id="alert-variants"><a class="header" href="#alert-variants">Alert Variants</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Default
alert()
    .child(alert_title("Note"))
    .child(alert_description("This is a note."))

// Destructive (error/warning)
alert()
    .variant(AlertVariant::Destructive)
    .child(alert_title("Error"))
    .child(alert_description("Something went wrong."))
<span class="boring">}</span></code></pre>
<h3 id="with-icon"><a class="header" href="#with-icon">With Icon</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>alert()
    .child(icon(icons::INFO).size(16.0))
    .child(alert_title("Information"))
    .child(alert_description("Here's some useful info."))
<span class="boring">}</span></code></pre>
<h2 id="badge"><a class="header" href="#badge">Badge</a></h2>
<p>Small labels for status or counts:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>badge("New")
badge("3").variant(BadgeVariant::Secondary)
badge("Error").variant(BadgeVariant::Destructive)
badge("Beta").variant(BadgeVariant::Outline)
<span class="boring">}</span></code></pre>
<h3 id="badge-variants"><a class="header" href="#badge-variants">Badge Variants</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Default - primary color
badge("Default")

// Secondary - muted color
badge("Secondary").variant(BadgeVariant::Secondary)

// Destructive - error/warning
badge("Destructive").variant(BadgeVariant::Destructive)

// Outline - bordered
badge("Outline").variant(BadgeVariant::Outline)
<span class="boring">}</span></code></pre>
<h3 id="with-icon-1"><a class="header" href="#with-icon-1">With Icon</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>badge("")
    .variant(BadgeVariant::Outline)
    .child(icon(icons::CHECK).size(12.0))
    .child(text("Verified"))
<span class="boring">}</span></code></pre>
<h2 id="progress"><a class="header" href="#progress">Progress</a></h2>
<p>Progress bar:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>progress()
    .value(75.0)  // 0-100
<span class="boring">}</span></code></pre>
<h3 id="indeterminate"><a class="header" href="#indeterminate">Indeterminate</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>progress()
    .indeterminate(true)
<span class="boring">}</span></code></pre>
<h3 id="with-label-1"><a class="header" href="#with-label-1">With Label</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>div()
    .flex_col()
    .gap(4.0)
    .child(
        div().flex_row().justify_between()
            .child(text("Uploading..."))
            .child(text(format!("{}%", progress_value)))
    )
    .child(progress().value(progress_value))
<span class="boring">}</span></code></pre>
<h2 id="spinner"><a class="header" href="#spinner">Spinner</a></h2>
<p>Loading indicator:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>spinner()
<span class="boring">}</span></code></pre>
<h3 id="spinner-sizes"><a class="header" href="#spinner-sizes">Spinner Sizes</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>spinner().size(SpinnerSize::Sm)   // Small
spinner().size(SpinnerSize::Md)   // Medium (default)
spinner().size(SpinnerSize::Lg)   // Large
<span class="boring">}</span></code></pre>
<h3 id="in-button"><a class="header" href="#in-button">In Button</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>button(if is_loading { "" } else { "Save" })
    .loading(is_loading)
    .disabled(is_loading)
<span class="boring">}</span></code></pre>
<h2 id="skeleton"><a class="header" href="#skeleton">Skeleton</a></h2>
<p>Placeholder for loading content:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>skeleton().w(200.0).h(20.0)
<span class="boring">}</span></code></pre>
<h3 id="card-skeleton"><a class="header" href="#card-skeleton">Card Skeleton</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>card()
    .child(card_header()
        .child(skeleton().w(150.0).h(24.0))  // Title placeholder
        .child(skeleton().w(200.0).h(16.0))) // Description placeholder
    .child(card_content()
        .child(skeleton().w_full().h(100.0))) // Content placeholder
<span class="boring">}</span></code></pre>
<h3 id="list-skeleton"><a class="header" href="#list-skeleton">List Skeleton</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>div()
    .flex_col()
    .gap(12.0)
    .child(
        div().flex_row().gap(12.0)
            .child(skeleton().w(48.0).h(48.0).rounded_full())  // Avatar
            .child(
                div().flex_col().gap(4.0)
                    .child(skeleton().w(150.0).h(16.0))  // Name
                    .child(skeleton().w(100.0).h(14.0))) // Subtitle
    )
    // Repeat for more items...
<span class="boring">}</span></code></pre>
<h2 id="toast"><a class="header" href="#toast">Toast</a></h2>
<p>Temporary notifications:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Show a toast
show_toast(
    toast()
        .title("Success")
        .description("Your changes have been saved.")
);

// With variant
show_toast(
    toast()
        .variant(ToastVariant::Destructive)
        .title("Error")
        .description("Failed to save changes.")
);
<span class="boring">}</span></code></pre>
<h3 id="toast-variants"><a class="header" href="#toast-variants">Toast Variants</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Default
toast().title("Notification")

// Success
toast()
    .variant(ToastVariant::Success)
    .title("Success")

// Destructive/Error
toast()
    .variant(ToastVariant::Destructive)
    .title("Error")
<span class="boring">}</span></code></pre>
<h3 id="with-action"><a class="header" href="#with-action">With Action</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>toast()
    .title("Event created")
    .description("Friday, February 10, 2024")
    .action(
        toast_action()
            .child(button("Undo").size(ButtonSize::Sm))
            .on_click(|| undo_action())
    )
<span class="boring">}</span></code></pre>
<h3 id="toast-position"><a class="header" href="#toast-position">Toast Position</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Configure toast container position
toaster()
    .position(ToasterPosition::TopRight)  // TopLeft, TopRight, BottomLeft, BottomRight
<span class="boring">}</span></code></pre>
<h2 id="examples-3"><a class="header" href="#examples-3">Examples</a></h2>
<h3 id="loading-state"><a class="header" href="#loading-state">Loading State</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let is_loading = use_state(true);

if is_loading {
    div()
        .flex_col()
        .items_center()
        .gap(16.0)
        .child(spinner().size(SpinnerSize::Lg))
        .child(text("Loading..."))
} else {
    // Actual content
}
<span class="boring">}</span></code></pre>
<h3 id="form-submission-feedback"><a class="header" href="#form-submission-feedback">Form Submission Feedback</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let status = use_state(FormStatus::Idle);

div()
    .flex_col()
    .gap(16.0)
    .child(/* form fields */)
    .child(
        match status {
            FormStatus::Idle =&gt; button("Submit").on_click(|| submit()),
            FormStatus::Submitting =&gt; button("").loading(true).disabled(true),
            FormStatus::Success =&gt; alert()
                .child(alert_title("Success"))
                .child(alert_description("Form submitted successfully!")),
            FormStatus::Error(msg) =&gt; alert()
                .variant(AlertVariant::Destructive)
                .child(alert_title("Error"))
                .child(alert_description(msg)),
        }
    )
<span class="boring">}</span></code></pre>
<h3 id="notification-center"><a class="header" href="#notification-center">Notification Center</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn notify_success(message: &amp;str) {
    show_toast(
        toast()
            .variant(ToastVariant::Success)
            .title("Success")
            .description(message)
            .duration(Duration::from_secs(5))
    );
}

fn notify_error(message: &amp;str) {
    show_toast(
        toast()
            .variant(ToastVariant::Destructive)
            .title("Error")
            .description(message)
            .duration(Duration::from_secs(10))
    );
}
<span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="layout-components"><a class="header" href="#layout-components">Layout Components</a></h1>
<p>Components for layout and structure: avatar, separator, accordion, and more.</p>
<h2 id="avatar"><a class="header" href="#avatar">Avatar</a></h2>
<p>User profile images with fallback:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use junita_cn::prelude::*;

avatar()
    .src("user.jpg")
    .fallback("JD")
<span class="boring">}</span></code></pre>
<h3 id="avatar-sizes"><a class="header" href="#avatar-sizes">Avatar Sizes</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>avatar().size(AvatarSize::Sm)    // 32px
avatar().size(AvatarSize::Md)    // 40px (default)
avatar().size(AvatarSize::Lg)    // 48px
avatar().size(AvatarSize::Xl)    // 64px
<span class="boring">}</span></code></pre>
<h3 id="avatar-fallback"><a class="header" href="#avatar-fallback">Avatar Fallback</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Initials fallback
avatar()
    .src("user.jpg")  // If fails to load...
    .fallback("JD")   // Show initials

// Icon fallback
avatar()
    .fallback_icon(icons::USER)
<span class="boring">}</span></code></pre>
<h3 id="avatar-group"><a class="header" href="#avatar-group">Avatar Group</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>avatar_group()
    .max(3)  // Show max 3, then "+N"
    .child(avatar().src("user1.jpg"))
    .child(avatar().src("user2.jpg"))
    .child(avatar().src("user3.jpg"))
    .child(avatar().src("user4.jpg"))
    .child(avatar().src("user5.jpg"))
// Displays: [avatar1] [avatar2] [avatar3] [+2]
<span class="boring">}</span></code></pre>
<h2 id="separator"><a class="header" href="#separator">Separator</a></h2>
<p>Visual divider:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Horizontal (default)
separator()

// Vertical
separator().orientation(Orientation::Vertical)
<span class="boring">}</span></code></pre>
<h3 id="with-label-2"><a class="header" href="#with-label-2">With Label</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>div()
    .flex_row()
    .items_center()
    .gap(8.0)
    .child(separator().flex_1())
    .child(text("or").color(Color::GRAY))
    .child(separator().flex_1())
<span class="boring">}</span></code></pre>
<h2 id="aspect-ratio"><a class="header" href="#aspect-ratio">Aspect Ratio</a></h2>
<p>Maintain aspect ratio:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>aspect_ratio(16.0 / 9.0)
    .child(img("video-thumbnail.jpg").cover())
<span class="boring">}</span></code></pre>
<h3 id="common-ratios"><a class="header" href="#common-ratios">Common Ratios</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 16:9 (video)
aspect_ratio(16.0 / 9.0)

// 4:3 (classic)
aspect_ratio(4.0 / 3.0)

// 1:1 (square)
aspect_ratio(1.0)

// 3:4 (portrait)
aspect_ratio(3.0 / 4.0)
<span class="boring">}</span></code></pre>
<h2 id="scroll-area"><a class="header" href="#scroll-area">Scroll Area</a></h2>
<p>Custom scrollbars:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>scroll_area()
    .h(400.0)
    .child(
        div()
            .flex_col()
            .gap(8.0)
            .children((0..50).map(|i| text(format!("Item {}", i))))
    )
<span class="boring">}</span></code></pre>
<h3 id="horizontal-scroll"><a class="header" href="#horizontal-scroll">Horizontal Scroll</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>scroll_area()
    .orientation(Orientation::Horizontal)
    .w(300.0)
    .child(
        div()
            .flex_row()
            .gap(8.0)
            .children((0..20).map(|i|
                card().w(150.0).child(text(format!("Card {}", i)))
            ))
    )
<span class="boring">}</span></code></pre>
<h2 id="collapsible"><a class="header" href="#collapsible">Collapsible</a></h2>
<p>Expandable content:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let is_open = use_state(false);

collapsible()
    .open(is_open)
    .on_open_change(|open| set_is_open(open))
    .child(collapsible_trigger()
        .child(
            div().flex_row().items_center().gap(8.0)
                .child(text("Show more"))
                .child(icon(if is_open { icons::CHEVRON_UP } else { icons::CHEVRON_DOWN }))
        ))
    .child(collapsible_content()
        .child(text("Hidden content that expands...")))
<span class="boring">}</span></code></pre>
<h2 id="accordion"><a class="header" href="#accordion">Accordion</a></h2>
<p>Multiple collapsible sections:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>accordion()
    .accordion_type(AccordionType::Single)  // Only one open at a time
    .child(accordion_item("item-1")
        .child(accordion_trigger()
            .child(text("Section 1")))
        .child(accordion_content()
            .child(text("Content for section 1"))))
    .child(accordion_item("item-2")
        .child(accordion_trigger()
            .child(text("Section 2")))
        .child(accordion_content()
            .child(text("Content for section 2"))))
    .child(accordion_item("item-3")
        .child(accordion_trigger()
            .child(text("Section 3")))
        .child(accordion_content()
            .child(text("Content for section 3"))))
<span class="boring">}</span></code></pre>
<h3 id="multiple-open"><a class="header" href="#multiple-open">Multiple Open</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>accordion()
    .accordion_type(AccordionType::Multiple)  // Multiple can be open
    // ... accordion items
<span class="boring">}</span></code></pre>
<h2 id="resizable"><a class="header" href="#resizable">Resizable</a></h2>
<p>Resizable panels:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>resizable()
    .direction(ResizeDirection::Horizontal)
    .child(resizable_panel()
        .default_size(30.0)  // 30%
        .min_size(20.0)
        .child(text("Left Panel")))
    .child(resizable_handle())
    .child(resizable_panel()
        .default_size(70.0)  // 70%
        .child(text("Right Panel")))
<span class="boring">}</span></code></pre>
<h3 id="vertical-resizable"><a class="header" href="#vertical-resizable">Vertical Resizable</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>resizable()
    .direction(ResizeDirection::Vertical)
    .child(resizable_panel()
        .default_size(50.0)
        .child(text("Top Panel")))
    .child(resizable_handle())
    .child(resizable_panel()
        .default_size(50.0)
        .child(text("Bottom Panel")))
<span class="boring">}</span></code></pre>
<h2 id="examples-4"><a class="header" href="#examples-4">Examples</a></h2>
<h3 id="user-list-item"><a class="header" href="#user-list-item">User List Item</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>div()
    .flex_row()
    .items_center()
    .gap(12.0)
    .p(12.0)
    .child(avatar().src(&amp;user.avatar).fallback(&amp;user.initials))
    .child(
        div().flex_col()
            .child(text(&amp;user.name).weight(FontWeight::Medium))
            .child(text(&amp;user.email).size(14.0).color(Color::GRAY))
    )
<span class="boring">}</span></code></pre>
<h3 id="faq-accordion"><a class="header" href="#faq-accordion">FAQ Accordion</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>accordion()
    .accordion_type(AccordionType::Single)
    .child(accordion_item("faq-1")
        .child(accordion_trigger()
            .child(text("How do I get started?")))
        .child(accordion_content()
            .child(text("To get started, first install the package..."))))
    .child(accordion_item("faq-2")
        .child(accordion_trigger()
            .child(text("What are the system requirements?")))
        .child(accordion_content()
            .child(text("You need Rust 1.70+ and..."))))
<span class="boring">}</span></code></pre>
<h3 id="split-pane-editor"><a class="header" href="#split-pane-editor">Split Pane Editor</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>resizable()
    .direction(ResizeDirection::Horizontal)
    .h_full()
    .child(resizable_panel()
        .default_size(25.0)
        .min_size(15.0)
        .child(sidebar()))  // File tree
    .child(resizable_handle())
    .child(resizable_panel()
        .default_size(75.0)
        .child(
            resizable()
                .direction(ResizeDirection::Vertical)
                .child(resizable_panel()
                    .default_size(70.0)
                    .child(editor()))  // Code editor
                .child(resizable_handle())
                .child(resizable_panel()
                    .default_size(30.0)
                    .child(terminal()))  // Terminal
        ))
<span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="data-display-components"><a class="header" href="#data-display-components">Data Display Components</a></h1>
<p>Components for displaying data: tooltips, popovers, hover cards, charts, and trees.</p>
<h2 id="tooltip"><a class="header" href="#tooltip">Tooltip</a></h2>
<p>Brief information on hover:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use junita_cn::prelude::*;

tooltip()
    .child(tooltip_trigger()
        .child(button("Hover me")))
    .child(tooltip_content()
        .child(text("This is a tooltip")))
<span class="boring">}</span></code></pre>
<h3 id="tooltip-position"><a class="header" href="#tooltip-position">Tooltip Position</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>tooltip()
    .side(TooltipSide::Top)     // Top (default)
    .side(TooltipSide::Bottom)  // Bottom
    .side(TooltipSide::Left)    // Left
    .side(TooltipSide::Right)   // Right
<span class="boring">}</span></code></pre>
<h3 id="with-arrow"><a class="header" href="#with-arrow">With Arrow</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>tooltip()
    .child(tooltip_trigger().child(icon(icons::INFO)))
    .child(tooltip_content()
        .with_arrow(true)
        .child(text("More information")))
<span class="boring">}</span></code></pre>
<h2 id="hover-card"><a class="header" href="#hover-card">Hover Card</a></h2>
<p>Rich content on hover:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>hover_card()
    .child(hover_card_trigger()
        .child(text("@username").color(Color::BLUE)))
    .child(hover_card_content()
        .child(
            div().flex_row().gap(12.0)
                .child(avatar().src("user.jpg").size(AvatarSize::Lg))
                .child(
                    div().flex_col().gap(4.0)
                        .child(text("John Doe").weight(FontWeight::Bold))
                        .child(text("@johndoe").color(Color::GRAY))
                        .child(text("Software developer at Acme Inc."))
                )
        ))
<span class="boring">}</span></code></pre>
<h2 id="popover"><a class="header" href="#popover">Popover</a></h2>
<p>Interactive content in a popup:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let is_open = use_state(false);

popover()
    .open(is_open)
    .on_open_change(|open| set_is_open(open))
    .child(popover_trigger()
        .child(button("Open Popover")))
    .child(popover_content()
        .child(
            div().flex_col().gap(12.0)
                .child(text("Settings").weight(FontWeight::Bold))
                .child(
                    div().flex_col().gap(8.0)
                        .child(
                            div().flex_row().justify_between()
                                .child(label("Notifications"))
                                .child(switch_())
                        )
                        .child(
                            div().flex_row().justify_between()
                                .child(label("Dark Mode"))
                                .child(switch_())
                        )
                )
        ))
<span class="boring">}</span></code></pre>
<h2 id="chart"><a class="header" href="#chart">Chart</a></h2>
<p>Data visualization:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>chart()
    .chart_type(ChartType::Line)
    .data(&amp;[
        DataPoint::new("Jan", 100.0),
        DataPoint::new("Feb", 150.0),
        DataPoint::new("Mar", 120.0),
        DataPoint::new("Apr", 180.0),
    ])
    .x_label("Month")
    .y_label("Sales")
<span class="boring">}</span></code></pre>
<h3 id="chart-types"><a class="header" href="#chart-types">Chart Types</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Line chart
chart().chart_type(ChartType::Line)

// Bar chart
chart().chart_type(ChartType::Bar)

// Area chart
chart().chart_type(ChartType::Area)

// Pie chart
chart().chart_type(ChartType::Pie)

// Histogram
chart().chart_type(ChartType::Histogram)

// Scatter plot
chart().chart_type(ChartType::Scatter)
<span class="boring">}</span></code></pre>
<h3 id="multi-series"><a class="header" href="#multi-series">Multi-Series</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>chart()
    .chart_type(ChartType::Line)
    .series("Revenue", &amp;revenue_data, Color::BLUE)
    .series("Expenses", &amp;expense_data, Color::RED)
    .series("Profit", &amp;profit_data, Color::GREEN)
    .legend(true)
<span class="boring">}</span></code></pre>
<h3 id="bar-chart"><a class="header" href="#bar-chart">Bar Chart</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>chart()
    .chart_type(ChartType::Bar)
    .data(&amp;[
        DataPoint::new("Q1", 1200.0),
        DataPoint::new("Q2", 1500.0),
        DataPoint::new("Q3", 1800.0),
        DataPoint::new("Q4", 2100.0),
    ])
    .color(Color::BLUE)
    .show_values(true)
<span class="boring">}</span></code></pre>
<h3 id="pie-chart"><a class="header" href="#pie-chart">Pie Chart</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>chart()
    .chart_type(ChartType::Pie)
    .data(&amp;[
        DataPoint::new("Desktop", 45.0),
        DataPoint::new("Mobile", 35.0),
        DataPoint::new("Tablet", 20.0),
    ])
    .show_labels(true)
    .show_percentages(true)
<span class="boring">}</span></code></pre>
<h2 id="tree"><a class="header" href="#tree">Tree</a></h2>
<p>Hierarchical data display:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>tree()
    .child(tree_item("root")
        .child(tree_item_content()
            .child(icon(icons::FOLDER))
            .child(text("Documents")))
        .child(tree_item("doc1")
            .child(tree_item_content()
                .child(icon(icons::FILE))
                .child(text("Report.pdf"))))
        .child(tree_item("doc2")
            .child(tree_item_content()
                .child(icon(icons::FILE))
                .child(text("Notes.txt")))))
<span class="boring">}</span></code></pre>
<h3 id="expandable-tree"><a class="header" href="#expandable-tree">Expandable Tree</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>tree()
    .child(tree_item("projects")
        .expandable(true)
        .expanded(true)
        .child(tree_item_trigger()
            .child(icon(icons::FOLDER))
            .child(text("Projects")))
        .child(tree_item_content()
            .child(tree_item("project1")
                .child(tree_item_trigger()
                    .child(icon(icons::FOLDER))
                    .child(text("Project A")))
                .child(tree_item_content()
                    .child(tree_item("file1")
                        .child(tree_item_content()
                            .child(icon(icons::FILE))
                            .child(text("main.rs"))))))))
<span class="boring">}</span></code></pre>
<h3 id="selectable-tree"><a class="header" href="#selectable-tree">Selectable Tree</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let selected = use_state(HashSet::new());

tree()
    .selectable(true)
    .selected(&amp;selected)
    .on_select(|ids| set_selected(ids))
    .child(/* tree items */)
<span class="boring">}</span></code></pre>
<h2 id="kbd"><a class="header" href="#kbd">Kbd</a></h2>
<p>Keyboard shortcut display:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Single key
kbd("⌘")

// Key combination
div().flex_row().gap(4.0)
    .child(kbd("⌘"))
    .child(kbd("K"))

// In context
div().flex_row().items_center().gap(8.0)
    .child(text("Search"))
    .child(
        div().flex_row().gap(2.0)
            .child(kbd("⌘"))
            .child(kbd("K"))
    )
<span class="boring">}</span></code></pre>
<h2 id="examples-5"><a class="header" href="#examples-5">Examples</a></h2>
<h3 id="user-profile-card"><a class="header" href="#user-profile-card">User Profile Card</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>hover_card()
    .child(hover_card_trigger()
        .child(
            div().flex_row().items_center().gap(8.0)
                .child(avatar().src(&amp;user.avatar).size(AvatarSize::Sm))
                .child(text(&amp;user.name))
        ))
    .child(hover_card_content()
        .w(300.0)
        .child(
            div().flex_col().gap(12.0)
                .child(
                    div().flex_row().gap(12.0)
                        .child(avatar().src(&amp;user.avatar).size(AvatarSize::Lg))
                        .child(
                            div().flex_col()
                                .child(text(&amp;user.name).weight(FontWeight::Bold))
                                .child(text(&amp;user.title).color(Color::GRAY))
                        )
                )
                .child(text(&amp;user.bio))
                .child(
                    div().flex_row().gap(16.0)
                        .child(
                            div().flex_col()
                                .child(text(&amp;user.followers.to_string()).weight(FontWeight::Bold))
                                .child(text("Followers").size(12.0).color(Color::GRAY))
                        )
                        .child(
                            div().flex_col()
                                .child(text(&amp;user.following.to_string()).weight(FontWeight::Bold))
                                .child(text("Following").size(12.0).color(Color::GRAY))
                        )
                )
        ))
<span class="boring">}</span></code></pre>
<h3 id="dashboard-chart"><a class="header" href="#dashboard-chart">Dashboard Chart</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>card()
    .child(card_header()
        .child(card_title("Revenue Overview"))
        .child(card_description("Monthly revenue for 2024")))
    .child(card_content()
        .child(
            chart()
                .chart_type(ChartType::Area)
                .h(300.0)
                .data(&amp;monthly_revenue)
                .color(Color::rgba(0.2, 0.5, 1.0, 0.5))
                .stroke_color(Color::BLUE)
                .x_label("Month")
                .y_label("Revenue ($)")
                .grid(true)
        ))
<span class="boring">}</span></code></pre>
<h3 id="file-tree"><a class="header" href="#file-tree">File Tree</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>tree()
    .child(tree_item("src")
        .expandable(true)
        .expanded(true)
        .child(tree_item_trigger()
            .child(icon(icons::FOLDER_OPEN))
            .child(text("src")))
        .child(tree_item_content()
            .child(tree_item("main")
                .on_click(|| open_file("src/main.rs"))
                .child(tree_item_content()
                    .child(icon(icons::FILE_CODE))
                    .child(text("main.rs"))))
            .child(tree_item("lib")
                .on_click(|| open_file("src/lib.rs"))
                .child(tree_item_content()
                    .child(icon(icons::FILE_CODE))
                    .child(text("lib.rs"))))))
<span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="buttons--inputs"><a class="header" href="#buttons--inputs">Buttons &amp; Inputs</a></h1>
<p>Junita provides ready-to-use input widgets with built-in state management.</p>
<h2 id="buttons"><a class="header" href="#buttons">Buttons</a></h2>
<h3 id="basic-button"><a class="header" href="#basic-button">Basic Button</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use junita_layout::widgets::button::{button, Button};

fn my_ui(ctx: &amp;WindowedContext) -&gt; impl ElementBuilder {
    let btn_state = ctx.use_state_for("save_btn", ButtonState::Idle);

    button(btn_state, "Save")
        .on_click(|_| {
            println!("Saved!");
        })
}
<span class="boring">}</span></code></pre>
<h3 id="styled-buttons"><a class="header" href="#styled-buttons">Styled Buttons</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>button(state, "Primary")
    .bg_color(Color::rgba(0.3, 0.5, 0.9, 1.0))
    .hover_color(Color::rgba(0.4, 0.6, 1.0, 1.0))
    .pressed_color(Color::rgba(0.2, 0.4, 0.8, 1.0))
    .text_color(Color::WHITE)
    .rounded(8.0)
    .p(2.0)
<span class="boring">}</span></code></pre>
<h3 id="custom-content-buttons"><a class="header" href="#custom-content-buttons">Custom Content Buttons</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Button::with_content(state, |s| {
    div()
        .flex_row()
        .gap(8.0)
        .items_center()
        .child(svg("icons/save.svg").w(16.0).h(16.0).tint(Color::WHITE))
        .child(text("Save").color(Color::WHITE))
})
.on_click(|_| save_file())
<span class="boring">}</span></code></pre>
<h3 id="disabled-buttons"><a class="header" href="#disabled-buttons">Disabled Buttons</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let state = ctx.use_state_for("btn", ButtonState::Disabled);

button(state, "Cannot Click")
    .disabled_color(Color::rgba(0.2, 0.2, 0.25, 0.5))
<span class="boring">}</span></code></pre>
<hr>
<h2 id="checkboxes"><a class="header" href="#checkboxes">Checkboxes</a></h2>
<h3 id="basic-checkbox"><a class="header" href="#basic-checkbox">Basic Checkbox</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use junita_layout::widgets::checkbox::{checkbox, checkbox_state};

fn my_ui(ctx: &amp;WindowedContext) -&gt; impl ElementBuilder {
    let state = checkbox_state(false);  // Initially unchecked

    checkbox(&amp;state)
        .on_change(|checked| {
            println!("Checkbox is now: {}", checked);
        })
}
<span class="boring">}</span></code></pre>
<h3 id="labeled-checkbox"><a class="header" href="#labeled-checkbox">Labeled Checkbox</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>checkbox(&amp;state)
    .label("Remember me")
    .label_color(Color::WHITE)
<span class="boring">}</span></code></pre>
<h3 id="styled-checkbox"><a class="header" href="#styled-checkbox">Styled Checkbox</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>checkbox(&amp;state)
    .check_color(Color::rgba(0.4, 0.6, 1.0, 1.0))
    .bg_color(Color::rgba(0.2, 0.2, 0.25, 1.0))
    .rounded(4.0)
    .size(20.0)
<span class="boring">}</span></code></pre>
<h3 id="initially-checked"><a class="header" href="#initially-checked">Initially Checked</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let state = checkbox_state(true);  // Start checked
<span class="boring">}</span></code></pre>
<hr>
<h2 id="text-input"><a class="header" href="#text-input">Text Input</a></h2>
<h3 id="basic-text-input"><a class="header" href="#basic-text-input">Basic Text Input</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use junita_layout::widgets::text_input::{text_input, text_input_state};

fn my_ui(ctx: &amp;WindowedContext) -&gt; impl ElementBuilder {
    let state = text_input_state("Enter your name...");

    text_input(&amp;state)
        .w(300.0)
        .on_change(|text| {
            println!("Input: {}", text);
        })
}
<span class="boring">}</span></code></pre>
<h3 id="styled-text-input"><a class="header" href="#styled-text-input">Styled Text Input</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>text_input(&amp;state)
    .w(300.0)
    .rounded(8.0)
    .bg_color(Color::rgba(0.15, 0.15, 0.2, 1.0))
    .text_color(Color::WHITE)
    .placeholder_color(Color::rgba(0.5, 0.5, 0.6, 1.0))
    .focus_border_color(Color::rgba(0.4, 0.6, 1.0, 1.0))
<span class="boring">}</span></code></pre>
<h3 id="reading-input-value"><a class="header" href="#reading-input-value">Reading Input Value</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let state = text_input_state("");

// Later, read the current value
let current_text = state.text();
<span class="boring">}</span></code></pre>
<hr>
<h2 id="text-area"><a class="header" href="#text-area">Text Area</a></h2>
<h3 id="basic-text-area"><a class="header" href="#basic-text-area">Basic Text Area</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use junita_layout::widgets::text_area::{text_area, text_area_state};

fn my_ui(ctx: &amp;WindowedContext) -&gt; impl ElementBuilder {
    let state = text_area_state("Enter description...");

    text_area(&amp;state)
        .w(400.0)
        .h(200.0)
        .on_change(|text| {
            println!("Content: {}", text);
        })
}
<span class="boring">}</span></code></pre>
<h3 id="styled-text-area"><a class="header" href="#styled-text-area">Styled Text Area</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>text_area(&amp;state)
    .w(400.0)
    .h(200.0)
    .rounded(8.0)
    .bg_color(Color::rgba(0.15, 0.15, 0.2, 1.0))
    .text_color(Color::WHITE)
    .font_size(14.0)
    .line_height(1.5)
<span class="boring">}</span></code></pre>
<hr>
<h2 id="code-editor"><a class="header" href="#code-editor">Code Editor</a></h2>
<h3 id="syntax-highlighted-code"><a class="header" href="#syntax-highlighted-code">Syntax Highlighted Code</a></h3>
<pre class="playground"><code class="language-rust">use junita_layout::widgets::code::code;

fn my_ui() -&gt; impl ElementBuilder {
    let source = r#"
fn main() {
    println!("Hello, Junita!");
}
"#;

    code(source)
        .lang("rust")
        .w_full()
        .h(300.0)
        .rounded(8.0)
        .font("Fira Code")
        .size(14.0)
}</code></pre>
<h3 id="supported-languages"><a class="header" href="#supported-languages">Supported Languages</a></h3>
<ul>
<li><code>rust</code>, <code>python</code>, <code>javascript</code>, <code>typescript</code></li>
<li><code>html</code>, <code>css</code>, <code>json</code>, <code>yaml</code>, <code>xml</code></li>
<li><code>sql</code>, <code>bash</code>, <code>go</code>, <code>java</code>, <code>c</code>, <code>cpp</code></li>
<li>And more…</li>
</ul>
<hr>
<h2 id="form-example"><a class="header" href="#form-example">Form Example</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn login_form(ctx: &amp;WindowedContext) -&gt; impl ElementBuilder {
    let email_state = text_input_state("Email address");
    let password_state = text_input_state("Password");
    let remember_state = checkbox_state(false);
    let submit_state = ctx.use_state_for("submit", ButtonState::Idle);

    div()
        .w(400.0)
        .p(24.0)
        .rounded(16.0)
        .bg(Color::rgba(0.12, 0.12, 0.16, 1.0))
        .flex_col()
        .gap(16.0)
        // Title
        .child(
            text("Sign In")
                .size(24.0)
                .weight(FontWeight::Bold)
                .color(Color::WHITE)
        )
        // Email field
        .child(
            div()
                .flex_col()
                .gap(4.0)
                .child(label("Email").color(Color::WHITE))
                .child(
                    text_input(&amp;email_state)
                        .w_full()
                        .rounded(8.0)
                )
        )
        // Password field
        .child(
            div()
                .flex_col()
                .gap(4.0)
                .child(label("Password").color(Color::WHITE))
                .child(
                    text_input(&amp;password_state)
                        .w_full()
                        .rounded(8.0)
                        // Note: password masking would be a feature to add
                )
        )
        // Remember me
        .child(
            checkbox(&amp;remember_state)
                .label("Remember me")
                .label_color(Color::WHITE)
        )
        // Submit button
        .child(
            button(submit_state, "Sign In")
                .w_full()
                .bg_color(Color::rgba(0.3, 0.5, 0.9, 1.0))
                .text_color(Color::WHITE)
                .rounded(8.0)
                .on_click(|_| {
                    println!("Form submitted!");
                })
        )
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="widget-state-types"><a class="header" href="#widget-state-types">Widget State Types</a></h2>
<p>Each widget uses a specific state type:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Widget</th><th>State Type</th><th>States</th></tr>
</thead>
<tbody>
<tr><td>Button</td><td><code>ButtonState</code></td><td>Idle, Hovered, Pressed, Disabled</td></tr>
<tr><td>Checkbox</td><td><code>CheckboxState</code></td><td>UncheckedIdle, UncheckedHovered, CheckedIdle, CheckedHovered</td></tr>
<tr><td>TextInput</td><td><code>TextFieldState</code></td><td>Idle, Hovered, Focused, FocusedHovered, Disabled</td></tr>
<tr><td>TextArea</td><td><code>TextFieldState</code></td><td>Same as TextInput</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="best-practices-7"><a class="header" href="#best-practices-7">Best Practices</a></h2>
<ol>
<li>
<p><strong>Use unique keys for state</strong> - Each widget needs its own state key.</p>
</li>
<li>
<p><strong>Handle validation in on_change</strong> - Validate input as users type.</p>
</li>
<li>
<p><strong>Provide visual feedback</strong> - Use colors to indicate focus and errors.</p>
</li>
<li>
<p><strong>Group related inputs</strong> - Use flex containers to organize forms.</p>
</li>
<li>
<p><strong>Add labels</strong> - Every input should have an associated label for accessibility.</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="text--rich-text"><a class="header" href="#text--rich-text">Text &amp; Rich Text</a></h1>
<p>Junita provides two main elements for displaying text: <code>text()</code> for plain text and <code>rich_text()</code> for inline-formatted text with HTML-like markup.</p>
<h2 id="plain-text"><a class="header" href="#plain-text">Plain Text</a></h2>
<p>The <code>text()</code> element is the simplest way to display text:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use junita_layout::prelude::*;

// Basic text
text("Hello, World!")

// Styled text
text("Styled text")
    .size(24.0)
    .color(Color::BLUE)
    .bold()
    .italic()

// Text with decorations
text("Underlined and struck")
    .underline()
    .strikethrough()
<span class="boring">}</span></code></pre>
<h3 id="text-properties"><a class="header" href="#text-properties">Text Properties</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Method</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>.size(f32)</code></td><td>Font size in pixels</td></tr>
<tr><td><code>.color(Color)</code></td><td>Text color</td></tr>
<tr><td><code>.bold()</code></td><td>Bold weight</td></tr>
<tr><td><code>.italic()</code></td><td>Italic style</td></tr>
<tr><td><code>.underline()</code></td><td>Underline decoration</td></tr>
<tr><td><code>.strikethrough()</code></td><td>Strikethrough decoration</td></tr>
<tr><td><code>.align(TextAlign)</code></td><td>Horizontal alignment (Left, Center, Right)</td></tr>
<tr><td><code>.v_align(TextVerticalAlign)</code></td><td>Vertical alignment (Top, Middle, Bottom)</td></tr>
<tr><td><code>.font_family(FontFamily)</code></td><td>Custom font family</td></tr>
<tr><td><code>.line_height(f32)</code></td><td>Line height multiplier (default: 1.2)</td></tr>
<tr><td><code>.wrap(bool)</code></td><td>Enable/disable text wrapping</td></tr>
</tbody>
</table>
</div>
<h2 id="rich-text"><a class="header" href="#rich-text">Rich Text</a></h2>
<p>The <code>rich_text()</code> element supports inline formatting using HTML-like tags. This is ideal for text that needs mixed styling within a single block.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use junita_layout::prelude::*;

// Basic formatting
rich_text("This has &lt;b&gt;bold&lt;/b&gt; and &lt;i&gt;italic&lt;/i&gt; text.")
    .size(16.0)
    .default_color(Color::WHITE)

// Nested tags
rich_text("&lt;b&gt;Bold with &lt;i&gt;nested italic&lt;/i&gt;&lt;/b&gt;")

// Inline colors
rich_text(r#"Colors: &lt;span color="#FF0000"&gt;red&lt;/span&gt; and &lt;span color="blue"&gt;blue&lt;/span&gt;"#)

// Links (clickable, opens in browser)
rich_text(r#"Visit &lt;a href="https://example.com"&gt;our website&lt;/a&gt; for more info."#)
<span class="boring">}</span></code></pre>
<h3 id="supported-tags"><a class="header" href="#supported-tags">Supported Tags</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Tag</th><th>Effect</th></tr>
</thead>
<tbody>
<tr><td><code>&lt;b&gt;</code>, <code>&lt;strong&gt;</code></td><td>Bold text</td></tr>
<tr><td><code>&lt;i&gt;</code>, <code>&lt;em&gt;</code></td><td>Italic text</td></tr>
<tr><td><code>&lt;u&gt;</code></td><td>Underlined text</td></tr>
<tr><td><code>&lt;s&gt;</code>, <code>&lt;strike&gt;</code>, <code>&lt;del&gt;</code></td><td>Strikethrough text</td></tr>
<tr><td><code>&lt;a href="url"&gt;</code></td><td>Clickable link (auto-underlined)</td></tr>
<tr><td><code>&lt;span color="..."&gt;</code></td><td>Inline color</td></tr>
</tbody>
</table>
</div>
<h3 id="color-formats"><a class="header" href="#color-formats">Color Formats</a></h3>
<p>The <code>&lt;span color="..."&gt;</code> tag supports multiple color formats:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Hex colors
rich_text(r#"&lt;span color="#FF0000"&gt;Red&lt;/span&gt;"#)
rich_text(r#"&lt;span color="#F00"&gt;Short hex&lt;/span&gt;"#)
rich_text(r#"&lt;span color="#FF000080"&gt;With alpha&lt;/span&gt;"#)

// Named colors (CSS subset)
rich_text(r#"&lt;span color="crimson"&gt;Crimson&lt;/span&gt;"#)
rich_text(r#"&lt;span color="steelblue"&gt;Steel Blue&lt;/span&gt;"#)

// RGB/RGBA
rich_text(r#"&lt;span color="rgb(255, 128, 0)"&gt;Orange&lt;/span&gt;"#)
<span class="boring">}</span></code></pre>
<p><strong>Supported named colors:</strong> black, white, red, green, blue, yellow, cyan, magenta, gray, silver, maroon, olive, navy, purple, teal, orange, pink, brown, lime, coral, gold, indigo, violet, crimson, salmon, tomato, skyblue, steelblue, transparent</p>
<h3 id="html-entity-decoding"><a class="header" href="#html-entity-decoding">HTML Entity Decoding</a></h3>
<p>Rich text automatically decodes common HTML entities:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>rich_text("Use &amp;lt;b&amp;gt; for bold")  // Renders: Use &lt;b&gt; for bold
rich_text("&amp;copy; 2024 &amp;bull; All Rights Reserved &amp;trade;")
rich_text("&amp;ldquo;Smart quotes&amp;rdquo; &amp;mdash; and &amp;hellip;")
<span class="boring">}</span></code></pre>
<p><strong>Supported entities:</strong> <code>&amp;lt;</code>, <code>&amp;gt;</code>, <code>&amp;amp;</code>, <code>&amp;quot;</code>, <code>&amp;apos;</code>, <code>&amp;nbsp;</code>, <code>&amp;copy;</code>, <code>&amp;reg;</code>, <code>&amp;trade;</code>, <code>&amp;mdash;</code>, <code>&amp;ndash;</code>, <code>&amp;hellip;</code>, <code>&amp;lsquo;</code>, <code>&amp;rsquo;</code>, <code>&amp;ldquo;</code>, <code>&amp;rdquo;</code>, <code>&amp;bull;</code>, <code>&amp;middot;</code>, and numeric entities (<code>&amp;#65;</code>, <code>&amp;#x41;</code>)</p>
<h3 id="range-based-api"><a class="header" href="#range-based-api">Range-Based API</a></h3>
<p>For programmatic control, use the range-based API with byte indices:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Style specific byte ranges
rich_text("Hello World")
    .bold_range(0..5)           // "Hello" is bold
    .color_range(6..11, Color::CYAN)  // "World" is cyan
    .size(18.0)
    .default_color(Color::WHITE)

// Multiple overlapping styles
rich_text("Important Notice: Please read carefully!")
    .bold_range(0..16)           // "Important Notice" bold
    .color_range(0..9, Color::ORANGE)  // "Important" orange
    .underline_range(18..39)     // "Please read carefully" underlined
<span class="boring">}</span></code></pre>
<p>Available range methods:</p>
<ul>
<li><code>.bold_range(Range&lt;usize&gt;)</code></li>
<li><code>.italic_range(Range&lt;usize&gt;)</code></li>
<li><code>.underline_range(Range&lt;usize&gt;)</code></li>
<li><code>.strikethrough_range(Range&lt;usize&gt;)</code></li>
<li><code>.color_range(Range&lt;usize&gt;, Color)</code></li>
<li><code>.link_range(Range&lt;usize&gt;, url: &amp;str)</code></li>
</ul>
<h3 id="interactive-links"><a class="header" href="#interactive-links">Interactive Links</a></h3>
<p>Links in rich text are fully interactive:</p>
<ul>
<li><strong>Click to open</strong>: Clicking a link opens the URL in the system’s default browser</li>
<li><strong>Pointer cursor</strong>: The cursor changes to a pointer when hovering over links</li>
<li><strong>Auto-underlined</strong>: Links are automatically underlined for visibility</li>
</ul>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>rich_text(r#"
    Check the &lt;a href="https://docs.example.com"&gt;documentation&lt;/a&gt;
    or view the &lt;a href="https://github.com/example"&gt;source code&lt;/a&gt;.
"#)
    .size(14.0)
    .default_color(Color::WHITE)
<span class="boring">}</span></code></pre>
<h3 id="standalone-links"><a class="header" href="#standalone-links">Standalone Links</a></h3>
<p>For simple clickable text, use the <code>link()</code> widget:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Default behavior - opens URL in browser
link("Click here", "https://example.com")

// Custom styling
link("Styled link", "https://example.com")
    .size(18.0)
    .color(Color::CYAN)
    .no_underline()

// Underline only on hover
link("Hover to see underline", "https://example.com")
    .underline_on_hover()
<span class="boring">}</span></code></pre>
<h2 id="from-styledtext"><a class="header" href="#from-styledtext">From StyledText</a></h2>
<p>For integration with syntax highlighting or markdown rendering, create rich text from a pre-built <code>StyledText</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use junita_layout::styled_text::{StyledText, StyledLine, TextSpan};

let styled = StyledText {
    lines: vec![
        StyledLine {
            text: "Hello World".to_string(),
            spans: vec![
                TextSpan {
                    start: 0,
                    end: 5,
                    bold: true,
                    color: Color::RED,
                    ..Default::default()
                },
            ],
        },
    ],
};

rich_text_styled(styled)
    .size(16.0)
    .default_color(Color::WHITE)
<span class="boring">}</span></code></pre>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<p>Here’s a complete example demonstrating various text features:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use junita_app::prelude::*;
use junita_core::Color;

fn demo_ui() -&gt; impl ElementBuilder {
    div()
        .flex_col()
        .gap(16.0)
        .p(20.0)
        // Plain text
        .child(
            text("Plain Text Example")
                .size(24.0)
                .color(Color::WHITE)
                .bold()
        )
        // Rich text with inline formatting
        .child(
            rich_text("This is &lt;b&gt;bold&lt;/b&gt;, &lt;i&gt;italic&lt;/i&gt;, and &lt;span color=\"#00FF00\"&gt;green&lt;/span&gt;.")
                .size(16.0)
                .default_color(Color::WHITE)
        )
        // Interactive link
        .child(
            rich_text(r#"Visit &lt;a href="https://github.com"&gt;GitHub&lt;/a&gt; for more."#)
                .size(16.0)
                .default_color(Color::WHITE)
        )
        // Range-based styling
        .child(
            rich_text("Programmatic styling with ranges")
                .bold_range(0..13)
                .color_range(14..21, Color::CYAN)
                .underline_range(22..32)
                .size(16.0)
                .default_color(Color::WHITE)
        )
}
<span class="boring">}</span></code></pre>
<p>Run the rich text demo to see all features in action:</p>
<pre><code class="language-bash">cargo run -p junita_app --example rich_text_demo --features windowed
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="scroll-containers"><a class="header" href="#scroll-containers">Scroll Containers</a></h1>
<p>Junita provides scroll containers with WebKit-style momentum scrolling and bounce physics.</p>
<h2 id="basic-scroll"><a class="header" href="#basic-scroll">Basic Scroll</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use junita_layout::widgets::scroll::scroll;

fn scrollable_content() -&gt; impl ElementBuilder {
    scroll()
        .h(400.0)
        .child(
            div()
                .flex_col()
                .gap(8.0)
                .child(/* ... long content ... */)
        )
}
<span class="boring">}</span></code></pre>
<h2 id="scroll-without-bounce"><a class="header" href="#scroll-without-bounce">Scroll Without Bounce</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use junita_layout::widgets::scroll::scroll_no_bounce;

scroll_no_bounce()
    .h(400.0)
    .child(content)
<span class="boring">}</span></code></pre>
<h2 id="scroll-configuration"><a class="header" href="#scroll-configuration">Scroll Configuration</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use junita_layout::widgets::scroll::{Scroll, ScrollConfig, ScrollDirection};
use junita_animation::SpringConfig;

Scroll::with_config(ScrollConfig {
    bounce_enabled: true,
    bounce_spring: SpringConfig::wobbly(),
    deceleration: 1500.0,
    velocity_threshold: 10.0,
    max_overscroll: 0.3,  // 30% of viewport
    direction: ScrollDirection::Vertical,
})
.h(400.0)
.child(content)
<span class="boring">}</span></code></pre>
<h3 id="configuration-presets"><a class="header" href="#configuration-presets">Configuration Presets</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>ScrollConfig::default()       // Standard bounce
ScrollConfig::no_bounce()     // No bounce physics
ScrollConfig::stiff_bounce()  // Tight, minimal bounce
ScrollConfig::gentle_bounce() // Soft, more bounce
<span class="boring">}</span></code></pre>
<h2 id="scroll-directions"><a class="header" href="#scroll-directions">Scroll Directions</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Vertical only (default)
Scroll::with_config(ScrollConfig {
    direction: ScrollDirection::Vertical,
    ..Default::default()
})

// Horizontal only
Scroll::with_config(ScrollConfig {
    direction: ScrollDirection::Horizontal,
    ..Default::default()
})

// Both directions
Scroll::with_config(ScrollConfig {
    direction: ScrollDirection::Both,
    ..Default::default()
})
<span class="boring">}</span></code></pre>
<h2 id="scroll-states"><a class="header" href="#scroll-states">Scroll States</a></h2>
<p>Scroll containers use <code>ScrollState</code> for physics-driven behavior:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>ScrollState::Idle         // Not scrolling
ScrollState::Scrolling    // User is dragging
ScrollState::Decelerating // Momentum after release
ScrollState::Bouncing     // Edge bounce animation
<span class="boring">}</span></code></pre>
<h2 id="example-scrollable-list"><a class="header" href="#example-scrollable-list">Example: Scrollable List</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn message_list() -&gt; impl ElementBuilder {
    scroll()
        .h(500.0)
        .w_full()
        .child(
            div()
                .flex_col()
                .gap(8.0)
                .p(16.0)
                .child(
                    (0..50).map(|i| {
                        div()
                            .p(12.0)
                            .rounded(8.0)
                            .bg(Color::rgba(0.15, 0.15, 0.2, 1.0))
                            .child(
                                text(&amp;format!("Message {}", i + 1))
                                    .color(Color::WHITE)
                            )
                    })
                )
        )
}
<span class="boring">}</span></code></pre>
<h2 id="example-horizontal-gallery"><a class="header" href="#example-horizontal-gallery">Example: Horizontal Gallery</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn image_gallery() -&gt; impl ElementBuilder {
    Scroll::with_config(ScrollConfig {
        direction: ScrollDirection::Horizontal,
        ..Default::default()
    })
    .h(200.0)
    .w_full()
    .child(
        div()
            .flex_row()
            .gap(16.0)
            .p(16.0)
            .child(
                (0..10).map(|i| {
                    div()
                        .w(150.0)
                        .h(150.0)
                        .rounded(12.0)
                        .bg(Color::rgba(0.2, 0.3, 0.5, 1.0))
                        .flex_center()
                        .child(text(&amp;format!("{}", i + 1)).size(24.0).color(Color::WHITE))
                })
            )
    )
}
<span class="boring">}</span></code></pre>
<h2 id="nested-scrolling"><a class="header" href="#nested-scrolling">Nested Scrolling</a></h2>
<p>Scroll containers handle nested scrolling automatically. Inner scrolls consume events when they can scroll; outer scrolls take over at boundaries.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn nested_scroll_example() -&gt; impl ElementBuilder {
    // Outer vertical scroll
    scroll()
        .h(600.0)
        .child(
            div()
                .flex_col()
                .gap(16.0)
                .child(text("Section 1").size(24.0))
                // Inner horizontal scroll
                .child(
                    Scroll::with_config(ScrollConfig {
                        direction: ScrollDirection::Horizontal,
                        ..Default::default()
                    })
                    .h(120.0)
                    .child(horizontal_items())
                )
                .child(text("Section 2").size(24.0))
                .child(more_content())
        )
}
<span class="boring">}</span></code></pre>
<h2 id="physics-parameters"><a class="header" href="#physics-parameters">Physics Parameters</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Parameter</th><th>Default</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>deceleration</code></td><td>1500.0</td><td>How quickly momentum decays (higher = faster stop)</td></tr>
<tr><td><code>velocity_threshold</code></td><td>10.0</td><td>Minimum velocity to continue momentum</td></tr>
<tr><td><code>max_overscroll</code></td><td>0.3</td><td>Maximum overscroll as fraction of viewport</td></tr>
<tr><td><code>bounce_spring</code></td><td>wobbly</td><td>Spring config for bounce animation</td></tr>
</tbody>
</table>
</div>
<h2 id="programmatic-scroll-control"><a class="header" href="#programmatic-scroll-control">Programmatic Scroll Control</a></h2>
<p>Junita provides a powerful selector API for programmatic scroll control through <code>ScrollRef</code>. This allows you to scroll to specific elements, positions, or the top/bottom of content.</p>
<h3 id="creating-a-scrollref"><a class="header" href="#creating-a-scrollref">Creating a ScrollRef</a></h3>
<p>Use <code>ctx.use_scroll_ref()</code> to create a persistent scroll reference:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use junita_layout::selector::{ScrollRef, ScrollOptions, ScrollBehavior, ScrollBlock};

fn my_component(ctx: &amp;WindowedContext) -&gt; impl ElementBuilder {
    // Create a ScrollRef - persists across rebuilds
    let scroll_ref = ctx.use_scroll_ref("my_scroll");

    scroll()
        .bind(&amp;scroll_ref)  // Bind the ref to this scroll container
        .child(content)
}
<span class="boring">}</span></code></pre>
<h3 id="element-ids"><a class="header" href="#element-ids">Element IDs</a></h3>
<p>Assign IDs to elements you want to scroll to:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn card_list() -&gt; impl ElementBuilder {
    div()
        .flex_col()
        .children(
            (0..10).map(|i| {
                div()
                    .id(format!("card-{}", i))  // Assign unique ID
                    .child(text(&amp;format!("Card {}", i)))
            })
        )
}
<span class="boring">}</span></code></pre>
<h3 id="scrolling-to-elements"><a class="header" href="#scrolling-to-elements">Scrolling to Elements</a></h3>
<p>Use <code>scroll_to()</code> or <code>scroll_to_with_options()</code> to scroll to an element by ID:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Simple scroll to element
scroll_ref.scroll_to("card-5");

// Scroll with options
scroll_ref.scroll_to_with_options(
    "card-5",
    ScrollOptions {
        behavior: ScrollBehavior::Smooth,  // Animate the scroll
        block: ScrollBlock::Center,        // Center element in viewport
        ..Default::default()
    },
);
<span class="boring">}</span></code></pre>
<h3 id="scrolloptions"><a class="header" href="#scrolloptions">ScrollOptions</a></h3>
<p>Configure how the scroll behaves:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>ScrollOptions {
    behavior: ScrollBehavior::Smooth,  // or ScrollBehavior::Auto (instant)
    block: ScrollBlock::Center,        // Vertical alignment
    inline: ScrollInline::Nearest,     // Horizontal alignment
}
<span class="boring">}</span></code></pre>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Block/Inline Value</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>Start</code></td><td>Align to top/left of viewport</td></tr>
<tr><td><code>Center</code></td><td>Align to center of viewport</td></tr>
<tr><td><code>End</code></td><td>Align to bottom/right of viewport</td></tr>
<tr><td><code>Nearest</code></td><td>Scroll minimum distance to make visible (default)</td></tr>
</tbody>
</table>
</div>
<h3 id="other-scroll-operations"><a class="header" href="#other-scroll-operations">Other Scroll Operations</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Scroll to top/bottom
scroll_ref.scroll_to_top();
scroll_ref.scroll_to_bottom();

// With smooth animation
scroll_ref.scroll_to_bottom_with_behavior(ScrollBehavior::Smooth);

// Scroll by relative amount
scroll_ref.scroll_by(0.0, 100.0);  // Scroll down 100px

// Set absolute offset
scroll_ref.set_scroll_offset(0.0, 500.0);
<span class="boring">}</span></code></pre>
<h3 id="querying-scroll-state"><a class="header" href="#querying-scroll-state">Querying Scroll State</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Current offset
let (x, y) = scroll_ref.offset();
let y = scroll_ref.scroll_y();

// Content and viewport sizes
let content_size = scroll_ref.content_size();
let viewport_size = scroll_ref.viewport_size();

// Position checks
if scroll_ref.is_at_top() { /* ... */ }
if scroll_ref.is_at_bottom() { /* ... */ }

// Scroll progress (0.0 = top, 1.0 = bottom)
let progress = scroll_ref.scroll_progress();
<span class="boring">}</span></code></pre>
<h3 id="example-carousel-with-dot-navigation"><a class="header" href="#example-carousel-with-dot-navigation">Example: Carousel with Dot Navigation</a></h3>
<p>Here’s a complete example of a horizontal carousel with clickable navigation dots:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use junita_app::prelude::*;
use junita_layout::selector::{ScrollBehavior, ScrollBlock, ScrollOptions, ScrollRef};
use junita_layout::units::px;  // Semantic unit for raw pixels

fn carousel(ctx: &amp;WindowedContext) -&gt; impl ElementBuilder {
    let scroll_ref = ctx.use_scroll_ref("carousel_scroll");
    let current_index = ctx.use_state_keyed("current_index", || 0usize);

    div()
        .flex_col()
        .items_center()
        .gap(16.0)
        // Horizontal scroll carousel
        .child(
            scroll()
                .bind(&amp;scroll_ref)
                .direction(ScrollDirection::Horizontal)
                .w(400.0)
                .h(300.0)
                .child(
                    div()
                        .flex_row()
                        .gap(20.0)
                        .padding_x(px(60.0))  // Padding to center first/last cards
                        .children(
                            (0..5).map(|i| {
                                div()
                                    .id(format!("card-{}", i))  // Element ID
                                    .w(280.0)
                                    .h(280.0)
                                    .bg(Color::rgba(0.2, 0.3, 0.5, 1.0))
                                    .rounded(16.0)
                                    .child(text(&amp;format!("Card {}", i + 1)))
                            })
                        ),
                ),
        )
        // Navigation dots
        .child(build_dots(ctx, &amp;scroll_ref, &amp;current_index))
}

fn build_dots(
    ctx: &amp;WindowedContext,
    scroll_ref: &amp;ScrollRef,
    current_index: &amp;State&lt;usize&gt;,
) -&gt; impl ElementBuilder {
    div()
        .flex_row()
        .gap(12.0)
        .children(
            (0..5).map(|i| {
                let scroll_ref = scroll_ref.clone();
                let current_index = current_index.clone();

                div()
                    .w(12.0)
                    .h(12.0)
                    .rounded(6.0)
                    .bg(if i == current_index.get() {
                        Color::rgba(0.4, 0.6, 1.0, 1.0)
                    } else {
                        Color::rgba(0.3, 0.3, 0.4, 1.0)
                    })
                    .on_click(move |_| {
                        current_index.set(i);
                        scroll_ref.scroll_to_with_options(
                            &amp;format!("card-{}", i),
                            ScrollOptions {
                                behavior: ScrollBehavior::Smooth,
                                block: ScrollBlock::Center,
                                ..Default::default()
                            },
                        );
                    })
            })
        )
}
<span class="boring">}</span></code></pre>
<h2 id="best-practices-8"><a class="header" href="#best-practices-8">Best Practices</a></h2>
<ol>
<li>
<p><strong>Set explicit height</strong> - Scroll containers need a bounded height to work.</p>
</li>
<li>
<p><strong>Use overflow_clip on parent</strong> - Ensure parent clips overflowing content.</p>
</li>
<li>
<p><strong>Prefer vertical for long content</strong> - Horizontal scrolling is less intuitive for lists.</p>
</li>
<li>
<p><strong>Consider no-bounce for forms</strong> - Disable bounce for content that needs precise positioning.</p>
</li>
<li>
<p><strong>Test nested scrolling</strong> - Verify inner/outer scroll interactions work as expected.</p>
</li>
<li>
<p><strong>Use meaningful element IDs</strong> - Choose descriptive IDs like <code>"message-123"</code> or <code>"section-intro"</code> for elements you need to scroll to.</p>
</li>
<li>
<p><strong>Prefer <code>ctx.use_scroll_ref()</code></strong> - Always use the context method rather than <code>ScrollRef::new()</code> for proper reactive integration.</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="canvas-drawing"><a class="header" href="#canvas-drawing">Canvas Drawing</a></h1>
<p>The <code>canvas()</code> element provides direct GPU drawing access for custom graphics, charts, and procedural content.</p>
<h2 id="basic-usage-8"><a class="header" href="#basic-usage-8">Basic Usage</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use junita_core::{DrawContext, Rect, Brush, Color, CornerRadius};

canvas(|ctx: &amp;mut dyn DrawContext, bounds| {
    // bounds contains the canvas size
    ctx.fill_rect(
        Rect::new(0.0, 0.0, bounds.width, bounds.height),
        CornerRadius::uniform(8.0),
        Brush::Solid(Color::RED),
    );
})
.w(200.0)
.h(100.0)
<span class="boring">}</span></code></pre>
<h2 id="drawing-primitives"><a class="header" href="#drawing-primitives">Drawing Primitives</a></h2>
<h3 id="filled-rectangles"><a class="header" href="#filled-rectangles">Filled Rectangles</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>ctx.fill_rect(
    Rect::new(x, y, width, height),
    CornerRadius::uniform(8.0),  // Corner radius
    Brush::Solid(Color::BLUE),
);

// No corner radius
ctx.fill_rect(
    Rect::new(10.0, 10.0, 100.0, 50.0),
    CornerRadius::default(),
    Brush::Solid(Color::GREEN),
);
<span class="boring">}</span></code></pre>
<h3 id="stroked-rectangles"><a class="header" href="#stroked-rectangles">Stroked Rectangles</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>ctx.stroke_rect(
    Rect::new(x, y, width, height),
    CornerRadius::uniform(4.0),
    2.0,  // Stroke width
    Brush::Solid(Color::WHITE),
);
<span class="boring">}</span></code></pre>
<h3 id="circles"><a class="header" href="#circles">Circles</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Filled circle
ctx.fill_circle(
    Point::new(cx, cy),  // Center
    radius,
    Brush::Solid(Color::BLUE),
);

// Stroked circle
ctx.stroke_circle(
    Point::new(cx, cy),
    radius,
    2.0,  // Stroke width
    Brush::Solid(Color::WHITE),
);
<span class="boring">}</span></code></pre>
<h3 id="text"><a class="header" href="#text">Text</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use junita_core::TextStyle;

ctx.draw_text(
    "Hello, Canvas!",
    Point::new(x, y),
    &amp;TextStyle::new(16.0).with_color(Color::WHITE),
);
<span class="boring">}</span></code></pre>
<h2 id="gradients-2"><a class="header" href="#gradients-2">Gradients</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use junita_core::{Gradient, GradientStop, Point};

// Linear gradient
let gradient = Brush::Gradient(Gradient::linear(
    Point::new(0.0, 0.0),      // Start
    Point::new(200.0, 0.0),    // End
    Color::rgba(0.9, 0.2, 0.5, 1.0),
    Color::rgba(0.2, 0.8, 0.6, 1.0),
));

ctx.fill_rect(
    Rect::new(0.0, 0.0, 200.0, 100.0),
    CornerRadius::default(),
    gradient,
);

// Multi-stop gradient
let gradient = Brush::Gradient(Gradient::linear_with_stops(
    Point::new(0.0, 0.0),
    Point::new(200.0, 0.0),
    vec![
        GradientStop::new(0.0, Color::RED),
        GradientStop::new(0.5, Color::YELLOW),
        GradientStop::new(1.0, Color::GREEN),
    ],
));
<span class="boring">}</span></code></pre>
<h2 id="transforms-1"><a class="header" href="#transforms-1">Transforms</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use junita_core::Transform;

// Push transform
ctx.push_transform(Transform::translate(50.0, 50.0));

// Draw in transformed space
ctx.fill_rect(/* ... */);

// Pop transform
ctx.pop_transform();

// Rotation
ctx.push_transform(Transform::rotate(angle_radians));
// ... draw ...
ctx.pop_transform();

// Scale
ctx.push_transform(Transform::scale(2.0, 2.0));
// ... draw ...
ctx.pop_transform();
<span class="boring">}</span></code></pre>
<h2 id="clipping"><a class="header" href="#clipping">Clipping</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Push clip region
ctx.push_clip(Rect::new(10.0, 10.0, 100.0, 100.0));

// Only content within clip region is visible
ctx.fill_rect(/* ... */);

// Pop clip
ctx.pop_clip();
<span class="boring">}</span></code></pre>
<h2 id="example-animated-spinner"><a class="header" href="#example-animated-spinner">Example: Animated Spinner</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::f32::consts::PI;

fn spinner(ctx: &amp;WindowedContext) -&gt; impl ElementBuilder {
    let timeline = ctx.use_animated_timeline();

    let entry_id = timeline.lock().unwrap().configure(|t| {
        let id = t.add(0, 1000, 0.0, 360.0);
        t.set_loop(-1);
        t.start();
        id
    });

    let render_timeline = Arc::clone(&amp;timeline);

    canvas(move |draw_ctx, bounds| {
        let angle_deg = render_timeline.lock().unwrap().get(entry_id).unwrap_or(0.0);
        let angle_rad = angle_deg * PI / 180.0;

        let cx = bounds.width / 2.0;
        let cy = bounds.height / 2.0;
        let radius = 30.0;

        // Draw spinning segments
        for i in 0..8 {
            let segment_angle = angle_rad + (i as f32 * PI / 4.0);
            let alpha = 1.0 - (i as f32 * 0.1);

            let x = cx + segment_angle.cos() * radius;
            let y = cy + segment_angle.sin() * radius;

            draw_ctx.fill_circle(
                Point::new(x, y),
                4.0,
                Brush::Solid(Color::rgba(0.4, 0.6, 1.0, alpha)),
            );
        }
    })
    .w(80.0)
    .h(80.0)
}
<span class="boring">}</span></code></pre>
<h2 id="example-progress-ring"><a class="header" href="#example-progress-ring">Example: Progress Ring</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn progress_ring(progress: f32) -&gt; impl ElementBuilder {
    canvas(move |ctx, bounds| {
        let cx = bounds.width / 2.0;
        let cy = bounds.height / 2.0;
        let radius = bounds.width.min(bounds.height) / 2.0 - 4.0;

        // Background ring
        ctx.stroke_circle(
            Point::new(cx, cy),
            radius,
            4.0,
            Brush::Solid(Color::rgba(0.2, 0.2, 0.25, 1.0)),
        );

        // Progress arc (simplified - actual arc drawing would need path API)
        // For now, draw segments
        let segments = 32;
        let filled = (segments as f32 * progress) as i32;

        for i in 0..filled {
            let angle = (i as f32 / segments as f32) * 2.0 * PI - PI / 2.0;
            let x = cx + angle.cos() * radius;
            let y = cy + angle.sin() * radius;

            ctx.fill_circle(
                Point::new(x, y),
                3.0,
                Brush::Solid(Color::rgba(0.4, 0.6, 1.0, 1.0)),
            );
        }

        // Center text
        ctx.draw_text(
            &amp;format!("{}%", (progress * 100.0) as i32),
            Point::new(cx - 15.0, cy + 6.0),
            &amp;TextStyle::new(16.0).with_color(Color::WHITE),
        );
    })
    .w(80.0)
    .h(80.0)
}
<span class="boring">}</span></code></pre>
<h2 id="example-color-palette"><a class="header" href="#example-color-palette">Example: Color Palette</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn color_palette() -&gt; impl ElementBuilder {
    canvas(|ctx, bounds| {
        let cols = 8;
        let rows = 3;
        let cell_w = bounds.width / cols as f32;
        let cell_h = bounds.height / rows as f32;

        for row in 0..rows {
            for col in 0..cols {
                let hue = col as f32 / cols as f32;
                let sat = 1.0 - (row as f32 * 0.25);
                let color = hsv_to_rgb(hue, sat, 0.9);

                ctx.fill_rect(
                    Rect::new(
                        col as f32 * cell_w,
                        row as f32 * cell_h,
                        cell_w - 2.0,
                        cell_h - 2.0,
                    ),
                    CornerRadius::uniform(4.0),
                    Brush::Solid(color),
                );
            }
        }
    })
    .w(240.0)
    .h(90.0)
}
<span class="boring">}</span></code></pre>
<h2 id="best-practices-9"><a class="header" href="#best-practices-9">Best Practices</a></h2>
<ol>
<li>
<p><strong>Set explicit size</strong> - Canvas needs width and height to render.</p>
</li>
<li>
<p><strong>Use bounds parameter</strong> - Draw relative to <code>bounds.width</code> and <code>bounds.height</code>.</p>
</li>
<li>
<p><strong>Clone Arcs for closures</strong> - Animation values need <code>Arc::clone()</code> before the render closure.</p>
</li>
<li>
<p><strong>Push/pop transforms</strong> - Always pop what you push to avoid state leaks.</p>
</li>
<li>
<p><strong>Prefer elements when possible</strong> - Use <code>div()</code>, <code>text()</code> for standard UI; canvas for custom graphics.</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="images--svg"><a class="header" href="#images--svg">Images &amp; SVG</a></h1>
<p>Junita supports raster images and SVG graphics with flexible sizing and styling options.</p>
<h2 id="images"><a class="header" href="#images">Images</a></h2>
<h3 id="basic-image"><a class="header" href="#basic-image">Basic Image</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use junita_layout::image::image;

image("path/to/photo.png")
    .w(200.0)
    .h(150.0)
<span class="boring">}</span></code></pre>
<h3 id="image-from-url"><a class="header" href="#image-from-url">Image from URL</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>image("https://example.com/image.jpg")
    .w(300.0)
    .h(200.0)
<span class="boring">}</span></code></pre>
<h3 id="object-fit"><a class="header" href="#object-fit">Object Fit</a></h3>
<p>Control how the image fills its container:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>image(src)
    .w(200.0)
    .h(200.0)
    .cover()      // Fill container, crop if needed (default)

image(src)
    .contain()    // Fit entirely, may letterbox

image(src)
    .fill()       // Stretch to fill exactly

image(src)
    .scale_down() // Scale down only if larger

image(src)
    .no_scale()   // No scaling, original size
<span class="boring">}</span></code></pre>
<h3 id="object-position"><a class="header" href="#object-position">Object Position</a></h3>
<p>Control alignment within the container:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>image(src)
    .cover()
    .center()         // Center (default)

image(src)
    .cover()
    .top_left()

image(src)
    .cover()
    .top_center()

image(src)
    .cover()
    .bottom_right()

// Custom position (0.0 to 1.0)
image(src)
    .cover()
    .position_xy(0.25, 0.75)
<span class="boring">}</span></code></pre>
<h3 id="image-filters"><a class="header" href="#image-filters">Image Filters</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>image(src)
    .w(200.0)
    .h(200.0)
    .grayscale(0.5)      // 0.0 = color, 1.0 = grayscale
    .sepia(0.3)          // Sepia tone
    .brightness(1.2)     // &gt; 1.0 brighter, &lt; 1.0 darker
    .contrast(1.1)       // &gt; 1.0 more contrast
    .saturate(0.8)       // &lt; 1.0 less saturated
    .hue_rotate(45.0)    // Rotate hue (degrees)
    .invert(0.2)         // Color inversion
    .blur(2.0)           // Blur radius
<span class="boring">}</span></code></pre>
<h3 id="lazy-loading"><a class="header" href="#lazy-loading">Lazy Loading</a></h3>
<p>For content-heavy applications with many images (galleries, feeds, chat apps), lazy loading defers image loading until the image is visible in the viewport. This reduces initial memory usage and load time.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use junita_layout::prelude::*;
use std::time::Duration;

// Basic lazy loading
img("large-photo.jpg")
    .lazy()
    .w(300.0)
    .h(200.0)

// With placeholder color
img("photo.jpg")
    .lazy()
    .placeholder_color(Color::rgba(0.2, 0.2, 0.2, 1.0))
    .w(300.0)
    .h(200.0)

// With gradient placeholder using Brush
img("photo.jpg")
    .lazy()
    .placeholder_brush(Brush::Gradient(Gradient::linear(
        Point::new(0.0, 0.0),
        Point::new(1.0, 1.0),
        Color::rgba(0.4, 0.6, 1.0, 1.0),
        Color::rgba(0.6, 0.4, 1.0, 1.0),
    )))
    .w(300.0)
    .h(200.0)

// With thumbnail placeholder
img("large-photo.jpg")
    .lazy()
    .placeholder_image("thumbnail.jpg")
    .fade_in(Duration::from_millis(300))
    .w(300.0)
    .h(200.0)

// Skeleton loading animation
img("photo.jpg")
    .lazy()
    .skeleton()
    .fade_in(Duration::from_millis(250))
    .w(300.0)
    .h(200.0)

// Disable fade animation
img("photo.jpg")
    .lazy()
    .no_fade()
    .w(300.0)
    .h(200.0)
<span class="boring">}</span></code></pre>
<h4 id="loading-strategies"><a class="header" href="#loading-strategies">Loading Strategies</a></h4>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Strategy</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>Eager</code> (default)</td><td>Load immediately when element is created</td></tr>
<tr><td><code>Lazy</code></td><td>Load only when visible in viewport</td></tr>
</tbody>
</table>
</div>
<h4 id="placeholder-types"><a class="header" href="#placeholder-types">Placeholder Types</a></h4>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Placeholder</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>None</code></td><td>No placeholder (blank until loaded)</td></tr>
<tr><td><code>Color(color)</code></td><td>Solid color background</td></tr>
<tr><td><code>Brush(brush)</code></td><td>Any brush (gradient, glass effect, etc.)</td></tr>
<tr><td><code>Image(url)</code></td><td>Another image (e.g., low-res thumbnail, blur hash)</td></tr>
<tr><td><code>Skeleton</code></td><td>Shimmer loading animation</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="emoji-images"><a class="header" href="#emoji-images">Emoji Images</a></h2>
<p>Render emoji as images at arbitrary sizes using the system emoji font. Emoji images are <strong>automatically lazy-loaded</strong> for memory efficiency.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use junita_layout::image::{emoji, emoji_sized};

// Default size (64px)
emoji("😀")

// Custom size
emoji_sized("🚀", 128.0)

// In a layout
div()
    .flex_row()
    .gap(8.0)
    .child(emoji_sized("👍", 32.0))
    .child(emoji_sized("🎉", 32.0))
    .child(emoji_sized("✨", 32.0))
<span class="boring">}</span></code></pre>
<p>Emoji images use the system color emoji font (Apple Color Emoji on macOS, Segoe UI Emoji on Windows, Noto Color Emoji on Linux).</p>
<hr>
<h2 id="svg"><a class="header" href="#svg">SVG</a></h2>
<h3 id="basic-svg"><a class="header" href="#basic-svg">Basic SVG</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use junita_layout::svg::svg;

svg("icons/menu.svg")
    .w(24.0)
    .h(24.0)
<span class="boring">}</span></code></pre>
<h3 id="svg-with-tint"><a class="header" href="#svg-with-tint">SVG with Tint</a></h3>
<p>Apply a color tint to monochrome SVGs:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>svg("icons/settings.svg")
    .w(24.0)
    .h(24.0)
    .tint(Color::WHITE)

svg("icons/error.svg")
    .w(20.0)
    .h(20.0)
    .tint(Color::rgba(0.9, 0.3, 0.3, 1.0))
<span class="boring">}</span></code></pre>
<h3 id="svg-sizing"><a class="header" href="#svg-sizing">SVG Sizing</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Fixed size
svg(src).w(32.0).h(32.0)

// Square shorthand
svg(src).square(24.0)

// Aspect ratio preserved
svg(src).w(48.0).h_auto()
<span class="boring">}</span></code></pre>
<hr>
<h2 id="common-patterns"><a class="header" href="#common-patterns">Common Patterns</a></h2>
<h3 id="avatar-image"><a class="header" href="#avatar-image">Avatar Image</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn avatar(url: &amp;str, size: f32) -&gt; impl ElementBuilder {
    image(url)
        .w(size)
        .h(size)
        .cover()
        .rounded_full()  // Circular
}
<span class="boring">}</span></code></pre>
<h3 id="icon-button-1"><a class="header" href="#icon-button-1">Icon Button</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use junita_layout::stateful::stateful;

fn icon_button(ctx: &amp;WindowedContext, icon_path: &amp;str) -&gt; impl ElementBuilder {
    // Use use_state_for with icon_path as key for reusable component
    let handle = ctx.use_state_for(icon_path, ButtonState::Idle);

    stateful(handle)
        .w(40.0)
        .h(40.0)
        .rounded(8.0)
        .flex_center()
        .on_state(|state, div| {
            let bg = match state {
                ButtonState::Idle =&gt; Color::TRANSPARENT,
                ButtonState::Hovered =&gt; Color::rgba(0.2, 0.2, 0.25, 1.0),
                ButtonState::Pressed =&gt; Color::rgba(0.15, 0.15, 0.2, 1.0),
                _ =&gt; Color::TRANSPARENT,
            };
            div.set_bg(bg);
        })
        .child(
            svg(icon_path)
                .w(20.0)
                .h(20.0)
                .tint(Color::WHITE)
        )
}
<span class="boring">}</span></code></pre>
<h3 id="image-card"><a class="header" href="#image-card">Image Card</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn image_card(image_url: &amp;str, title: &amp;str) -&gt; impl ElementBuilder {
    div()
        .w(300.0)
        .rounded(12.0)
        .overflow_clip()
        .bg(Color::rgba(0.15, 0.15, 0.2, 1.0))
        .child(
            image(image_url)
                .w_full()
                .h(180.0)
                .cover()
        )
        .child(
            div()
                .p(16.0)
                .child(
                    text(title)
                        .size(18.0)
                        .weight(FontWeight::SemiBold)
                        .color(Color::WHITE)
                )
        )
}
<span class="boring">}</span></code></pre>
<h3 id="gallery-grid"><a class="header" href="#gallery-grid">Gallery Grid</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn gallery(images: &amp;[&amp;str]) -&gt; impl ElementBuilder {
    div()
        .flex_row()
        .flex_wrap()
        .gap(8.0)
        .child(
            images.iter().map(|url| {
                image(*url)
                    .w(150.0)
                    .h(150.0)
                    .cover()
                    .rounded(8.0)
            })
        )
}
<span class="boring">}</span></code></pre>
<h3 id="placeholder-with-fallback"><a class="header" href="#placeholder-with-fallback">Placeholder with Fallback</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn image_with_placeholder(url: Option&lt;&amp;str&gt;) -&gt; impl ElementBuilder {
    match url {
        Some(src) =&gt; image(src)
            .w(200.0)
            .h(200.0)
            .cover()
            .rounded(8.0),
        None =&gt; div()
            .w(200.0)
            .h(200.0)
            .rounded(8.0)
            .bg(Color::rgba(0.2, 0.2, 0.25, 1.0))
            .flex_center()
            .child(
                svg("icons/image-placeholder.svg")
                    .w(48.0)
                    .h(48.0)
                    .tint(Color::rgba(0.4, 0.4, 0.5, 1.0))
            ),
    }
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="supported-formats"><a class="header" href="#supported-formats">Supported Formats</a></h2>
<h3 id="images-1"><a class="header" href="#images-1">Images</a></h3>
<ul>
<li>PNG</li>
<li>JPEG</li>
<li>WebP</li>
<li>GIF (first frame)</li>
<li>BMP</li>
<li>ICO</li>
</ul>
<h3 id="svg-1"><a class="header" href="#svg-1">SVG</a></h3>
<ul>
<li>Standard SVG 1.1</li>
<li>Path elements</li>
<li>Basic shapes (rect, circle, ellipse, line, polyline, polygon)</li>
<li>Transforms</li>
<li>Fill and stroke</li>
</ul>
<hr>
<h2 id="best-practices-10"><a class="header" href="#best-practices-10">Best Practices</a></h2>
<ol>
<li>
<p><strong>Set explicit dimensions</strong> - Images need width and height for layout.</p>
</li>
<li>
<p><strong>Use <code>cover</code> for photos</strong> - Fills container nicely without distortion.</p>
</li>
<li>
<p><strong>Use <code>contain</code> for diagrams</strong> - Ensures nothing is cropped.</p>
</li>
<li>
<p><strong>Tint icons</strong> - Use <code>.tint()</code> to match your color scheme.</p>
</li>
<li>
<p><strong>Use SVG for icons</strong> - Scales perfectly at any size.</p>
</li>
<li>
<p><strong>Optimize images</strong> - Use appropriate formats and compression for web.</p>
</li>
<li>
<p><strong>Use lazy loading for galleries</strong> - In scroll containers with many images, use <code>.lazy()</code> to reduce memory usage and improve initial load time.</p>
</li>
<li>
<p><strong>Use emoji images for large emoji</strong> - For emoji larger than ~24px, use <code>emoji_sized()</code> instead of text for crisp rendering.</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="markdown-rendering"><a class="header" href="#markdown-rendering">Markdown Rendering</a></h1>
<p>Junita includes a built-in markdown renderer that converts CommonMark + GFM markdown to native layout elements.</p>
<h2 id="basic-usage-9"><a class="header" href="#basic-usage-9">Basic Usage</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use junita_layout::markdown::markdown;

// Render markdown to a Div
let content = markdown(r#"
<span class="boring">Hello World
</span>
This is **bold** and *italic* text.

- List item 1
- List item 2
"#);

// Use in your layout
div()
    .flex_col()
    .child(content)
<span class="boring">}</span></code></pre>
<h2 id="themes"><a class="header" href="#themes">Themes</a></h2>
<p>The renderer supports light and dark themes:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use junita_layout::markdown::{markdown, markdown_light, markdown_with_config, MarkdownConfig};

// Dark theme (default) - for dark backgrounds
let dark_content = markdown("# Dark Theme");

// Light theme - for white/light backgrounds
let light_content = markdown_light("# Light Theme");

// Custom configuration
let custom = markdown_with_config("# Custom", MarkdownConfig {
    h1_size: 36.0,
    body_size: 16.0,
    ..MarkdownConfig::default()
});
<span class="boring">}</span></code></pre>
<h2 id="supported-elements"><a class="header" href="#supported-elements">Supported Elements</a></h2>
<h3 id="text-formatting"><a class="header" href="#text-formatting">Text Formatting</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Markdown</th><th>Result</th></tr>
</thead>
<tbody>
<tr><td><code>**bold**</code></td><td><strong>bold</strong> text</td></tr>
<tr><td><code>*italic*</code></td><td><em>italic</em> text</td></tr>
<tr><td><code>~~strikethrough~~</code></td><td><del>strikethrough</del> text</td></tr>
<tr><td><code>`inline code`</code></td><td>inline code</td></tr>
<tr><td><code>[link](url)</code></td><td>clickable link</td></tr>
</tbody>
</table>
</div>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>markdown(r#"
This is **bold**, *italic*, and ~~strikethrough~~ text.

Here's some `inline code` and a [link](https://example.com).
"#)
<span class="boring">}</span></code></pre>
<h3 id="headings"><a class="header" href="#headings">Headings</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>markdown(r#"
<span class="boring">Heading 1
</span># Heading 2
## Heading 3
### Heading 4
#### Heading 5
##### Heading 6
"#)
<span class="boring">}</span></code></pre>
<h3 id="lists"><a class="header" href="#lists">Lists</a></h3>
<p>Unordered lists:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>markdown(r#"
- First item
- Second item
  - Nested item
  - Another nested
- Third item
"#)
<span class="boring">}</span></code></pre>
<p>Ordered lists:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>markdown(r#"
1. First step
2. Second step
3. Third step
"#)
<span class="boring">}</span></code></pre>
<p>Task lists (GFM extension):</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>markdown(r#"
- [x] Completed task
- [ ] Pending task
- [x] Another done
"#)
<span class="boring">}</span></code></pre>
<h3 id="code-blocks"><a class="header" href="#code-blocks">Code Blocks</a></h3>
<p>Fenced code blocks with optional language:</p>
<pre class="playground"><code class="language-rust">markdown(r#"
```rust
fn main() {
    println!("Hello, Junita!");
}</code></pre>
<p>“#)</p>
<pre><code>
Supported languages for syntax highlighting include Rust, Python, JavaScript, TypeScript, and more.

### Blockquotes

```rust
markdown(r#"
&gt; This is a blockquote.
&gt; It can span multiple lines.
&gt;
&gt; And have multiple paragraphs.
"#)
</code></pre>
<h3 id="tables-gfm"><a class="header" href="#tables-gfm">Tables (GFM)</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>markdown(r#"
| Header 1 | Header 2 | Header 3 |
|----------|----------|----------|
| Cell 1   | Cell 2   | Cell 3   |
| Cell 4   | Cell 5   | Cell 6   |
"#)
<span class="boring">}</span></code></pre>
<h3 id="horizontal-rules"><a class="header" href="#horizontal-rules">Horizontal Rules</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>markdown(r#"
Content above

---

Content below
"#)
<span class="boring">}</span></code></pre>
<h3 id="images-2"><a class="header" href="#images-2">Images</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>markdown(r#"
![Alt text](path/to/image.png)

![Remote image](https://example.com/photo.jpg)
"#)
<span class="boring">}</span></code></pre>
<h2 id="configuration-1"><a class="header" href="#configuration-1">Configuration</a></h2>
<p>Customize the renderer with <code>MarkdownConfig</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use junita_layout::markdown::{markdown_with_config, MarkdownConfig};
use junita_core::Color;

let config = MarkdownConfig {
    // Typography sizes
    h1_size: 32.0,
    h2_size: 28.0,
    h3_size: 24.0,
    h4_size: 20.0,
    h5_size: 18.0,
    h6_size: 16.0,
    body_size: 16.0,
    code_size: 14.0,

    // Colors
    text_color: Color::WHITE,
    heading_color: Color::WHITE,
    link_color: Color::rgba(0.4, 0.6, 1.0, 1.0),
    code_bg: Color::rgba(0.1, 0.1, 0.12, 1.0),
    code_text: Color::rgba(0.9, 0.6, 0.3, 1.0),

    // Spacing
    paragraph_spacing: 16.0,
    heading_margin_top: 24.0,
    heading_margin_bottom: 12.0,

    // Lists
    list_indent: 24.0,
    list_item_spacing: 4.0,

    ..Default::default()
};

let content = markdown_with_config("# Custom Styled", config);
<span class="boring">}</span></code></pre>
<h3 id="preset-themes"><a class="header" href="#preset-themes">Preset Themes</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Dark theme (default) - white text on dark backgrounds
let dark = MarkdownConfig::default();

// Light theme - dark text on light backgrounds
let light = MarkdownConfig::light();
<span class="boring">}</span></code></pre>
<h2 id="live-editor-example"><a class="header" href="#live-editor-example">Live Editor Example</a></h2>
<p>A full markdown editor with live preview is available in the examples:</p>
<pre><code class="language-bash">cargo run -p junita_app --example markdown_demo --features windowed
</code></pre>
<p>This demonstrates:</p>
<ul>
<li>TextArea for markdown source editing</li>
<li>Live preview with <code>markdown_light()</code></li>
<li>Stateful reactive updates on text change</li>
</ul>
<h2 id="html-entities"><a class="header" href="#html-entities">HTML Entities</a></h2>
<p>The renderer automatically decodes HTML entities in text:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>markdown(r#"
&amp;copy; 2025 &amp;mdash; All rights reserved

Temperature: 72&amp;deg;F

Price: &amp;euro;99.99
"#)
<span class="boring">}</span></code></pre>
<p>Common entities: <code>&amp;amp;</code> (<code>&amp;</code>), <code>&amp;lt;</code> (<code>&lt;</code>), <code>&amp;gt;</code> (<code>&gt;</code>), <code>&amp;quot;</code> (<code>"</code>), <code>&amp;nbsp;</code> (non-breaking space), <code>&amp;copy;</code> (<code>©</code>), <code>&amp;trade;</code> (<code>™</code>), and many more.</p>
<h2 id="best-practices-11"><a class="header" href="#best-practices-11">Best Practices</a></h2>
<ol>
<li>
<p><strong>Use <code>markdown_light()</code> for light backgrounds</strong> - The default theme assumes dark backgrounds.</p>
</li>
<li>
<p><strong>Wrap in scroll for long content</strong> - Markdown can produce tall content:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>scroll()
    .h(600.0)
    .direction(ScrollDirection::Vertical)
    .child(markdown(long_content))
<span class="boring">}</span></code></pre>
</li>
<li>
<p><strong>Set container width</strong> - Markdown content respects parent width:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>div()
    .w(800.0)
    .child(markdown(content))
<span class="boring">}</span></code></pre>
</li>
<li>
<p><strong>Code blocks need height</strong> - For syntax highlighting to render properly, ensure the container has adequate height.</p>
</li>
<li>
<p><strong>Images need explicit dimensions</strong> - While images will render, they work best when the markdown container has width constraints.</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="element-query-api"><a class="header" href="#element-query-api">Element Query API</a></h1>
<p>The Element Query API provides programmatic access to elements in the UI tree, enabling imperative operations like scrolling, focusing, reading bounds, and triggering updates.</p>
<h2 id="overview-3"><a class="header" href="#overview-3">Overview</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Query an element by its string ID
let handle = ctx.query("my-element");

// Check if it exists
if handle.exists() {
    // Get computed bounds
    if let Some(bounds) = handle.bounds() {
        println!("Element at ({}, {}) size {}x{}",
            bounds.x, bounds.y, bounds.width, bounds.height);
    }

    // Scroll into view
    handle.scroll_into_view();

    // Focus the element
    handle.focus();
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="assigning-element-ids"><a class="header" href="#assigning-element-ids">Assigning Element IDs</a></h2>
<p>To query an element, it must have a string ID assigned via <code>.id()</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>div()
    .id("sidebar")
    .w(250.0)
    .h_full()
    .child(
        div()
            .id("nav-item-home")
            .child(text("Home"))
    )
    .child(
        div()
            .id("nav-item-settings")
            .child(text("Settings"))
    )
<span class="boring">}</span></code></pre>
<p>IDs should be unique within your UI. Duplicate IDs will cause the last element to win.</p>
<hr>
<h2 id="elementhandle-api"><a class="header" href="#elementhandle-api">ElementHandle API</a></h2>
<h3 id="creation--existence"><a class="header" href="#creation--existence">Creation &amp; Existence</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Get a handle - works even if element doesn't exist yet
let handle = ctx.query("my-element");

// Check if element exists in the tree
if handle.exists() {
    // Element is rendered
}

// Get the string ID
let id = handle.id();  // "my-element"
<span class="boring">}</span></code></pre>
<h3 id="bounds--visibility"><a class="header" href="#bounds--visibility">Bounds &amp; Visibility</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Get computed bounds after layout
if let Some(bounds) = handle.bounds() {
    println!("Position: ({}, {})", bounds.x, bounds.y);
    println!("Size: {}x{}", bounds.width, bounds.height);
}

// Check if visible in viewport
if handle.is_visible() {
    // Element intersects with window viewport
}
<span class="boring">}</span></code></pre>
<h3 id="navigation"><a class="header" href="#navigation">Navigation</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Scroll element into view (smooth scroll)
handle.scroll_into_view();

// Focus the element (for inputs, updates EventRouter)
handle.focus();

// Remove focus
handle.blur();

// Check focus state
if handle.is_focused() {
    // Element has keyboard focus
}
<span class="boring">}</span></code></pre>
<h3 id="tree-traversal"><a class="header" href="#tree-traversal">Tree Traversal</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Get parent element
if let Some(parent) = handle.parent() {
    println!("Parent ID: {}", parent.id());
}

// Iterate over ancestors (parent → grandparent → root)
for ancestor in handle.ancestors() {
    println!("Ancestor: {}", ancestor.id());
}
<span class="boring">}</span></code></pre>
<h3 id="triggering-updates"><a class="header" href="#triggering-updates">Triggering Updates</a></h3>
<p>ElementHandle provides three levels of update granularity:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 1. Visual-only update (fastest - skips layout)
// Use for: background color, opacity, shadows, transforms
handle.mark_visual_dirty(
    RenderProps::default().with_background(Color::RED.into())
);

// 2. Subtree rebuild with new children
// Use for: structural changes where you know the new content
handle.mark_dirty_subtree(
    div().child(text("New content"))
);

// 3. Full rebuild (fallback)
// Triggers complete UI rebuild, diffing determines actual changes
handle.mark_dirty();
<span class="boring">}</span></code></pre>
<h3 id="signal-integration"><a class="header" href="#signal-integration">Signal Integration</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Emit a signal to trigger reactive updates
// Only rebuilds stateful elements that depend on this signal
handle.emit_signal(my_signal_id);
<span class="boring">}</span></code></pre>
<h3 id="on-ready-callbacks"><a class="header" href="#on-ready-callbacks">On-Ready Callbacks</a></h3>
<p>Register callbacks that fire once after an element’s first layout:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>ctx.query("progress-bar").on_ready(|bounds| {
    // Element has been laid out
    println!("Progress bar width: {}", bounds.width);

    // Start an animation based on computed size
    progress_anim.lock().unwrap().set_target(bounds.width * 0.75);
});
<span class="boring">}</span></code></pre>
<p>On-ready callbacks:</p>
<ul>
<li>Fire only once per element ID</li>
<li>Work even if element doesn’t exist yet (callback queued)</li>
<li>Survive tree rebuilds (tracked by string ID)</li>
</ul>
<hr>
<h2 id="querying-in-event-handlers"><a class="header" href="#querying-in-event-handlers">Querying in Event Handlers</a></h2>
<p>Inside event handlers, use the global <code>query()</code> function to get an <code>ElementHandle</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use junita_layout::prelude::*;

div()
    .on_click(|_| {
        // query() returns Option&lt;ElementHandle&gt; - None if element doesn't exist
        if let Some(handle) = query("my-element") {
            handle.scroll_into_view();
            handle.focus();
        }
    })
<span class="boring">}</span></code></pre>
<p>The <code>query()</code> function uses the global <code>JunitaContextState</code> internally, so you don’t need to capture any context or registry in your closures.</p>
<p>For simple operations like scroll and focus without needing the full handle:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use junita_core::JunitaContextState;

div()
    .on_click(|_| {
        // Direct access for simple operations
        if let Some(ctx) = JunitaContextState::try_get() {
            ctx.scroll_element_into_view("my-element");
            ctx.set_focus(Some("my-input"));
        }
    })
<span class="boring">}</span></code></pre>
<hr>
<h2 id="use-cases-1"><a class="header" href="#use-cases-1">Use Cases</a></h2>
<h3 id="scroll-to-element-on-action"><a class="header" href="#scroll-to-element-on-action">Scroll to Element on Action</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn scrollable_list(ctx: &amp;WindowedContext) -&gt; impl ElementBuilder {
    div()
        .flex_col()
        .child(
            div()
                .on_click(|_| {
                    // Use query() to get handle and scroll
                    if let Some(handle) = query("list-bottom") {
                        handle.scroll_into_view();
                    }
                })
                .child(text("Jump to Bottom"))
        )
        .child(
            scroll()
                .h(400.0)
                .child(
                    div()
                        .flex_col()
                        .children((0..100).map(|i| {
                            div()
                                .id(format!("item-{}", i))
                                .child(text(format!("Item {}", i)))
                        }))
                        .child(
                            div().id("list-bottom").h(1.0)
                        )
                )
        )
}
<span class="boring">}</span></code></pre>
<h3 id="focus-management"><a class="header" href="#focus-management">Focus Management</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn login_form(ctx: &amp;WindowedContext) -&gt; impl ElementBuilder {
    div()
        .flex_col()
        .gap(16.0)
        .child(
            text_input(ctx.use_state_keyed::&lt;TextInputState&gt;("username"))
                .id("username-input")
                .placeholder("Username")
        )
        .child(
            text_input(ctx.use_state_keyed::&lt;TextInputState&gt;("password"))
                .id("password-input")
                .placeholder("Password")
                .on_key_down(|evt| {
                    if evt.key_code == 9 &amp;&amp; evt.shift {  // Shift+Tab
                        if let Some(handle) = query("username-input") {
                            handle.focus();
                        }
                    }
                })
        )
        .child(
            div()
                .on_click(|_| {
                    // Focus username on form reset
                    if let Some(handle) = query("username-input") {
                        handle.focus();
                    }
                })
                .child(text("Reset"))
        )
}
<span class="boring">}</span></code></pre>
<h3 id="measure-element-after-layout"><a class="header" href="#measure-element-after-layout">Measure Element After Layout</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn responsive_card(ctx: &amp;WindowedContext) -&gt; impl ElementBuilder {
    let card_width = ctx.use_signal(0.0f32);

    // Register callback to measure after layout
    ctx.query("adaptive-card").on_ready(move |bounds| {
        // on_ready callback has access to bounds directly
        println!("Card width: {}", bounds.width);
    });

    let width = ctx.get(card_width).unwrap_or(0.0);
    let columns = if width &gt; 600.0 { 3 } else if width &gt; 400.0 { 2 } else { 1 };

    div()
        .id("adaptive-card")
        .w_full()
        .flex_wrap()
        .children((0..9).map(|i| {
            div()
                .w(pct(100.0 / columns as f32))
                .child(text(format!("Item {}", i)))
        }))
}
<span class="boring">}</span></code></pre>
<h3 id="efficient-visual-updates"><a class="header" href="#efficient-visual-updates">Efficient Visual Updates</a></h3>
<p>Use <code>mark_visual_dirty</code> for visual-only changes that don’t affect layout:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn highlight_on_selection(ctx: &amp;WindowedContext, selected_id: Option&lt;&amp;str&gt;) -&gt; impl ElementBuilder {
    let selected = selected_id.map(|s| s.to_string());

    div()
        .flex_col()
        .children(["item-a", "item-b", "item-c"].iter().map(|id| {
            let is_selected = selected.as_deref() == Some(*id);
            let id_string = id.to_string();

            div()
                .id(*id)
                .p(12.0)
                .bg(if is_selected {
                    Color::rgba(0.2, 0.5, 1.0, 0.3)
                } else {
                    Color::TRANSPARENT
                })
                .on_click(move |_| {
                    // Visual-only update - skips layout recomputation
                    if let Some(handle) = query(&amp;id_string) {
                        handle.mark_visual_dirty(
                            RenderProps::default()
                                .with_background(Color::rgba(0.2, 0.5, 1.0, 0.3).into())
                        );
                    }
                })
                .child(text(*id))
        }))
}
<span class="boring">}</span></code></pre>
<h3 id="carousel-with-snap-points"><a class="header" href="#carousel-with-snap-points">Carousel with Snap Points</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn carousel(ctx: &amp;WindowedContext, items: &amp;[String]) -&gt; impl ElementBuilder {
    let current_index = ctx.use_signal(0usize);

    div()
        .flex_col()
        .child(
            scroll()
                .id("carousel-scroll")
                .w(300.0)
                .h(200.0)
                .scroll_x()
                .child(
                    div()
                        .flex_row()
                        .children(items.iter().enumerate().map(|(i, item)| {
                            div()
                                .id(format!("slide-{}", i))
                                .w(300.0)
                                .h(200.0)
                                .flex_center()
                                .child(text(item))
                        }))
                )
        )
        .child(
            div()
                .flex_row()
                .justify_center()
                .gap(8.0)
                .children((0..items.len()).map(|i| {
                    div()
                        .circle(8.0)
                        .bg(Color::WHITE.with_alpha(0.5))
                        .on_click(move |_| {
                            if let Some(handle) = query(&amp;format!("slide-{}", i)) {
                                handle.scroll_into_view();
                            }
                        })
                }))
        )
}

---

# Performance Considerations

## Update Granularity

Choose the right update method based on what changed:

| Method | When to Use | Layout Cost |
|--------|-------------|-------------|
| `mark_visual_dirty(props)` | Background, opacity, shadow, transform | None (visual only) |
| `mark_dirty_subtree(div)` | Children structure changed | Subtree only |
| `mark_dirty()` | Unknown changes, fallback | Full rebuild |
| `emit_signal(id)` | Signal-based state change | Targeted stateful |

## Avoid Frequent Queries in Render

```rust
// Bad: Query in render function (called every frame)
fn bad_example(ctx: &amp;WindowedContext) -&gt; impl ElementBuilder {
    let bounds = ctx.query("my-element").bounds();  // Called every render!
    // ...
}

// Good: Query in event handler or on_ready
fn good_example(ctx: &amp;WindowedContext) -&gt; impl ElementBuilder {
    div()
        .on_click(|_| {
            // query() is designed for use in event handlers
            if let Some(handle) = query("my-element") {
                let bounds = handle.bounds();
                // Use bounds...
            }
        })
}
<span class="boring">}</span></code></pre>
<h3 id="use-on_ready-for-post-layout-measurements"><a class="header" href="#use-on_ready-for-post-layout-measurements">Use on_ready for Post-Layout Measurements</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// The on_ready callback fires once after first layout
ctx.query("my-element").on_ready(|bounds| {
    // Safe to use bounds here - layout is complete
    setup_animations_based_on_size(bounds);
});
<span class="boring">}</span></code></pre>
<hr>
<h2 id="best-practices-12"><a class="header" href="#best-practices-12">Best Practices</a></h2>
<ol>
<li>
<p><strong>Assign meaningful IDs</strong> - Use descriptive IDs like <code>"sidebar"</code>, <code>"submit-button"</code>, <code>"user-avatar"</code> rather than generic names.</p>
</li>
<li>
<p><strong>Prefer declarative state</strong> - Use signals and reactive state for most UI updates. Use ElementHandle for imperative operations like scroll-to and focus.</p>
</li>
<li>
<p><strong>Use visual-only updates</strong> - When only colors/opacity/shadows change, use <code>mark_visual_dirty()</code> to skip layout.</p>
</li>
<li>
<p><strong>Handle missing elements</strong> - Always check <code>exists()</code> or handle <code>None</code> from <code>bounds()</code> when the element might not be rendered.</p>
</li>
<li>
<p><strong>Avoid ID collisions</strong> - Each ID should be unique. Consider namespacing like <code>"dialog-submit"</code>, <code>"sidebar-nav-home"</code>.</p>
</li>
<li>
<p><strong>Use on_ready for measurements</strong> - Don’t assume bounds are available immediately. Use <code>on_ready</code> for post-layout operations.</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="overlay-system"><a class="header" href="#overlay-system">Overlay System</a></h1>
<p>Junita provides an overlay system for modals, dialogs, toasts, and context menus.</p>
<h2 id="overview-4"><a class="header" href="#overview-4">Overview</a></h2>
<p>Overlays render on top of the main UI and handle their own lifecycle. Access the overlay manager through the context:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>ctx.overlay_manager()
<span class="boring">}</span></code></pre>
<h2 id="modals"><a class="header" href="#modals">Modals</a></h2>
<p>Full-screen overlays with backdrop:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>ctx.overlay_manager()
    .modal()
    .title("Confirm Action")
    .content(|| {
        div()
            .flex_col()
            .gap(16.0)
            .child(text("Are you sure you want to proceed?"))
    })
    .show();
<span class="boring">}</span></code></pre>
<h3 id="modal-with-actions"><a class="header" href="#modal-with-actions">Modal with Actions</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>ctx.overlay_manager()
    .modal()
    .title("Delete Item")
    .content(|| {
        text("This action cannot be undone.")
    })
    .primary_action("Delete", |_| {
        delete_item();
    })
    .secondary_action("Cancel", |_| {
        // Modal closes automatically
    })
    .show();
<span class="boring">}</span></code></pre>
<h2 id="dialogs"><a class="header" href="#dialogs">Dialogs</a></h2>
<p>Centered dialogs with customizable content:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>ctx.overlay_manager()
    .dialog()
    .title("Settings")
    .content(|| build_settings_form())
    .primary_action("Save", |_| {
        save_settings();
    })
    .secondary_action("Cancel", |_| {})
    .show();
<span class="boring">}</span></code></pre>
<h3 id="dialog-sizing"><a class="header" href="#dialog-sizing">Dialog Sizing</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>ctx.overlay_manager()
    .dialog()
    .width(600.0)
    .height(400.0)
    .title("Large Dialog")
    .content(|| content)
    .show();
<span class="boring">}</span></code></pre>
<h2 id="toasts"><a class="header" href="#toasts">Toasts</a></h2>
<p>Brief notifications:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Simple toast
ctx.overlay_manager()
    .toast("Item saved successfully!")
    .show();

// With duration
ctx.overlay_manager()
    .toast("Processing...")
    .duration(5000)  // 5 seconds
    .show();

// Positioned
ctx.overlay_manager()
    .toast("Copied to clipboard")
    .position(ToastPosition::BottomCenter)
    .show();
<span class="boring">}</span></code></pre>
<h3 id="toast-positions"><a class="header" href="#toast-positions">Toast Positions</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>ToastPosition::TopLeft
ToastPosition::TopCenter
ToastPosition::TopRight
ToastPosition::BottomLeft
ToastPosition::BottomCenter
ToastPosition::BottomRight
<span class="boring">}</span></code></pre>
<h2 id="context-menus"><a class="header" href="#context-menus">Context Menus</a></h2>
<p>Right-click menus:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>div()
    .on_context_menu(|evt| {
        ctx.overlay_manager()
            .context_menu()
            .item("Copy", || copy_to_clipboard())
            .item("Paste", || paste_from_clipboard())
            .separator()
            .item("Delete", || delete_selected())
            .show_at(evt.mouse_x, evt.mouse_y);
    })
<span class="boring">}</span></code></pre>
<h3 id="nested-menus"><a class="header" href="#nested-menus">Nested Menus</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>ctx.overlay_manager()
    .context_menu()
    .item("Edit", || {})
    .submenu("Export", |menu| {
        menu.item("PNG", || export_png())
            .item("JPEG", || export_jpeg())
            .item("SVG", || export_svg())
    })
    .show_at(x, y);
<span class="boring">}</span></code></pre>
<h2 id="dismissing-overlays"><a class="header" href="#dismissing-overlays">Dismissing Overlays</a></h2>
<p>Overlays close when:</p>
<ul>
<li>User clicks outside (backdrop click)</li>
<li>Escape key is pressed</li>
<li>Action callback completes</li>
<li>Programmatically dismissed</li>
</ul>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let overlay_id = ctx.overlay_manager()
    .modal()
    .title("Loading...")
    .content(|| spinner())
    .show();

// Later, dismiss programmatically
ctx.overlay_manager().dismiss(overlay_id);
<span class="boring">}</span></code></pre>
<h2 id="custom-overlay-content"><a class="header" href="#custom-overlay-content">Custom Overlay Content</a></h2>
<p>For full control, use a custom overlay:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>ctx.overlay_manager()
    .custom(|| {
        stack()
            .w_full()
            .h_full()
            // Backdrop
            .child(
                div()
                    .w_full()
                    .h_full()
                    .bg(Color::rgba(0.0, 0.0, 0.0, 0.5))
            )
            // Content
            .child(
                div()
                    .absolute()
                    .inset(0.0)
                    .flex_center()
                    .child(my_custom_modal())
            )
    })
    .show();
<span class="boring">}</span></code></pre>
<h2 id="best-practices-13"><a class="header" href="#best-practices-13">Best Practices</a></h2>
<ol>
<li>
<p><strong>Use appropriate overlay type</strong> - Modal for blocking actions, toast for notifications, dialog for forms.</p>
</li>
<li>
<p><strong>Provide escape routes</strong> - Always include a way to close (cancel button, backdrop click).</p>
</li>
<li>
<p><strong>Keep toasts brief</strong> - Short messages that don’t require action.</p>
</li>
<li>
<p><strong>Position context menus near cursor</strong> - Use event coordinates for natural placement.</p>
</li>
<li>
<p><strong>Limit overlay nesting</strong> - Avoid opening overlays from within overlays.</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="custom-state-machines"><a class="header" href="#custom-state-machines">Custom State Machines</a></h1>
<p>For complex interactions beyond hover/press, define custom state types with the <code>StateTransitions</code> trait.</p>
<h2 id="defining-custom-states"><a class="header" href="#defining-custom-states">Defining Custom States</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use junita_layout::stateful::StateTransitions;
use junita_core::events::event_types::*;

#[derive(Clone, Copy, PartialEq, Eq, Hash, Default)]
enum PlayerState {
    #[default]
    Stopped,
    Playing,
    Paused,
}

impl StateTransitions for PlayerState {
    fn on_event(&amp;self, event: u32) -&gt; Option&lt;Self&gt; {
        match (self, event) {
            // Click cycles through states
            (PlayerState::Stopped, POINTER_UP) =&gt; Some(PlayerState::Playing),
            (PlayerState::Playing, POINTER_UP) =&gt; Some(PlayerState::Paused),
            (PlayerState::Paused, POINTER_UP) =&gt; Some(PlayerState::Playing),
            _ =&gt; None,
        }
    }
}
<span class="boring">}</span></code></pre>
<h2 id="using-custom-states"><a class="header" href="#using-custom-states">Using Custom States</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use junita_layout::prelude::*;

fn player_button() -&gt; impl ElementBuilder {
    stateful::&lt;PlayerState&gt;()
        .w(60.0)
        .h(60.0)
        .rounded_full()
        .flex_center()
        .on_state(|ctx| {
            let bg = match ctx.state() {
                PlayerState::Stopped =&gt; Color::rgba(0.3, 0.3, 0.35, 1.0),
                PlayerState::Playing =&gt; Color::rgba(0.2, 0.8, 0.4, 1.0),
                PlayerState::Paused =&gt; Color::rgba(0.9, 0.6, 0.2, 1.0),
            };
            div().bg(bg).child(text("▶").color(Color::WHITE))
        })
}
<span class="boring">}</span></code></pre>
<h2 id="event-types"><a class="header" href="#event-types">Event Types</a></h2>
<p>Available event types for state transitions:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use junita_core::events::event_types::*;

POINTER_ENTER    // Mouse enters element
POINTER_LEAVE    // Mouse leaves element
POINTER_DOWN     // Mouse button pressed
POINTER_UP       // Mouse button released (click)
POINTER_MOVE     // Mouse moved over element

KEY_DOWN         // Keyboard key pressed
KEY_UP           // Keyboard key released
TEXT_INPUT       // Character typed

FOCUS            // Element gained focus
BLUR             // Element lost focus

SCROLL           // Scroll event
DRAG             // Drag motion
DRAG_END         // Drag completed
<span class="boring">}</span></code></pre>
<h2 id="multi-phase-interactions"><a class="header" href="#multi-phase-interactions">Multi-Phase Interactions</a></h2>
<h3 id="drag-state-machine"><a class="header" href="#drag-state-machine">Drag State Machine</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone, Copy, PartialEq, Eq, Hash, Default)]
enum DragPhase {
    #[default]
    Idle,
    Hovering,
    Pressing,
    Dragging,
}

impl StateTransitions for DragPhase {
    fn on_event(&amp;self, event: u32) -&gt; Option&lt;Self&gt; {
        match (self, event) {
            // Enter hover
            (DragPhase::Idle, POINTER_ENTER) =&gt; Some(DragPhase::Hovering),
            (DragPhase::Hovering, POINTER_LEAVE) =&gt; Some(DragPhase::Idle),

            // Start press
            (DragPhase::Hovering, POINTER_DOWN) =&gt; Some(DragPhase::Pressing),

            // Transition to drag on move while pressed
            (DragPhase::Pressing, DRAG) =&gt; Some(DragPhase::Dragging),

            // Release
            (DragPhase::Pressing, POINTER_UP) =&gt; Some(DragPhase::Hovering),
            (DragPhase::Dragging, DRAG_END) =&gt; Some(DragPhase::Idle),

            _ =&gt; None,
        }
    }
}

fn draggable_card() -&gt; impl ElementBuilder {
    stateful::&lt;DragPhase&gt;()
        .w(120.0)
        .h(80.0)
        .rounded(8.0)
        .on_state(|ctx| {
            let (bg, cursor) = match ctx.state() {
                DragPhase::Idle =&gt; (Color::BLUE, "default"),
                DragPhase::Hovering =&gt; (Color::CYAN, "grab"),
                DragPhase::Pressing =&gt; (Color::YELLOW, "grabbing"),
                DragPhase::Dragging =&gt; (Color::GREEN, "grabbing"),
            };
            div().bg(bg).cursor(cursor)
        })
}
<span class="boring">}</span></code></pre>
<h3 id="focus-state-machine"><a class="header" href="#focus-state-machine">Focus State Machine</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone, Copy, PartialEq, Eq, Hash, Default)]
enum InputFocus {
    #[default]
    Idle,
    Hovered,
    Focused,
    FocusedHovered,
}

impl StateTransitions for InputFocus {
    fn on_event(&amp;self, event: u32) -&gt; Option&lt;Self&gt; {
        match (self, event) {
            // Hover transitions
            (InputFocus::Idle, POINTER_ENTER) =&gt; Some(InputFocus::Hovered),
            (InputFocus::Hovered, POINTER_LEAVE) =&gt; Some(InputFocus::Idle),
            (InputFocus::Focused, POINTER_ENTER) =&gt; Some(InputFocus::FocusedHovered),
            (InputFocus::FocusedHovered, POINTER_LEAVE) =&gt; Some(InputFocus::Focused),

            // Focus transitions
            (InputFocus::Idle, FOCUS) =&gt; Some(InputFocus::Focused),
            (InputFocus::Hovered, FOCUS) =&gt; Some(InputFocus::FocusedHovered),
            (InputFocus::Hovered, POINTER_UP) =&gt; Some(InputFocus::FocusedHovered),
            (InputFocus::Focused, BLUR) =&gt; Some(InputFocus::Idle),
            (InputFocus::FocusedHovered, BLUR) =&gt; Some(InputFocus::Hovered),

            _ =&gt; None,
        }
    }
}

fn focusable_input() -&gt; impl ElementBuilder {
    stateful::&lt;InputFocus&gt;()
        .w(200.0)
        .h(40.0)
        .rounded(4.0)
        .on_state(|ctx| {
            let (border_color, border_width) = match ctx.state() {
                InputFocus::Idle =&gt; (Color::GRAY, 1.0),
                InputFocus::Hovered =&gt; (Color::LIGHT_GRAY, 1.0),
                InputFocus::Focused =&gt; (Color::BLUE, 2.0),
                InputFocus::FocusedHovered =&gt; (Color::BLUE, 2.0),
            };
            div().border(border_width, border_color)
        })
}
<span class="boring">}</span></code></pre>
<h2 id="combining-with-external-state"><a class="header" href="#combining-with-external-state">Combining with External State</a></h2>
<p>Use <code>.deps()</code> to combine state machine transitions with external signals:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn smart_button() -&gt; impl ElementBuilder {
    let enabled = use_state_keyed("enabled", || true);

    stateful::&lt;ButtonState&gt;()
        .px(16.0)
        .py(8.0)
        .rounded(8.0)
        .deps([enabled.signal_id()])
        .on_state(move |ctx| {
            let is_enabled = enabled.get();

            let bg = if !is_enabled {
                Color::rgba(0.2, 0.2, 0.25, 0.5)  // Disabled
            } else {
                match ctx.state() {
                    ButtonState::Idle =&gt; Color::rgba(0.3, 0.5, 0.9, 1.0),
                    ButtonState::Hovered =&gt; Color::rgba(0.4, 0.6, 1.0, 1.0),
                    ButtonState::Pressed =&gt; Color::rgba(0.2, 0.4, 0.8, 1.0),
                    _ =&gt; Color::rgba(0.3, 0.5, 0.9, 1.0),
                }
            };

            div().bg(bg).child(text("Submit").color(Color::WHITE))
        })
}
<span class="boring">}</span></code></pre>
<h2 id="accessing-dependencies-via-context"><a class="header" href="#accessing-dependencies-via-context">Accessing Dependencies via Context</a></h2>
<p>Use <code>ctx.dep()</code> for cleaner dependency access:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn counter_button(count: State&lt;i32&gt;) -&gt; impl ElementBuilder {
    stateful::&lt;ButtonState&gt;()
        .deps([count.signal_id()])
        .on_state(|ctx| {
            // Access by index - no need to capture in closure
            let value: i32 = ctx.dep(0).unwrap_or_default();

            // Or get a State handle for reading/writing
            if let Some(count_state) = ctx.dep_as_state::&lt;i32&gt;(0) {
                // count_state.set(value + 1);
            }

            let bg = match ctx.state() {
                ButtonState::Hovered =&gt; Color::CYAN,
                _ =&gt; Color::BLUE,
            };

            div()
                .bg(bg)
                .child(text(&amp;format!("Count: {}", value)))
        })
}
<span class="boring">}</span></code></pre>
<h2 id="using-scoped-state"><a class="header" href="#using-scoped-state">Using Scoped State</a></h2>
<p>StateContext provides scoped signals and animated values:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn interactive_counter() -&gt; impl ElementBuilder {
    stateful::&lt;ButtonState&gt;()
        .on_state(|ctx| {
            // Scoped signal - persists across rebuilds
            let clicks = ctx.use_signal("clicks", || 0);

            // Scoped animated value with spring physics
            let scale = ctx.use_animated_value("scale", 1.0);

            // Animate based on state
            match ctx.state() {
                ButtonState::Pressed =&gt; {
                    scale.lock().unwrap().set_target(0.95);
                }
                _ =&gt; {
                    scale.lock().unwrap().set_target(1.0);
                }
            }

            let s = scale.lock().unwrap().get();

            div()
                .transform(Transform::scale(s, s))
                .child(text(&amp;format!("Clicks: {}", clicks.get())))
                .on_click(move |_| {
                    clicks.update(|n| n + 1);
                })
        })
}
<span class="boring">}</span></code></pre>
<h2 id="state-debugging"><a class="header" href="#state-debugging">State Debugging</a></h2>
<p>Log state transitions for debugging:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl StateTransitions for MyState {
    fn on_event(&amp;self, event: u32) -&gt; Option&lt;Self&gt; {
        let next = match (self, event) {
            // ... transitions ...
            _ =&gt; None,
        };

        if let Some(ref new_state) = next {
            println!("State: {:?} -&gt; {:?} (event: {})", self, new_state, event);
        }

        next
    }
}
<span class="boring">}</span></code></pre>
<h2 id="setting-initial-state-1"><a class="header" href="#setting-initial-state-1">Setting Initial State</a></h2>
<p>Use <code>.initial()</code> when you need a non-default starting state:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn initially_disabled_button(disabled: bool) -&gt; impl ElementBuilder {
    stateful::&lt;ButtonState&gt;()
        .initial(if disabled { ButtonState::Disabled } else { ButtonState::Idle })
        .on_state(|ctx| {
            let bg = match ctx.state() {
                ButtonState::Disabled =&gt; Color::GRAY,
                ButtonState::Idle =&gt; Color::BLUE,
                ButtonState::Hovered =&gt; Color::CYAN,
                ButtonState::Pressed =&gt; Color::DARK_BLUE,
            };
            div().bg(bg)
        })
}
<span class="boring">}</span></code></pre>
<h2 id="nostate-for-dependency-only-containers"><a class="header" href="#nostate-for-dependency-only-containers">NoState for Dependency-Only Containers</a></h2>
<p>When you only need dependency tracking without state transitions:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn data_display(data: State&lt;Vec&lt;String&gt;&gt;) -&gt; impl ElementBuilder {
    stateful::&lt;NoState&gt;()
        .deps([data.signal_id()])
        .on_state(|ctx| {
            // Access data via context
            let items: Vec&lt;String&gt; = ctx.dep(0).unwrap_or_default();

            div()
                .flex_col()
                .gap(4.0)
                .children(items.iter().map(|item| {
                    div().child(text(item))
                }))
        })
}
<span class="boring">}</span></code></pre>
<h2 id="best-practices-14"><a class="header" href="#best-practices-14">Best Practices</a></h2>
<ol>
<li>
<p><strong>Keep states minimal</strong> - Only include states you need to distinguish visually.</p>
</li>
<li>
<p><strong>Handle all paths</strong> - Consider every possible event in each state.</p>
</li>
<li>
<p><strong>Use descriptive names</strong> - State names should clearly indicate the UI appearance.</p>
</li>
<li>
<p><strong>Return None for no-ops</strong> - If an event doesn’t cause a transition, return <code>None</code>.</p>
</li>
<li>
<p><strong>Test transitions</strong> - Verify all state paths work as expected.</p>
</li>
<li>
<p><strong>Use <code>.deps()</code> for external dependencies</strong> - When combining with signals.</p>
</li>
<li>
<p><strong>Use <code>ctx.dep()</code> over closures</strong> - Cleaner access to dependency values.</p>
</li>
<li>
<p><strong>Implement Default</strong> - Mark the default state with <code>#[default]</code> attribute.</p>
</li>
<li>
<p><strong>Use scoped signals</strong> - <code>ctx.use_signal()</code> for state local to the stateful.</p>
</li>
<li>
<p><strong>Use animated values</strong> - <code>ctx.use_animated_value()</code> for smooth transitions.</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="performance-tips-2"><a class="header" href="#performance-tips-2">Performance Tips</a></h1>
<p>Junita is designed for high performance, but following these guidelines ensures your UI stays smooth.</p>
<h2 id="use-stateful-for-visual-states"><a class="header" href="#use-stateful-for-visual-states">Use Stateful for Visual States</a></h2>
<p><strong>Do:</strong> Use <code>stateful(handle)</code> for hover, press, and focus effects:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use junita_layout::stateful::stateful;

fn hover_button(ctx: &amp;WindowedContext) -&gt; impl ElementBuilder {
    let handle = ctx.use_state(ButtonState::Idle);

    stateful(handle)
        .px(16.0)
        .py(8.0)
        .rounded(8.0)
        .on_state(|state, div| {
            let bg = match state {
                ButtonState::Idle =&gt; Color::RED,
                ButtonState::Hovered =&gt; Color::BLUE,
                _ =&gt; Color::RED,
            };
            div.set_bg(bg);
        })
        .child(text("Hover me").color(Color::WHITE))
}
<span class="boring">}</span></code></pre>
<p><strong>Don’t:</strong> Use if-else or signals for visual-only state changes:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// AVOID - causes full tree rebuild on every hover
let is_hovered = ctx.use_signal(false);
div()
    .on_hover_enter(move |_| ctx.set(is_hovered, true))
    .on_hover_leave(move |_| ctx.set(is_hovered, false))
    .bg(if ctx.get(is_hovered).unwrap_or(false) {
        Color::BLUE
    } else {
        Color::RED
    })
<span class="boring">}</span></code></pre>
<p>The <code>stateful(handle)</code> pattern only updates the affected element, while signals with if-else rebuild the entire UI tree.</p>
<h2 id="minimize-signal-updates"><a class="header" href="#minimize-signal-updates">Minimize Signal Updates</a></h2>
<p>Signals trigger UI rebuilds. Batch related updates:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Good - single rebuild
ctx.batch(|g| {
    g.set(x, 10);
    g.set(y, 20);
    g.set(z, 30);
});

// Avoid - three rebuilds
ctx.set(x, 10);
ctx.set(y, 20);
ctx.set(z, 30);
<span class="boring">}</span></code></pre>
<h2 id="use-keyed-state-appropriately"><a class="header" href="#use-keyed-state-appropriately">Use Keyed State Appropriately</a></h2>
<p>Keyed state persists across rebuilds. Use it for:</p>
<ul>
<li>Form input values</li>
<li>Toggle states</li>
<li>Selected items</li>
</ul>
<p>Don’t overuse - each key adds memory overhead.</p>
<h2 id="efficient-list-rendering"><a class="header" href="#efficient-list-rendering">Efficient List Rendering</a></h2>
<p>For large lists, consider:</p>
<ol>
<li><strong>Virtualization</strong> - Only render visible items</li>
<li><strong>Stable keys</strong> - Use consistent identifiers for list items</li>
<li><strong>Memoization</strong> - Cache expensive computations</li>
</ol>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// For very long lists, wrap in scroll and limit rendered items
scroll()
    .h(500.0)
    .child(
        div()
            .flex_col()
            .child(
                visible_items.iter().map(|item| render_item(item))
            )
    )
<span class="boring">}</span></code></pre>
<h2 id="canvas-optimization"><a class="header" href="#canvas-optimization">Canvas Optimization</a></h2>
<p>For custom drawing:</p>
<ol>
<li><strong>Minimize state reads</strong> - Read animated values once, not per-shape</li>
<li><strong>Use transforms</strong> - Push/pop transforms instead of recalculating positions</li>
<li><strong>Batch similar draws</strong> - Group shapes by color/brush</li>
</ol>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>canvas(move |ctx, bounds| {
    // Read once
    let angle = timeline.lock().unwrap().get(entry_id).unwrap_or(0.0);

    // Use transform for rotation
    ctx.push_transform(Transform::rotate(angle));
    // ... draw ...
    ctx.pop_transform();
})
<span class="boring">}</span></code></pre>
<h2 id="animation-performance"><a class="header" href="#animation-performance">Animation Performance</a></h2>
<ol>
<li><strong>Use appropriate spring stiffness</strong> - Stiffer springs settle faster</li>
<li><strong>Limit simultaneous animations</strong> - Too many can cause jank</li>
<li><strong>Use timelines for loops</strong> - More efficient than many spring values</li>
</ol>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Good - single timeline with multiple entries
let timeline = ctx.use_animated_timeline();
let (x, y, scale) = timeline.lock().unwrap().configure(|t| {
    (t.add(0, 1000, 0.0, 100.0),
     t.add(0, 1000, 0.0, 100.0),
     t.add(0, 500, 1.0, 1.5))
});
<span class="boring">}</span></code></pre>
<h2 id="memory-management"><a class="header" href="#memory-management">Memory Management</a></h2>
<ol>
<li><strong>Clone Arc, not data</strong> - Use <code>Arc::clone()</code> for shared state</li>
<li><strong>Drop unused state</strong> - Clean up keyed state when no longer needed</li>
<li><strong>Avoid closures capturing large data</strong> - Clone only what’s needed</li>
</ol>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Good - clone the Arc, not the data
let data = Arc::clone(&amp;shared_data);

// Avoid - captures entire struct
let large_struct = expensive_struct.clone();
div().on_click(move |_| use_struct(&amp;large_struct))
<span class="boring">}</span></code></pre>
<h2 id="lazy-loading-for-images"><a class="header" href="#lazy-loading-for-images">Lazy Loading for Images</a></h2>
<p>For applications with many images (galleries, feeds, chat), use lazy loading to defer loading until images are visible:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Images in a scrollable gallery
scroll()
    .h(600.0)
    .child(
        div()
            .flex_row()
            .flex_wrap()
            .gap(8.0)
            .child(
                image_urls.iter().map(|url| {
                    img(*url)
                        .lazy()  // Only loads when scrolled into view
                        .placeholder_color(Color::rgba(0.2, 0.2, 0.2, 1.0))
                        .w(150.0)
                        .h(150.0)
                        .cover()
                })
            )
    )
<span class="boring">}</span></code></pre>
<p>Benefits:</p>
<ul>
<li><strong>Reduced initial memory</strong> - Only visible images are loaded</li>
<li><strong>Faster startup</strong> - No waiting for off-screen images</li>
<li><strong>Automatic cleanup</strong> - LRU cache evicts old images</li>
</ul>
<p>Emoji images (<code>emoji()</code> and <code>emoji_sized()</code>) are automatically lazy-loaded. The ~180MB system emoji font is only loaded when emoji characters actually appear on screen.</p>
<h2 id="debugging-performance"><a class="header" href="#debugging-performance">Debugging Performance</a></h2>
<p>Enable tracing to identify bottlenecks:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>tracing_subscriber::fmt()
    .with_env_filter("junita_layout=debug")
    .init();
<span class="boring">}</span></code></pre>
<p>Look for:</p>
<ul>
<li>Frequent tree rebuilds</li>
<li>Long frame times</li>
<li>Excessive state updates</li>
</ul>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Do</th><th>Don’t</th></tr>
</thead>
<tbody>
<tr><td>Use <code>Stateful</code> for hover/press</td><td>Use signals for visual-only changes</td></tr>
<tr><td>Batch signal updates</td><td>Update signals one at a time</td></tr>
<tr><td>Use <code>Arc::clone()</code></td><td>Clone large data into closures</td></tr>
<tr><td>Use timelines for loops</td><td>Create many spring values</td></tr>
<tr><td>Read animated values once</td><td>Read repeatedly in draw loops</td></tr>
</tbody>
</table>
</div>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="architecture-overview-1"><a class="header" href="#architecture-overview-1">Architecture Overview</a></h1>
<p>Blinc is a high-performance UI framework built from the ground up for GPU-accelerated rendering without virtual DOM overhead. This chapter explains how the major systems work together.</p>
<h2 id="design-philosophy"><a class="header" href="#design-philosophy">Design Philosophy</a></h2>
<p>Blinc follows several key principles:</p>
<ol>
<li><strong>Fine-grained Reactivity</strong> - Signal-based state management with automatic dependency tracking eliminates the need for virtual DOM diffing</li>
<li><strong>Layout as Separate Concern</strong> - Tree structure is independent from visual properties, enabling visual-only updates without layout recomputation</li>
<li><strong>GPU-First Rendering</strong> - SDF shaders provide resolution-independent, smooth rendering with glass/blur effects</li>
<li><strong>Incremental Updates</strong> - Hash-based diffing with change categories minimizes recomputation</li>
<li><strong>Background Thread Animations</strong> - Animation scheduler runs independently from the UI thread</li>
</ol>
<h2 id="system-architecture"><a class="header" href="#system-architecture">System Architecture</a></h2>
<pre><code>┌─────────────────────────────────────────────────────────────┐
│  WindowedApp Event Loop (Platform abstraction)              │
├─────────────────────────────────────────────────────────────┤
│ • Receives pointer, keyboard, lifecycle events              │
│ • Routes through EventRouter -&gt; StateMachines               │
│ • Triggers reactive signal updates                          │
│ • Checks signal dependencies for rebuilds                   │
└─────────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────────┐
│  ReactiveGraph &amp; Stateful Element Updates                   │
├─────────────────────────────────────────────────────────────┤
│ • Signals change -&gt; Effects run -&gt; Rebuilds queued          │
│ • Stateful elements transition -&gt; Subtree rebuild queued    │
│ • Diff algorithm determines change categories               │
└─────────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────────┐
│  RenderTree Update (Incremental)                            │
├─────────────────────────────────────────────────────────────┤
│ • incremental_update() compares hashes                      │
│ • VisualOnly: apply prop updates only                       │
│ • ChildrenChanged: rebuild subtrees + mark layout dirty     │
└─────────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────────┐
│  Layout Computation (Taffy Flexbox)                         │
├─────────────────────────────────────────────────────────────┤
│ • compute_layout() on dirty nodes only                      │
│ • Returns (x, y, width, height) for all nodes               │
│ • Cached in LayoutTree                                      │
└─────────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────────┐
│  Animation Scheduler (Background Thread @ 120fps)           │
├─────────────────────────────────────────────────────────────┤
│ • Ticks springs, keyframes, timelines                       │
│ • Stores current values in AnimatedValue                    │
│ • Sets needs_redraw flag, wakes main thread                 │
└─────────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────────┐
│  GPU Rendering (DrawContext -&gt; GpuRenderer)                 │
├─────────────────────────────────────────────────────────────┤
│ • RenderTree traversal, samples animation values            │
│ • Emits SDF primitives to batches                           │
│ • Multi-pass rendering: Background -&gt; Glass -&gt; Foreground  │
└─────────────────────────────────────────────────────────────┘
</code></pre>
<h2 id="core-crates"><a class="header" href="#core-crates">Core Crates</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Crate</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>blinc_core</code></td><td>Reactive signals, FSM, core types, event system</td></tr>
<tr><td><code>blinc_layout</code></td><td>Element builders, Taffy integration, diff system, stateful elements</td></tr>
<tr><td><code>blinc_animation</code></td><td>Spring physics, keyframe timelines, animation scheduler</td></tr>
<tr><td><code>blinc_gpu</code></td><td>wgpu renderer, SDF shaders, glass effects, text rendering</td></tr>
<tr><td><code>blinc_text</code></td><td>Font loading, glyph shaping, text atlas</td></tr>
<tr><td><code>blinc_app</code></td><td>WindowedApp, render context, platform integration</td></tr>
</tbody>
</table>
</div>
<h2 id="why-no-virtual-dom"><a class="header" href="#why-no-virtual-dom">Why No Virtual DOM?</a></h2>
<p>Traditional frameworks (React, Vue) use a virtual DOM to diff the entire component tree on every state change. This has overhead:</p>
<ol>
<li>Creating VDOM objects for every render</li>
<li>Diffing the full tree to find changes</li>
<li>Patching the real DOM with changes</li>
</ol>
<p>Blinc avoids this with:</p>
<ol>
<li><strong>Fine-grained signals</strong> - Only dependent code re-runs when state changes</li>
<li><strong>Stateful elements</strong> - UI state managed at the element level, not rebuilt from scratch</li>
<li><strong>Hash-based diffing</strong> - Quick equality checks without deep comparison</li>
<li><strong>Change categories</strong> - Visual vs layout vs structural changes handled differently</li>
</ol>
<p>The result: updates proportional to what changed, not to tree size.</p>
<hr>
<h2 id="chapter-contents"><a class="header" href="#chapter-contents">Chapter Contents</a></h2>
<ul>
<li><a href="#gpu-rendering">GPU Rendering</a> - SDF primitives, glass effects, text rendering</li>
<li><a href="#reactive-state-system">Reactive State</a> - Signal system, dependency tracking, effects</li>
<li><a href="#layout--diff-system">Layout &amp; Diff</a> - Taffy integration, incremental updates</li>
<li><a href="#animation-system">Animation</a> - Spring physics, timelines, scheduler</li>
<li><a href="#stateful-elements--fsm">Stateful Elements</a> - FSM-driven interactive widgets</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="gpu-rendering"><a class="header" href="#gpu-rendering">GPU Rendering</a></h1>
<p>Junita uses GPU-accelerated rendering via wgpu with <strong>Signed Distance Field (SDF)</strong> shaders for smooth, resolution-independent UI primitives.</p>
<h2 id="signed-distance-fields"><a class="header" href="#signed-distance-fields">Signed Distance Fields</a></h2>
<p>An SDF shader computes the signed distance from each pixel to the geometry’s edge:</p>
<ul>
<li><strong>Negative distance</strong>: pixel is inside the shape</li>
<li><strong>Positive distance</strong>: pixel is outside the shape</li>
<li><strong>Zero</strong>: pixel is exactly on the edge</li>
</ul>
<p>This enables:</p>
<ul>
<li>Smooth anti-aliasing at any scale</li>
<li>Per-corner rounded rectangles</li>
<li>Soft shadows with Gaussian blur</li>
<li>Sharp text at any zoom level</li>
</ul>
<h2 id="gpu-primitive-structure"><a class="header" href="#gpu-primitive-structure">GPU Primitive Structure</a></h2>
<p>All UI elements are converted to <code>GpuPrimitive</code> structs (192 bytes each):</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct GpuPrimitive {
    // Geometry
    bounds: [f32; 4],           // x, y, width, height
    corner_radii: [f32; 4],     // top-left, top-right, bottom-right, bottom-left

    // Fill
    fill_type: FillType,        // Solid, LinearGradient, RadialGradient
    fill_colors: [Color; 4],    // gradient stops or solid color

    // Border
    border_width: f32,
    border_color: Color,

    // Shadow
    shadow_offset: [f32; 2],
    shadow_blur: f32,
    shadow_color: Color,

    // Clipping
    clip_bounds: [f32; 4],
    clip_radii: [f32; 4],
}
<span class="boring">}</span></code></pre>
<h3 id="primitive-types"><a class="header" href="#primitive-types">Primitive Types</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>Rect</code></td><td>Rounded rectangle with per-corner radius</td></tr>
<tr><td><code>Circle</code></td><td>Perfect circle</td></tr>
<tr><td><code>Ellipse</code></td><td>Axis-aligned ellipse</td></tr>
<tr><td><code>Shadow</code></td><td>Drop shadow with Gaussian blur</td></tr>
<tr><td><code>InnerShadow</code></td><td>Inset shadow</td></tr>
<tr><td><code>Text</code></td><td>Glyph sampled from texture atlas</td></tr>
</tbody>
</table>
</div>
<h3 id="fill-types"><a class="header" href="#fill-types">Fill Types</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>Solid</code></td><td>Single color fill</td></tr>
<tr><td><code>LinearGradient</code></td><td>Gradient between two points</td></tr>
<tr><td><code>RadialGradient</code></td><td>Gradient radiating from center</td></tr>
</tbody>
</table>
</div>
<h2 id="rendering-pipeline"><a class="header" href="#rendering-pipeline">Rendering Pipeline</a></h2>
<p>Rendering happens in multiple passes for proper layering:</p>
<pre><code>1. Background Pass (non-glass elements)
   └── SDF shader for rects, circles, shadows

2. Glass Pass (frosted glass elements)
   └── Glass shader samples backbuffer + blur

3. Foreground Pass (text, overlays)
   └── Text shader with glyph atlases
   └── SDF shader for overlays

4. Composite Pass
   └── Blend layers + MSAA resolve
</code></pre>
<h3 id="sdf-shader"><a class="header" href="#sdf-shader">SDF Shader</a></h3>
<p>The main SDF shader handles rectangles with:</p>
<pre><code class="language-wgsl">// Signed distance to rounded rectangle
fn sdf_rounded_rect(p: vec2f, size: vec2f, radii: vec4f) -&gt; f32 {
    // Select corner radius based on quadrant
    let radius = select_corner_radius(p, radii);

    // Compute distance to rounded corner
    let q = abs(p) - size + radius;
    return min(max(q.x, q.y), 0.0) + length(max(q, vec2f(0.0))) - radius;
}
</code></pre>
<p>Anti-aliasing uses the SDF gradient:</p>
<pre><code class="language-wgsl">// Smooth alpha based on distance
let alpha = 1.0 - smoothstep(-0.5, 0.5, distance);
</code></pre>
<h3 id="shadow-rendering"><a class="header" href="#shadow-rendering">Shadow Rendering</a></h3>
<p>Soft shadows use Gaussian blur approximated with the error function:</p>
<pre><code class="language-wgsl">fn shadow_alpha(distance: f32, blur_radius: f32) -&gt; f32 {
    // Error function approximation for Gaussian
    let t = distance / (blur_radius * 0.5);
    return 0.5 * (1.0 - erf(t));
}
</code></pre>
<h2 id="glass-effects"><a class="header" href="#glass-effects">Glass Effects</a></h2>
<p>Junita implements Apple-style frosted glass (vibrancy) with backdrop blur:</p>
<h3 id="glass-types"><a class="header" href="#glass-types">Glass Types</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Type</th><th>Blur</th><th>Saturation</th><th>Use Case</th></tr>
</thead>
<tbody>
<tr><td><code>UltraThin</code></td><td>Light</td><td>High</td><td>Subtle overlays</td></tr>
<tr><td><code>Thin</code></td><td>Medium</td><td>Medium</td><td>Sidebars</td></tr>
<tr><td><code>Regular</code></td><td>Standard</td><td>Standard</td><td>Modals, cards</td></tr>
<tr><td><code>Thick</code></td><td>Heavy</td><td>Low</td><td>Headers</td></tr>
<tr><td><code>Chrome</code></td><td>Very heavy</td><td>Low</td><td>Window chrome</td></tr>
</tbody>
</table>
</div>
<h3 id="glass-shader"><a class="header" href="#glass-shader">Glass Shader</a></h3>
<p>The glass shader:</p>
<ol>
<li><strong>Samples backbuffer</strong> - Reads rendered content behind the glass</li>
<li><strong>Applies Gaussian blur</strong> - Multi-tap sampling with weights</li>
<li><strong>Adjusts saturation</strong> - Controls color vibrancy</li>
<li><strong>Adds tint color</strong> - Overlays glass tint</li>
<li><strong>Applies noise grain</strong> - Frosted texture effect</li>
<li><strong>Rim bending</strong> - Light refraction at edges</li>
</ol>
<pre><code class="language-wgsl">// Simplified glass computation
fn glass_color(uv: vec2f, glass_type: u32) -&gt; vec4f {
    // Sample and blur background
    var color = blur_sample(backbuffer, uv, blur_radius);

    // Adjust saturation
    color = saturate_color(color, saturation);

    // Apply tint
    color = mix(color, tint_color, tint_strength);

    // Add noise grain
    color += noise(uv) * grain_amount;

    return color;
}
</code></pre>
<h3 id="three-layer-rendering"><a class="header" href="#three-layer-rendering">Three-Layer Rendering</a></h3>
<p>Glass requires separating background from foreground:</p>
<pre><code>┌─────────────────────────────────┐
│  Foreground Layer               │  Text, icons on glass
├─────────────────────────────────┤
│  Glass Layer                    │  Frosted glass with blur
├─────────────────────────────────┤
│  Background Layer               │  Content behind glass
└─────────────────────────────────┘
</code></pre>
<p>The renderer:</p>
<ol>
<li>Renders background to backbuffer texture</li>
<li>Renders glass elements sampling the backbuffer</li>
<li>Renders foreground elements on top</li>
<li>Composites all layers</li>
</ol>
<h2 id="text-rendering"><a class="header" href="#text-rendering">Text Rendering</a></h2>
<p>Text uses a separate glyph atlas system:</p>
<ol>
<li><strong>Font Loading</strong> - Parses TTF/OTF via rustybuzz</li>
<li><strong>Glyph Shaping</strong> - HarfBuzz-compatible shaping for complex scripts</li>
<li><strong>Atlas Generation</strong> - Rasterizes glyphs to texture atlas</li>
<li><strong>SDF Text</strong> - Stores distance field for each glyph</li>
<li><strong>Rendering</strong> - Samples atlas with color spans</li>
</ol>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Text rendering produces glyph primitives
for glyph in shaped_text.glyphs() {
    emit_text_primitive(GpuPrimitive {
        primitive_type: PrimitiveType::Text,
        bounds: glyph.bounds,
        texture_coords: glyph.atlas_uv,
        color: text_color,
        // ...
    });
}
<span class="boring">}</span></code></pre>
<h2 id="batching--instancing"><a class="header" href="#batching--instancing">Batching &amp; Instancing</a></h2>
<p>Primitives are batched by type and rendered with GPU instancing:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// All rects in one draw call
batch.add_primitive(rect1);
batch.add_primitive(rect2);
batch.add_primitive(rect3);
// Single instanced draw call for all rects
<span class="boring">}</span></code></pre>
<p>Benefits:</p>
<ul>
<li>Minimal CPU-GPU communication</li>
<li>Efficient use of GPU parallelism</li>
<li>Scales to thousands of primitives</li>
</ul>
<h2 id="msaa-support"><a class="header" href="#msaa-support">MSAA Support</a></h2>
<p>Junita supports multi-sample anti-aliasing:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Sample Count</th><th>Quality</th><th>Performance</th></tr>
</thead>
<tbody>
<tr><td>1x</td><td>Baseline</td><td>Fastest</td></tr>
<tr><td>2x</td><td>Improved edges</td><td>Slight cost</td></tr>
<tr><td>4x</td><td>Good quality</td><td>Moderate cost</td></tr>
<tr><td>8x</td><td>High quality</td><td>Higher cost</td></tr>
</tbody>
</table>
</div>
<p>MSAA is resolved in the final composite pass.</p>
<h2 id="drawcontext-trait"><a class="header" href="#drawcontext-trait">DrawContext Trait</a></h2>
<p>The bridge between layout and GPU is the <code>DrawContext</code> trait:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait DrawContext {
    fn draw_rect(&amp;mut self, bounds: Rect, props: &amp;RenderProps);
    fn draw_text(&amp;mut self, text: &amp;ShapedText, position: Point);
    fn draw_shadow(&amp;mut self, bounds: Rect, shadow: &amp;Shadow);
    fn push_clip(&amp;mut self, bounds: Rect, radii: [f32; 4]);
    fn pop_clip(&amp;mut self);
    fn push_transform(&amp;mut self, transform: Transform);
    fn pop_transform(&amp;mut self);
}
<span class="boring">}</span></code></pre>
<p>The RenderTree traverses nodes and calls DrawContext methods, which accumulate GPU primitives for the render passes.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="reactive-state-system"><a class="header" href="#reactive-state-system">Reactive State System</a></h1>
<p>Junita implements a <strong>push-pull hybrid reactive system</strong> for fine-grained state management without virtual DOM overhead. This is inspired by modern reactive frameworks like Leptos and SolidJS.</p>
<h2 id="core-concepts"><a class="header" href="#core-concepts">Core Concepts</a></h2>
<h3 id="signals"><a class="header" href="#signals">Signals</a></h3>
<p>A <code>Signal&lt;T&gt;</code> is a reactive container for a value. When the value changes, all dependent computations automatically update.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Create a signal
let count = ctx.use_state_keyed("count", || 0i32);

// Read the current value
let value = count.get();

// Update the value
count.set(5);
count.update(|v| v + 1);
<span class="boring">}</span></code></pre>
<h3 id="signal-ids"><a class="header" href="#signal-ids">Signal IDs</a></h3>
<p>Signals are identified by <code>SignalId</code>, a cheap-to-copy handle:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Get the signal's ID for dependency tracking
let id = count.signal_id();
<span class="boring">}</span></code></pre>
<h2 id="automatic-dependency-tracking"><a class="header" href="#automatic-dependency-tracking">Automatic Dependency Tracking</a></h2>
<p>When code accesses a signal’s value, the dependency is automatically recorded:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Stateful element with signal dependency
stateful(handle)
    .deps(&amp;[count.signal_id()])  // Declare dependency
    .on_state(move |state, div| {
        // Reading count.get() here is tracked
        let value = count.get();
        div.set_bg(color_for_value(value));
    })
<span class="boring">}</span></code></pre>
<p>When <code>count</code> changes, only elements depending on it re-run their callbacks.</p>
<h2 id="reactivegraph-internals"><a class="header" href="#reactivegraph-internals">ReactiveGraph Internals</a></h2>
<p>The <code>ReactiveGraph</code> manages all reactive state:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct ReactiveGraph {
    signals: SlotMap&lt;SignalId, SignalNode&gt;,
    deriveds: SlotMap&lt;DerivedId, DerivedNode&gt;,
    effects: SlotMap&lt;EffectId, EffectNode&gt;,
    pending_effects: Vec&lt;EffectId&gt;,
    batch_depth: u32,
}
<span class="boring">}</span></code></pre>
<h3 id="data-structures"><a class="header" href="#data-structures">Data Structures</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Type</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>SignalNode</code></td><td>Stores value + list of subscribers</td></tr>
<tr><td><code>DerivedNode</code></td><td>Cached computed value + dirty flag</td></tr>
<tr><td><code>EffectNode</code></td><td>Side-effect function + dependencies</td></tr>
</tbody>
</table>
</div>
<h3 id="subscription-flow"><a class="header" href="#subscription-flow">Subscription Flow</a></h3>
<pre><code>Signal.set(new_value)
    │
    ├── Mark all subscribers dirty
    │
    ├── Propagate to derived values
    │
    └── Queue effects for execution
</code></pre>
<h2 id="derived-values"><a class="header" href="#derived-values">Derived Values</a></h2>
<p>Derived values compute from other signals and cache the result:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Conceptual - derived values
let doubled = derived(|| count.get() * 2);

// Value is cached until count changes
let value = doubled.get();  // Computed once
let again = doubled.get();  // Returns cached value
<span class="boring">}</span></code></pre>
<h3 id="lazy-evaluation"><a class="header" href="#lazy-evaluation">Lazy Evaluation</a></h3>
<p>Derived values only compute when:</p>
<ol>
<li>First accessed after creation</li>
<li>Accessed after a dependency changed</li>
<li>Their value is explicitly needed</li>
</ol>
<p>This prevents wasted computation for unused values.</p>
<h2 id="effects"><a class="header" href="#effects">Effects</a></h2>
<p>Effects are side-effects that run when dependencies change:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Conceptual - effects
effect(|| {
    let value = count.get();  // Tracks dependency on count
    println!("Count changed to {}", value);
});
<span class="boring">}</span></code></pre>
<p>Effects are:</p>
<ul>
<li>Queued when dependencies change</li>
<li>Executed after the current batch completes</li>
<li>Run in topological order (respecting dependency depth)</li>
</ul>
<h2 id="batching"><a class="header" href="#batching">Batching</a></h2>
<p>Multiple signal updates can be batched to prevent redundant recomputation:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Without batching: 3 separate updates, 3 effect runs
count.set(1);
name.set("Alice");
enabled.set(true);

// With batching: 1 combined update, 1 effect run
ctx.batch(|g| {
    g.set(count, 1);
    g.set(name, "Alice");
    g.set(enabled, true);
});
<span class="boring">}</span></code></pre>
<h3 id="how-batching-works"><a class="header" href="#how-batching-works">How Batching Works</a></h3>
<ol>
<li><code>batch_start()</code> increments batch depth counter</li>
<li>Signal updates mark subscribers dirty but don’t run effects</li>
<li><code>batch_end()</code> decrements counter</li>
<li>When counter reaches 0, all pending effects execute</li>
</ol>
<h2 id="integration-with-stateful-elements"><a class="header" href="#integration-with-stateful-elements">Integration with Stateful Elements</a></h2>
<p>The reactive system integrates with stateful elements via <code>.deps()</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn counter_display(ctx: &amp;WindowedContext, count: State&lt;i32&gt;) -&gt; impl ElementBuilder {
    let handle = ctx.use_state(ButtonState::Idle);

    stateful(handle)
        // Declare signal dependencies
        .deps(&amp;[count.signal_id()])
        .on_state(move |_state, container| {
            // This callback re-runs when count changes
            let current = count.get();
            container.merge(
                div().child(text(&amp;format!("{}", current)).color(Color::WHITE))
            );
        })
}
<span class="boring">}</span></code></pre>
<h3 id="dependency-registry"><a class="header" href="#dependency-registry">Dependency Registry</a></h3>
<p>The system maintains a registry of signal dependencies:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Internal tracking
struct DependencyEntry {
    signal_ids: Vec&lt;SignalId&gt;,
    node_id: LayoutNodeId,
    refresh_callback: Box&lt;dyn Fn()&gt;,
}
<span class="boring">}</span></code></pre>
<p>When signals change, the registry triggers rebuilds for dependent nodes.</p>
<h2 id="performance-characteristics"><a class="header" href="#performance-characteristics">Performance Characteristics</a></h2>
<h3 id="o1-signal-access"><a class="header" href="#o1-signal-access">O(1) Signal Access</a></h3>
<p>Reading a signal is a simple memory lookup:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn get(&amp;self) -&gt; T {
    self.value.clone()  // Direct access, no computation
}
<span class="boring">}</span></code></pre>
<h3 id="osubscribers-propagation"><a class="header" href="#osubscribers-propagation">O(subscribers) Propagation</a></h3>
<p>Updates only touch direct subscribers:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn set(&amp;mut self, value: T) {
    self.value = value;
    for subscriber in &amp;self.subscribers {
        subscriber.mark_dirty();
    }
}
<span class="boring">}</span></code></pre>
<h3 id="minimal-allocations"><a class="header" href="#minimal-allocations">Minimal Allocations</a></h3>
<ul>
<li><code>SignalId</code> is a 64-bit handle (Copy)</li>
<li>Subscriber lists use <code>SmallVec&lt;[_; 4]&gt;</code> (inline for small counts)</li>
<li>SlotMap provides dense storage without gaps</li>
</ul>
<h2 id="comparison-to-virtual-dom"><a class="header" href="#comparison-to-virtual-dom">Comparison to Virtual DOM</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Aspect</th><th>Virtual DOM</th><th>Junita Reactive</th></tr>
</thead>
<tbody>
<tr><td>State change</td><td>Rebuild entire component</td><td>Update only affected nodes</td></tr>
<tr><td>Diffing</td><td>O(tree size)</td><td>O(1) per signal</td></tr>
<tr><td>Memory</td><td>VDOM objects per render</td><td>Fixed signal storage</td></tr>
<tr><td>Dependency tracking</td><td>Manual (useEffect deps)</td><td>Automatic</td></tr>
</tbody>
</table>
</div>
<h2 id="best-practices-15"><a class="header" href="#best-practices-15">Best Practices</a></h2>
<ol>
<li>
<p><strong>Use keyed state for persistence</strong> - <code>use_state_keyed("key", || value)</code> survives rebuilds</p>
</li>
<li>
<p><strong>Batch related updates</strong> - Group multiple signal changes to avoid redundant work</p>
</li>
<li>
<p><strong>Declare dependencies explicitly</strong> - Use <code>.deps()</code> for stateful elements that read signals</p>
</li>
<li>
<p><strong>Prefer stateful for visual changes</strong> - Use stateful elements instead of signals for hover/press effects</p>
</li>
<li>
<p><strong>Keep signals granular</strong> - Fine-grained signals enable more precise updates</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="layout--diff-system"><a class="header" href="#layout--diff-system">Layout &amp; Diff System</a></h1>
<p>Junita separates layout computation from visual rendering, enabling incremental updates without full tree rebuilds.</p>
<h2 id="layout-system-1"><a class="header" href="#layout-system-1">Layout System</a></h2>
<h3 id="taffy-integration"><a class="header" href="#taffy-integration">Taffy Integration</a></h3>
<p>Junita uses <a href="https://github.com/DioxusLabs/taffy">Taffy</a> for flexbox layout computation. Taffy is a high-performance layout engine that implements the CSS Flexbox specification.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// LayoutTree wraps Taffy
struct LayoutTree {
    taffy: TaffyTree,
    node_map: HashMap&lt;LayoutNodeId, TaffyNodeId&gt;,
    reverse_map: HashMap&lt;TaffyNodeId, LayoutNodeId&gt;,
}
<span class="boring">}</span></code></pre>
<h3 id="layout-properties-vs-visual-properties"><a class="header" href="#layout-properties-vs-visual-properties">Layout Properties vs Visual Properties</a></h3>
<p>Layout and visual properties are handled separately:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Layout Properties</th><th>Visual Properties</th></tr>
</thead>
<tbody>
<tr><td><code>width</code>, <code>height</code></td><td><code>background</code></td></tr>
<tr><td><code>padding</code>, <code>margin</code></td><td><code>border_color</code></td></tr>
<tr><td><code>flex_direction</code></td><td><code>shadow</code></td></tr>
<tr><td><code>justify_content</code></td><td><code>opacity</code></td></tr>
<tr><td><code>align_items</code></td><td><code>transform</code></td></tr>
<tr><td><code>gap</code></td><td><code>rounded</code></td></tr>
</tbody>
</table>
</div>
<p>This separation allows visual-only updates without layout recomputation.</p>
<h3 id="rendertree-structure"><a class="header" href="#rendertree-structure">RenderTree Structure</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct RenderTree {
    layout_tree: LayoutTree,           // Taffy wrapper
    render_props: HashMap&lt;NodeId, RenderProps&gt;,  // Visual properties
    dirty_nodes: HashSet&lt;NodeId&gt;,      // Nodes needing update
    scroll_state: HashMap&lt;NodeId, ScrollState&gt;,
    motion_bindings: HashMap&lt;NodeId, MotionBinding&gt;,
}
<span class="boring">}</span></code></pre>
<h3 id="layout-computation"><a class="header" href="#layout-computation">Layout Computation</a></h3>
<p>Layout is computed on-demand when the tree structure changes:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Compute layout for the tree
render_tree.compute_layout(root_id, AvailableSpace {
    width: window_width,
    height: window_height,
});

// Get computed bounds for a node
let layout = render_tree.get_layout(node_id);
// Returns: Layout { x, y, width, height }
<span class="boring">}</span></code></pre>
<hr>
<h2 id="diff-system"><a class="header" href="#diff-system">Diff System</a></h2>
<p>The diff system determines the minimum changes needed when UI structure updates.</p>
<h3 id="divhash---content-based-identity"><a class="header" href="#divhash---content-based-identity">DivHash - Content-Based Identity</a></h3>
<p>Every element has a hash computed from its properties:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone, Copy, PartialEq, Eq, Hash)]
struct DivHash(u64);

impl Div {
    // Hash of this element only (excludes children)
    fn compute_hash(&amp;self) -&gt; DivHash {
        let mut hasher = DefaultHasher::new();
        self.width.hash(&amp;mut hasher);
        self.height.hash(&amp;mut hasher);
        self.background.hash(&amp;mut hasher);
        // ... all properties
        DivHash(hasher.finish())
    }

    // Hash including entire subtree
    fn compute_tree_hash(&amp;self) -&gt; DivHash {
        let mut hasher = DefaultHasher::new();
        self.compute_hash().hash(&amp;mut hasher);
        for child in &amp;self.children {
            child.compute_tree_hash().hash(&amp;mut hasher);
        }
        DivHash(hasher.finish())
    }
}
<span class="boring">}</span></code></pre>
<h3 id="change-categories"><a class="header" href="#change-categories">Change Categories</a></h3>
<p>Changes are classified to determine the update strategy:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct ChangeCategory {
    layout: bool,      // Requires layout recomputation
    visual: bool,      // Only visual properties changed
    children: bool,    // Children added/removed/reordered
    handlers: bool,    // Event handlers changed
}
<span class="boring">}</span></code></pre>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Category</th><th>Example Changes</th><th>Action</th></tr>
</thead>
<tbody>
<tr><td>Visual only</td><td><code>bg</code>, <code>opacity</code>, <code>shadow</code></td><td>Update RenderProps</td></tr>
<tr><td>Layout</td><td><code>width</code>, <code>padding</code>, <code>gap</code></td><td>Recompute layout</td></tr>
<tr><td>Children</td><td>Add/remove child</td><td>Rebuild subtree</td></tr>
<tr><td>Handlers</td><td>Event callback changed</td><td>Update handlers</td></tr>
</tbody>
</table>
</div>
<h3 id="child-diffing-algorithm"><a class="header" href="#child-diffing-algorithm">Child Diffing Algorithm</a></h3>
<p>When children change, the diff algorithm matches old and new children:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum ChildDiff {
    Unchanged { index: usize },           // Same content, same position
    Moved { old_idx: usize, new_idx: usize },  // Same content, moved
    Modified { old_idx: usize, new_idx: usize, diff: Box&lt;DiffResult&gt; },
    Added { index: usize },               // New child
    Removed { index: usize },             // Old child gone
}
<span class="boring">}</span></code></pre>
<h3 id="matching-strategy"><a class="header" href="#matching-strategy">Matching Strategy</a></h3>
<ol>
<li><strong>Compute hashes</strong> for all old and new children</li>
<li><strong>Build hash map</strong> of old children by hash</li>
<li><strong>Match new children</strong> to old by hash lookup</li>
<li><strong>Detect moves</strong> when hash matches at different position</li>
<li><strong>Classify remaining</strong> as added or removed</li>
<li><strong>Merge same-position changes</strong> as modifications</li>
</ol>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn diff_children(old: &amp;[Div], new: &amp;[Div]) -&gt; Vec&lt;ChildDiff&gt; {
    let old_hashes: Vec&lt;_&gt; = old.iter().map(|c| c.compute_tree_hash()).collect();
    let new_hashes: Vec&lt;_&gt; = new.iter().map(|c| c.compute_tree_hash()).collect();

    let mut old_by_hash: HashMap&lt;DivHash, usize&gt; = old_hashes
        .iter()
        .enumerate()
        .map(|(i, h)| (*h, i))
        .collect();

    let mut diffs = Vec::new();

    for (new_idx, new_hash) in new_hashes.iter().enumerate() {
        if let Some(old_idx) = old_by_hash.remove(new_hash) {
            if old_idx == new_idx {
                diffs.push(ChildDiff::Unchanged { index: new_idx });
            } else {
                diffs.push(ChildDiff::Moved { old_idx, new_idx });
            }
        } else {
            diffs.push(ChildDiff::Added { index: new_idx });
        }
    }

    // Remaining old children were removed
    for (old_idx, _) in old_by_hash {
        diffs.push(ChildDiff::Removed { index: old_idx });
    }

    diffs
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="incremental-updates"><a class="header" href="#incremental-updates">Incremental Updates</a></h2>
<h3 id="update-result"><a class="header" href="#update-result">Update Result</a></h3>
<p>The incremental update process returns what changed:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum UpdateResult {
    NoChanges,                    // Nothing to do
    VisualOnly(Vec&lt;PropUpdate&gt;),  // Apply prop updates only
    LayoutChanged,                // Props + recompute layout
    ChildrenChanged,              // Rebuild subtrees + layout
}
<span class="boring">}</span></code></pre>
<h3 id="reconciliation"><a class="header" href="#reconciliation">Reconciliation</a></h3>
<p>The <code>reconcile</code> function determines actions from diffs:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct ReconcileActions {
    prop_updates: Vec&lt;(NodeId, RenderProps)&gt;,  // Visual updates
    subtree_rebuild_ids: Vec&lt;NodeId&gt;,          // Nodes to rebuild
    needs_layout: bool,                        // Layout recomputation needed
}

fn reconcile(old: &amp;Div, new: &amp;Div) -&gt; ReconcileActions {
    let changes = categorize_changes(old, new);

    let mut actions = ReconcileActions::default();

    if changes.visual &amp;&amp; !changes.layout &amp;&amp; !changes.children {
        // Visual-only: just update props
        actions.prop_updates.push((node_id, new.to_render_props()));
    }

    if changes.layout {
        actions.needs_layout = true;
    }

    if changes.children {
        actions.subtree_rebuild_ids.push(node_id);
        actions.needs_layout = true;
    }

    actions
}
<span class="boring">}</span></code></pre>
<h3 id="update-flow"><a class="header" href="#update-flow">Update Flow</a></h3>
<pre><code>incremental_update(root, new_element)
    │
    ├── Compare hashes: old_tree_hash vs new_tree_hash
    │   └── Same? Return NoChanges
    │
    ├── Compare element hashes: old_hash vs new_hash
    │   └── Same? Children might have changed
    │
    ├── Categorize changes
    │   ├── Visual only? Queue prop updates
    │   ├── Layout changed? Mark layout dirty
    │   └── Children changed? Diff children recursively
    │
    └── Return UpdateResult
</code></pre>
<hr>
<h2 id="pending-update-queues"><a class="header" href="#pending-update-queues">Pending Update Queues</a></h2>
<p>The system uses global queues for deferred updates:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Global pending updates (thread-local)
static PENDING_PROP_UPDATES: RefCell&lt;Vec&lt;(NodeId, RenderProps)&gt;&gt;;
static PENDING_SUBTREE_REBUILDS: RefCell&lt;Vec&lt;NodeId&gt;&gt;;
static NEEDS_REDRAW: AtomicBool;
<span class="boring">}</span></code></pre>
<h3 id="queue-processing"><a class="header" href="#queue-processing">Queue Processing</a></h3>
<p>The windowed app processes queues each frame:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn process_pending_updates(&amp;mut self) {
    // Apply prop updates (no layout needed)
    for (node_id, props) in drain_prop_updates() {
        self.render_tree.update_props(node_id, props);
    }

    // Rebuild dirty subtrees
    for node_id in drain_subtree_rebuilds() {
        self.rebuild_subtree(node_id);
    }

    // Recompute layout if needed
    if self.layout_dirty {
        self.render_tree.compute_layout(self.root_id, self.available_space);
        self.layout_dirty = false;
    }

    // Trigger redraw if visual changes occurred
    if NEEDS_REDRAW.swap(false, Ordering::SeqCst) {
        self.request_redraw();
    }
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="performance-benefits"><a class="header" href="#performance-benefits">Performance Benefits</a></h2>
<h3 id="hash-based-comparison"><a class="header" href="#hash-based-comparison">Hash-Based Comparison</a></h3>
<ul>
<li>O(1) per element to compute hash</li>
<li>O(1) equality check via hash comparison</li>
<li>No deep property-by-property comparison needed</li>
</ul>
<h3 id="child-matching"><a class="header" href="#child-matching">Child Matching</a></h3>
<ul>
<li>O(n) to build hash map</li>
<li>O(n) to match children</li>
<li>Detects moves without position-based assumptions</li>
</ul>
<h3 id="minimal-recomputation"><a class="header" href="#minimal-recomputation">Minimal Recomputation</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Scenario</th><th>What Runs</th></tr>
</thead>
<tbody>
<tr><td>Hover color change</td><td>Update 1 RenderProps</td></tr>
<tr><td>Text content change</td><td>Rebuild 1 text node</td></tr>
<tr><td>Add item to list</td><td>Insert node, layout affected subtree</td></tr>
<tr><td>Reorder list</td><td>Move nodes, minimal layout</td></tr>
</tbody>
</table>
</div>
<h3 id="layout-caching"><a class="header" href="#layout-caching">Layout Caching</a></h3>
<ul>
<li>Layout only recomputes when structure/dimensions change</li>
<li>Visual-only changes skip layout entirely</li>
<li>Taffy caches intermediate results</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="animation-system"><a class="header" href="#animation-system">Animation System</a></h1>
<p>Junita provides a multi-layered animation system with physics-based springs and timed keyframe animations.</p>
<h2 id="spring-physics-1"><a class="header" href="#spring-physics-1">Spring Physics</a></h2>
<p>Springs are the foundation of Junita’s animation system, providing natural, interruptible motion.</p>
<h3 id="spring-model"><a class="header" href="#spring-model">Spring Model</a></h3>
<p>A spring follows Hooke’s law with damping:</p>
<pre><code>Force = -k * (position - target) - d * velocity

where:
  k = stiffness (spring tightness)
  d = damping (friction)
</code></pre>
<h3 id="spring-structure"><a class="header" href="#spring-structure">Spring Structure</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Spring {
    value: f32,      // Current position
    velocity: f32,   // Current velocity
    target: f32,     // Destination
    config: SpringConfig,
}

struct SpringConfig {
    stiffness: f32,  // Spring constant (k)
    damping: f32,    // Damping coefficient (d)
    mass: f32,       // Virtual mass
}
<span class="boring">}</span></code></pre>
<h3 id="rk4-integration"><a class="header" href="#rk4-integration">RK4 Integration</a></h3>
<p>Junita uses <strong>4th-order Runge-Kutta (RK4)</strong> integration for stability:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn step(&amp;mut self, dt: f32) {
    // RK4 provides stable integration even with large timesteps
    let k1 = self.acceleration(self.value, self.velocity);
    let k2 = self.acceleration(
        self.value + self.velocity * dt * 0.5,
        self.velocity + k1 * dt * 0.5
    );
    let k3 = self.acceleration(
        self.value + (self.velocity + k2 * dt * 0.5) * dt * 0.5,
        self.velocity + k2 * dt * 0.5
    );
    let k4 = self.acceleration(
        self.value + (self.velocity + k3 * dt) * dt,
        self.velocity + k3 * dt
    );

    self.velocity += (k1 + 2.0 * k2 + 2.0 * k3 + k4) * dt / 6.0;
    self.value += self.velocity * dt;
}
<span class="boring">}</span></code></pre>
<h3 id="spring-presets"><a class="header" href="#spring-presets">Spring Presets</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Preset</th><th>Stiffness</th><th>Damping</th><th>Character</th></tr>
</thead>
<tbody>
<tr><td><code>stiff()</code></td><td>400</td><td>30</td><td>Fast, minimal overshoot</td></tr>
<tr><td><code>snappy()</code></td><td>300</td><td>20</td><td>Quick with slight bounce</td></tr>
<tr><td><code>gentle()</code></td><td>120</td><td>14</td><td>Soft, slower motion</td></tr>
<tr><td><code>wobbly()</code></td><td>180</td><td>12</td><td>Bouncy, playful</td></tr>
<tr><td><code>molasses()</code></td><td>50</td><td>20</td><td>Very slow, heavy</td></tr>
</tbody>
</table>
</div>
<h3 id="settling-detection"><a class="header" href="#settling-detection">Settling Detection</a></h3>
<p>A spring is considered settled when:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn is_settled(&amp;self) -&gt; bool {
    let position_settled = (self.value - self.target).abs() &lt; EPSILON;
    let velocity_settled = self.velocity.abs() &lt; VELOCITY_EPSILON;
    position_settled &amp;&amp; velocity_settled
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="animatedvalue-1"><a class="header" href="#animatedvalue-1">AnimatedValue</a></h2>
<p><code>AnimatedValue</code> wraps a spring for easy use in components:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Create an animated value
let scale = ctx.use_animated_value(1.0, SpringConfig::snappy());

// Read current value
let current = scale.lock().unwrap().get();

// Set new target (animates to it)
scale.lock().unwrap().set_target(1.2);

// Set immediately (no animation)
scale.lock().unwrap().set(1.0);
<span class="boring">}</span></code></pre>
<h3 id="sharedanimatedvalue"><a class="header" href="#sharedanimatedvalue">SharedAnimatedValue</a></h3>
<p>For use across closures, values are wrapped in <code>Arc&lt;Mutex&lt;_&gt;&gt;</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let scale = ctx.use_animated_value(1.0, SpringConfig::snappy());

// Clone Arc for closure
let hover_scale = Arc::clone(&amp;scale);

motion()
    .scale(scale.lock().unwrap().get())
    .on_hover_enter(move |_| {
        hover_scale.lock().unwrap().set_target(1.1);
    })
<span class="boring">}</span></code></pre>
<hr>
<h2 id="keyframe-animations-1"><a class="header" href="#keyframe-animations-1">Keyframe Animations</a></h2>
<p>For time-based animations with specific durations:</p>
<h3 id="keyframe-structure"><a class="header" href="#keyframe-structure">Keyframe Structure</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Keyframe {
    time: f32,           // Time in animation (0.0 - 1.0)
    value: f32,          // Value at this keyframe
    easing: EasingFn,    // Interpolation to next keyframe
}
<span class="boring">}</span></code></pre>
<h3 id="easing-functions"><a class="header" href="#easing-functions">Easing Functions</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Easing</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>linear</code></td><td>Constant speed</td></tr>
<tr><td><code>ease_in</code></td><td>Start slow, end fast</td></tr>
<tr><td><code>ease_out</code></td><td>Start fast, end slow</td></tr>
<tr><td><code>ease_in_out</code></td><td>Slow at both ends</td></tr>
<tr><td><code>ease_in_quad</code></td><td>Quadratic ease in</td></tr>
<tr><td><code>ease_out_cubic</code></td><td>Cubic ease out</td></tr>
<tr><td><code>ease_in_out_elastic</code></td><td>Elastic bounce</td></tr>
</tbody>
</table>
</div>
<h3 id="animation-fill-modes"><a class="header" href="#animation-fill-modes">Animation Fill Modes</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Mode</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>None</code></td><td>Revert after animation</td></tr>
<tr><td><code>Forwards</code></td><td>Keep final value</td></tr>
<tr><td><code>Backwards</code></td><td>Apply initial before start</td></tr>
<tr><td><code>Both</code></td><td>Forwards + Backwards</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="timelines"><a class="header" href="#timelines">Timelines</a></h2>
<p>Timelines coordinate multiple animations:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let timeline = ctx.use_animated_timeline();

let entry_id = timeline.lock().unwrap().configure(|t| {
    // Add animation entries
    let rotation_id = t.add(
        0,      // start_ms
        1000,   // duration_ms
        0.0,    // from
        360.0   // to
    );

    // Configure looping
    t.set_loop(-1);  // -1 = infinite loop

    // Start the timeline
    t.start();

    rotation_id
});
<span class="boring">}</span></code></pre>
<h3 id="timeline-features"><a class="header" href="#timeline-features">Timeline Features</a></h3>
<ul>
<li><strong>Stagger</strong> - Delay between child animations</li>
<li><strong>Loop</strong> - Repeat animations</li>
<li><strong>Reverse</strong> - Play backwards</li>
<li><strong>Alternate</strong> - Ping-pong direction</li>
</ul>
<hr>
<h2 id="animation-scheduler"><a class="header" href="#animation-scheduler">Animation Scheduler</a></h2>
<p>A background thread ticks all animations at 120fps:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct AnimationScheduler {
    springs: Vec&lt;SharedAnimatedValue&gt;,
    timelines: Vec&lt;SharedAnimatedTimeline&gt;,
    running: AtomicBool,
    needs_redraw: Arc&lt;AtomicBool&gt;,
    wake_callback: Box&lt;dyn Fn() + Send&gt;,
}
<span class="boring">}</span></code></pre>
<h3 id="scheduler-loop"><a class="header" href="#scheduler-loop">Scheduler Loop</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn run(&amp;self) {
    let frame_duration = Duration::from_secs_f64(1.0 / 120.0);

    while self.running.load(Ordering::SeqCst) {
        let start = Instant::now();

        // Tick all springs
        for spring in &amp;self.springs {
            spring.lock().unwrap().step(frame_duration.as_secs_f32());
        }

        // Tick all timelines
        for timeline in &amp;self.timelines {
            timeline.lock().unwrap().tick(frame_duration);
        }

        // If any animation is active, request redraw
        if self.has_active_animations() {
            self.needs_redraw.store(true, Ordering::SeqCst);
            (self.wake_callback)();  // Wake the main thread
        }

        // Sleep for remaining frame time
        let elapsed = start.elapsed();
        if elapsed &lt; frame_duration {
            thread::sleep(frame_duration - elapsed);
        }
    }
}
<span class="boring">}</span></code></pre>
<h3 id="benefits-of-background-thread"><a class="header" href="#benefits-of-background-thread">Benefits of Background Thread</a></h3>
<ol>
<li><strong>Consistent timing</strong> - Animations run at 120fps regardless of main thread</li>
<li><strong>Survives focus loss</strong> - Continues when window loses focus</li>
<li><strong>Non-blocking</strong> - Doesn’t block UI event processing</li>
<li><strong>Battery efficient</strong> - Only runs when animations are active</li>
</ol>
<hr>
<h2 id="motion-container"><a class="header" href="#motion-container">Motion Container</a></h2>
<p><code>motion()</code> binds animations to elements:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>motion()
    .scale(scale.lock().unwrap().get())      // Read current value
    .opacity(opacity.lock().unwrap().get())
    .translate_y(y.lock().unwrap().get())
    .child(content)
<span class="boring">}</span></code></pre>
<h3 id="how-motion-works"><a class="header" href="#how-motion-works">How Motion Works</a></h3>
<ol>
<li><strong>At build time</strong>: Reads current animation values</li>
<li><strong>Stores binding</strong>: Remembers which animated values to sample</li>
<li><strong>At render time</strong>: Samples current values from scheduler</li>
<li><strong>No rebuild needed</strong>: Animation updates don’t trigger tree rebuilds</li>
</ol>
<h3 id="enterexit-animations"><a class="header" href="#enterexit-animations">Enter/Exit Animations</a></h3>
<p>Motion also provides declarative enter/exit:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>motion()
    .fade_in(300)                           // Fade in over 300ms
    .scale_in(300)                          // Scale from 0 to 1
    .slide_in(SlideDirection::Right, 200)   // Slide from right
    .child(content)
<span class="boring">}</span></code></pre>
<hr>
<h2 id="integration-points"><a class="header" href="#integration-points">Integration Points</a></h2>
<h3 id="with-stateful-elements"><a class="header" href="#with-stateful-elements">With Stateful Elements</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn animated_button(ctx: &amp;WindowedContext) -&gt; impl ElementBuilder {
    let scale = ctx.use_animated_value(1.0, SpringConfig::snappy());
    let hover = Arc::clone(&amp;scale);
    let leave = Arc::clone(&amp;scale);

    motion()
        .scale(scale.lock().unwrap().get())
        .on_hover_enter(move |_| {
            hover.lock().unwrap().set_target(1.05);
        })
        .on_hover_leave(move |_| {
            leave.lock().unwrap().set_target(1.0);
        })
        .child(button_content())
}
<span class="boring">}</span></code></pre>
<h3 id="with-junitacomponent"><a class="header" href="#with-junitacomponent">With JunitaComponent</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(JunitaComponent)]
struct ExpandableCard {
    #[animation]
    height: f32,
    #[animation]
    arrow_rotation: f32,
}

fn card(ctx: &amp;WindowedContext) -&gt; impl ElementBuilder {
    let height = ExpandableCard::use_height(ctx, 60.0, SpringConfig::snappy());
    let rotation = ExpandableCard::use_arrow_rotation(ctx, 0.0, SpringConfig::snappy());

    motion()
        .h(height.lock().unwrap().get())
        .on_click(move |_| {
            height.lock().unwrap().set_target(200.0);
            rotation.lock().unwrap().set_target(180.0);
        })
        .child(card_content())
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="performance-considerations"><a class="header" href="#performance-considerations">Performance Considerations</a></h2>
<ol>
<li><strong>Spring settling</strong> - Stopped springs don’t consume CPU</li>
<li><strong>Batched ticks</strong> - All animations tick together</li>
<li><strong>No allocations</strong> - Animation values are pre-allocated</li>
<li><strong>GPU transforms</strong> - Motion transforms are GPU-accelerated</li>
<li><strong>Minimal redraws</strong> - Only redraw when animations are active</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="stateful-elements--fsm"><a class="header" href="#stateful-elements--fsm">Stateful Elements &amp; FSM</a></h1>
<p>Junita uses <strong>Finite State Machines (FSM)</strong> to manage interactive UI state. This provides predictable state transitions for widgets like buttons, checkboxes, and text fields.</p>
<h2 id="finite-state-machines"><a class="header" href="#finite-state-machines">Finite State Machines</a></h2>
<h3 id="core-concepts-1"><a class="header" href="#core-concepts-1">Core Concepts</a></h3>
<p>An FSM defines:</p>
<ul>
<li><strong>States</strong>: Discrete conditions the element can be in</li>
<li><strong>Events</strong>: Inputs that trigger transitions</li>
<li><strong>Transitions</strong>: Rules mapping (state, event) -&gt; new_state</li>
</ul>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// State IDs and Event IDs are u32
type StateId = u32;
type EventId = u32;

struct Transition {
    from_state: StateId,
    event: EventId,
    to_state: StateId,
    guard: Option&lt;Box&lt;dyn Fn() -&gt; bool&gt;&gt;,  // Conditional transition
    action: Option&lt;Box&lt;dyn Fn()&gt;&gt;,          // Side effect
}
<span class="boring">}</span></code></pre>
<h3 id="fsm-builder"><a class="header" href="#fsm-builder">FSM Builder</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let fsm = StateMachine::builder(initial_state)
    .on(State::Idle, Event::PointerEnter, State::Hovered)
    .on(State::Hovered, Event::PointerLeave, State::Idle)
    .on(State::Hovered, Event::PointerDown, State::Pressed)
    .on(State::Pressed, Event::PointerUp, State::Hovered)
    .on_enter(State::Pressed, || {
        println!("Button pressed!");
    })
    .build();
<span class="boring">}</span></code></pre>
<h3 id="entryexit-callbacks"><a class="header" href="#entryexit-callbacks">Entry/Exit Callbacks</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>.on_enter(state, || { /* called when entering state */ })
.on_exit(state, || { /* called when leaving state */ })
<span class="boring">}</span></code></pre>
<h3 id="guard-conditions"><a class="header" href="#guard-conditions">Guard Conditions</a></h3>
<p>Transitions can be conditional:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>.transition(
    Transition::new(State::Idle, Event::Click, State::Active)
        .with_guard(|| is_enabled())
)
<span class="boring">}</span></code></pre>
<hr>
<h2 id="statetransitions-trait"><a class="header" href="#statetransitions-trait">StateTransitions Trait</a></h2>
<p>For type-safe state definitions, implement <code>StateTransitions</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use junita_layout::stateful::StateTransitions;
use junita_core::events::event_types::*;

#[derive(Clone, Copy, PartialEq, Eq, Hash, Default)]
enum ButtonState {
    #[default]
    Idle,
    Hovered,
    Pressed,
    Disabled,
}

impl StateTransitions for ButtonState {
    fn on_event(&amp;self, event: u32) -&gt; Option&lt;Self&gt; {
        match (self, event) {
            (ButtonState::Idle, POINTER_ENTER) =&gt; Some(ButtonState::Hovered),
            (ButtonState::Hovered, POINTER_LEAVE) =&gt; Some(ButtonState::Idle),
            (ButtonState::Hovered, POINTER_DOWN) =&gt; Some(ButtonState::Pressed),
            (ButtonState::Pressed, POINTER_UP) =&gt; Some(ButtonState::Hovered),
            _ =&gt; None,
        }
    }
}
<span class="boring">}</span></code></pre>
<h3 id="available-event-types"><a class="header" href="#available-event-types">Available Event Types</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Pointer events
POINTER_ENTER    // Mouse enters element
POINTER_LEAVE    // Mouse leaves element
POINTER_DOWN     // Mouse button pressed
POINTER_UP       // Mouse button released
POINTER_MOVE     // Mouse moved over element

// Keyboard events
KEY_DOWN         // Key pressed
KEY_UP           // Key released
TEXT_INPUT       // Character typed

// Focus events
FOCUS            // Element gained focus
BLUR             // Element lost focus

// Other
SCROLL           // Scroll event
DRAG             // Drag motion
DRAG_END         // Drag completed
<span class="boring">}</span></code></pre>
<hr>
<h2 id="stateful-elements-1"><a class="header" href="#stateful-elements-1">Stateful Elements</a></h2>
<h3 id="creating-stateful-elements"><a class="header" href="#creating-stateful-elements">Creating Stateful Elements</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use junita_layout::prelude::*;

fn interactive_card() -&gt; impl ElementBuilder {
    stateful::&lt;ButtonState&gt;()
        .w(200.0)
        .h(120.0)
        .rounded(12.0)
        .on_state(|ctx| {
            let bg = match ctx.state() {
                ButtonState::Idle =&gt; Color::rgba(0.15, 0.15, 0.2, 1.0),
                ButtonState::Hovered =&gt; Color::rgba(0.18, 0.18, 0.25, 1.0),
                ButtonState::Pressed =&gt; Color::rgba(0.12, 0.12, 0.16, 1.0),
                ButtonState::Disabled =&gt; Color::rgba(0.1, 0.1, 0.12, 0.5),
            };
            div().bg(bg).child(text("Hover me").color(Color::WHITE))
        })
}
<span class="boring">}</span></code></pre>
<h3 id="how-it-works-4"><a class="header" href="#how-it-works-4">How It Works</a></h3>
<ol>
<li><strong>Builder creation</strong>: <code>stateful::&lt;S&gt;()</code> creates a StatefulBuilder for state type S</li>
<li><strong>Key generation</strong>: Automatic key based on call site location</li>
<li><strong>Event routing</strong>: Pointer/keyboard events are routed to the FSM</li>
<li><strong>State transition</strong>: FSM computes new state from (current_state, event)</li>
<li><strong>Callback invocation</strong>: <code>on_state</code> callback runs with StateContext</li>
<li><strong>Visual update</strong>: Returned Div is merged onto container</li>
</ol>
<h3 id="statecontext-api"><a class="header" href="#statecontext-api">StateContext API</a></h3>
<p>The callback receives a <code>StateContext</code> with these methods:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>.on_state(|ctx| {
    // Get current state
    let state = ctx.state();

    // Get triggering event (if any)
    if let Some(event) = ctx.event() {
        // Handle specific event types
        match event.event_type {
            POINTER_UP =&gt; println!("Clicked!"),
            _ =&gt; {}
        }
    }

    // Create scoped signals
    let counter = ctx.use_signal("counter", || 0);

    // Create animated values (spring physics)
    let scale = ctx.use_spring("scale", 1.0, SpringConfig::snappy());

    // Create animated timelines (keyframe sequences)
    let (entry_id, timeline) = ctx.use_timeline("fade", |t| {
        let id = t.add(0, 500, 0.0, 1.0);
        t.set_loop(-1);
        t.start();
        id
    });

    // Create keyframe animations with fluent API
    let anim = ctx.use_keyframes("pulse", |k| {
        k.at(0, 0.8).at(800, 1.2).ease(Easing::EaseInOut).ping_pong().loop_infinite()
    });

    // Access dependency values by index
    let value: i32 = ctx.dep(0).unwrap_or_default();

    // Get dependency as State handle
    let state_handle = ctx.dep_as_state::&lt;i32&gt;(0);

    // Dispatch events
    ctx.dispatch(CUSTOM_EVENT);

    div()
})
<span class="boring">}</span></code></pre>
<hr>
<h2 id="built-in-state-types-1"><a class="header" href="#built-in-state-types-1">Built-in State Types</a></h2>
<h3 id="buttonstate-1"><a class="header" href="#buttonstate-1">ButtonState</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum ButtonState {
    Idle,      // Default
    Hovered,   // Mouse over
    Pressed,   // Mouse down
    Disabled,  // Non-interactive
}
<span class="boring">}</span></code></pre>
<p>Transitions:</p>
<ul>
<li>Idle → Hovered (pointer enter)</li>
<li>Hovered → Idle (pointer leave)</li>
<li>Hovered → Pressed (pointer down)</li>
<li>Pressed → Hovered (pointer up)</li>
</ul>
<h3 id="nostate-1"><a class="header" href="#nostate-1">NoState</a></h3>
<p>For elements that only need dependency tracking:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>stateful::&lt;NoState&gt;()
    .deps([signal.signal_id()])
    .on_state(|_ctx| {
        div().child(text("Rebuilds on signal change"))
    })
<span class="boring">}</span></code></pre>
<h3 id="togglestate"><a class="header" href="#togglestate">ToggleState</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum ToggleState {
    Off,
    On,
}
<span class="boring">}</span></code></pre>
<p>Transitions:</p>
<ul>
<li>Off → On (click)</li>
<li>On → Off (click)</li>
</ul>
<h3 id="checkboxstate"><a class="header" href="#checkboxstate">CheckboxState</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum CheckboxState {
    UncheckedIdle,
    UncheckedHovered,
    CheckedIdle,
    CheckedHovered,
}
<span class="boring">}</span></code></pre>
<h3 id="textfieldstate"><a class="header" href="#textfieldstate">TextFieldState</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum TextFieldState {
    Idle,
    Hovered,
    Focused,
    FocusedHovered,
    Disabled,
}
<span class="boring">}</span></code></pre>
<h3 id="scrollstate"><a class="header" href="#scrollstate">ScrollState</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum ScrollState {
    Idle,
    Scrolling,
    Decelerating,
    Bouncing,
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="signal-dependencies"><a class="header" href="#signal-dependencies">Signal Dependencies</a></h2>
<p>Stateful elements can depend on external signals using <code>.deps()</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn counter_display(count: State&lt;i32&gt;) -&gt; impl ElementBuilder {
    stateful::&lt;ButtonState&gt;()
        .deps([count.signal_id()])  // Re-run on_state when count changes
        .on_state(move |ctx| {
            // Access via captured variable
            let value = count.get();

            // Or via context by index
            let value_alt: i32 = ctx.dep(0).unwrap_or_default();

            div().child(
                text(&amp;format!("Count: {}", value)).color(Color::WHITE)
            )
        })
}
<span class="boring">}</span></code></pre>
<h3 id="accessing-dependencies"><a class="header" href="#accessing-dependencies">Accessing Dependencies</a></h3>
<p>Two patterns for accessing dependency values:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Pattern 1: Capture in closure
let my_signal = use_state(|| 42);

stateful::&lt;ButtonState&gt;()
    .deps([my_signal.signal_id()])
    .on_state(move |ctx| {
        let value = my_signal.get();  // Via captured variable
        div()
    })

// Pattern 2: Access via context
stateful::&lt;ButtonState&gt;()
    .deps([my_signal.signal_id()])
    .on_state(|ctx| {
        let value: i32 = ctx.dep(0).unwrap_or_default();  // Via index
        div()
    })
<span class="boring">}</span></code></pre>
<h3 id="when-to-use-deps-1"><a class="header" href="#when-to-use-deps-1">When to Use <code>.deps()</code></a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Without <code>.deps()</code></th><th>With <code>.deps()</code></th></tr>
</thead>
<tbody>
<tr><td>Only runs on state transitions</td><td>Also runs when dependencies change</td></tr>
<tr><td>Hover/press only</td><td>External data + hover/press</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="scoped-state-management"><a class="header" href="#scoped-state-management">Scoped State Management</a></h2>
<p>StateContext provides scoped utilities that persist across rebuilds:</p>
<h3 id="scoped-signals-1"><a class="header" href="#scoped-signals-1">Scoped Signals</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>stateful::&lt;ButtonState&gt;()
    .on_state(|ctx| {
        // Signal keyed as "{stateful_key}:signal:click_count"
        let clicks = ctx.use_signal("click_count", || 0);

        div()
            .child(text(&amp;format!("Clicks: {}", clicks.get())))
            .on_click(move |_| clicks.update(|n| n + 1))
    })
<span class="boring">}</span></code></pre>
<h3 id="springs-use_spring"><a class="header" href="#springs-use_spring">Springs (use_spring)</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>stateful::&lt;ButtonState&gt;()
    .on_state(|ctx| {
        // Target value changes based on state
        let target = match ctx.state() {
            ButtonState::Hovered =&gt; 1.1,
            _ =&gt; 1.0,
        };

        // use_spring automatically animates to target
        let scale = ctx.use_spring("scale", target, SpringConfig::snappy());

        div().transform(Transform::scale(scale, scale))
    })
<span class="boring">}</span></code></pre>
<h3 id="keyframes-use_keyframes"><a class="header" href="#keyframes-use_keyframes">Keyframes (use_keyframes)</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>stateful::&lt;ButtonState&gt;()
    .on_state(|ctx| {
        // Keyframe animation with ping-pong and easing
        let pulse = ctx.use_keyframes("pulse", |k| {
            k.at(0, 0.8)
             .at(800, 1.2)
             .ease(Easing::EaseInOut)
             .ping_pong()
             .loop_infinite()
             .start()
        });

        let scale = pulse.get();
        div().transform(Transform::scale(scale, scale))
    })
<span class="boring">}</span></code></pre>
<h3 id="timelines-use_timeline"><a class="header" href="#timelines-use_timeline">Timelines (use_timeline)</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>stateful::&lt;NoState&gt;()
    .on_state(|ctx| {
        // Timeline with staggered entries
        let ((bar1, bar2), timeline) = ctx.use_timeline("bars", |t| {
            let b1 = t.add_with_easing(0, 500, 0.0, 60.0, Easing::EaseInOut);
            let b2 = t.add_with_easing(100, 500, 0.0, 60.0, Easing::EaseInOut);
            t.set_alternate(true);
            t.set_loop(-1);
            t.start();
            (b1, b2)
        });

        let x1 = timeline.get(bar1).unwrap_or(0.0);
        let x2 = timeline.get(bar2).unwrap_or(0.0);

        div()
            .child(div().transform(Transform::translate(x1, 0.0)))
            .child(div().transform(Transform::translate(x2, 0.0)))
    })
<span class="boring">}</span></code></pre>
<hr>
<h2 id="custom-state-machines-1"><a class="header" href="#custom-state-machines-1">Custom State Machines</a></h2>
<p>For complex interactions, define your own states:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone, Copy, PartialEq, Eq, Hash, Default)]
enum DragState {
    #[default]
    Idle,
    Hovering,
    Pressing,
    Dragging,
}

impl StateTransitions for DragState {
    fn on_event(&amp;self, event: u32) -&gt; Option&lt;Self&gt; {
        match (self, event) {
            (DragState::Idle, POINTER_ENTER) =&gt; Some(DragState::Hovering),
            (DragState::Hovering, POINTER_LEAVE) =&gt; Some(DragState::Idle),
            (DragState::Hovering, POINTER_DOWN) =&gt; Some(DragState::Pressing),
            (DragState::Pressing, DRAG) =&gt; Some(DragState::Dragging),
            (DragState::Pressing, POINTER_UP) =&gt; Some(DragState::Hovering),
            (DragState::Dragging, DRAG_END) =&gt; Some(DragState::Idle),
            _ =&gt; None,
        }
    }
}

fn draggable_element() -&gt; impl ElementBuilder {
    stateful::&lt;DragState&gt;()
        .on_state(|ctx| {
            let bg = match ctx.state() {
                DragState::Idle =&gt; Color::BLUE,
                DragState::Hovering =&gt; Color::CYAN,
                DragState::Pressing =&gt; Color::YELLOW,
                DragState::Dragging =&gt; Color::GREEN,
            };
            div().w(100.0).h(100.0).bg(bg)
        })
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="event-routing"><a class="header" href="#event-routing">Event Routing</a></h2>
<h3 id="event-flow"><a class="header" href="#event-flow">Event Flow</a></h3>
<pre><code class="language-text">Platform Event (pointer, keyboard)
    │
    ├── Hit test: which element?
    │
    ├── EventRouter dispatches to element
    │
    ├── StateMachine receives event
    │   └── Computes transition
    │
    └── on_state callback invoked
</code></pre>
<h3 id="event-context"><a class="header" href="#event-context">Event Context</a></h3>
<p>Handlers receive event details:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>.on_click(|ctx| {
    println!("Clicked at ({}, {})", ctx.local_x, ctx.local_y);
})
.on_key_down(|ctx| {
    if ctx.ctrl &amp;&amp; ctx.key_code == 83 {  // Ctrl+S
        save();
    }
})
<span class="boring">}</span></code></pre>
<hr>
<h2 id="performance"><a class="header" href="#performance">Performance</a></h2>
<h3 id="why-fsm-over-signals"><a class="header" href="#why-fsm-over-signals">Why FSM Over Signals?</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Signals for visual state</th><th>FSM for visual state</th></tr>
</thead>
<tbody>
<tr><td>Triggers full rebuild</td><td>Updates only affected element</td></tr>
<tr><td>Creates new VDOM</td><td>Mutates existing element</td></tr>
<tr><td>O(tree size)</td><td>O(1)</td></tr>
</tbody>
</table>
</div>
<h3 id="minimal-updates"><a class="header" href="#minimal-updates">Minimal Updates</a></h3>
<p>Stateful elements only update their own RenderProps:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// State change only affects this element
.on_state(|ctx| {
    div().bg(new_color)  // Updates RenderProps
    // No layout recomputation
    // No tree diff
    // Just visual update
})
<span class="boring">}</span></code></pre>
<h3 id="queued-updates"><a class="header" href="#queued-updates">Queued Updates</a></h3>
<p>State changes queue updates efficiently:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>static PENDING_PROP_UPDATES: Vec&lt;(NodeId, RenderProps)&gt;;

// Stateful callback queues update
fn on_state(ctx) -&gt; Div {
    div().bg(color)
    // Queues: (node_id, updated_props)
}

// Processed in batch by windowed app
for (node_id, props) in drain_pending() {
    render_tree.update_props(node_id, props);
}
<span class="boring">}</span></code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
